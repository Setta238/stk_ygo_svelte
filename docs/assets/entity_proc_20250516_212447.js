var Wi=Object.defineProperty;var Qi=(t,e,i)=>e in t?Wi(t,e,{enumerable:!0,configurable:!0,writable:!0,value:i}):t[e]=i;var o=(t,e,i)=>Qi(t,typeof e!="symbol"?e+"":e,i);import{j as Xi}from"./json_20250516_212447.js";class jr{constructor(e,i,a){o(this,"_dbname");o(this,"_dbversion");o(this,"dbPromise");o(this,"getTran",async(e,i)=>(await this.dbPromise).transaction(e,i));o(this,"reset",async()=>(await indexedDB.databases().then(e=>{console.log(e)}),await new Promise((e,i)=>{const a=indexedDB.deleteDatabase(this._dbname);a.onsuccess=()=>{console.log("onsuccess"),e()},a.onerror=n=>{console.log("onerror"),i(n)}})));o(this,"getAll",async e=>{const i=await this.dbPromise;return new Promise((a,n)=>{const l=i.transaction([e],"readonly").objectStore(e).getAll();l.onsuccess=()=>{a(l.result)},l.onerror=u=>{n(u)}})});o(this,"get",async(e,i)=>{const a=await this.dbPromise;return new Promise((n,r)=>{const u=a.transaction([e],"readonly").objectStore(e).get(i);u.onsuccess=()=>{n(u.result)},u.onerror=c=>{r(c)}})});o(this,"getMany",async(e,i)=>{const r=(await this.dbPromise).transaction([e],"readonly").objectStore(e),s=i.map(l=>new Promise((u,c)=>{const d=r.get(l);d.onsuccess=()=>{u(d.result)},d.onerror=p=>{c(p)}}));return await Promise.all(s)});o(this,"putRecords",async(e,i)=>{const n=(await this.dbPromise).transaction([e],"readwrite"),r=n.objectStore(e),s=i.map(l=>({record:l,request:r.put(l)}));return new Promise((l,u)=>{n.oncomplete=()=>l(s.map(c=>Object.assign({id:c.request.result},c.record))),n.onerror=c=>u(c)})});o(this,"deleteRecords",async(e,i)=>{const n=(await this.dbPromise).transaction([e],"readwrite"),r=n.objectStore(e),s=i.map(l=>({key:l,request:r.delete(l)}));return new Promise((l,u)=>{n.oncomplete=()=>{console.log(s.map(c=>c.request.result)),l()},n.onerror=c=>u(c)})});this._dbname=e,this._dbversion=i,this.dbPromise=new Promise((n,r)=>{const s=indexedDB.open(e,i);s.onsuccess=l=>{if(console.log(l),!l.target){console.log("event.target is undefined"),r("event.target is undefined");return}const u=l.target.result;if(!u){console.log("event.target.result is undefined"),r("event.target.result is undefined");return}u.onversionchange=c=>{console.log(c),u.close()},n(u)},s.onupgradeneeded=l=>{console.log("onupgradeneeded");const u=l.target.result;a.filter(c=>!u.objectStoreNames.contains(c)).map(c=>u.createObjectStore(c,{keyPath:"id",autoIncrement:!0}))},s.onerror=l=>{console.log(l),r(l)},s.onblocked=l=>{console.log(l),r(l)}}),console.log(this.dbPromise)}get dbversion(){return this._dbversion}}class B{constructor(){o(this,"handlers",[])}get length(){return this.handlers.length}append(e){this.handlers.push(e)}remove(e){this.handlers=this.handlers.filter(i=>i!==e)}trigger(e){this.handlers.slice(0).filter(i=>i(e)==="RemoveMe").forEach(i=>this.remove(i))}clear(){this.handlers.splice(0)}expose(){return this}}class pt{constructor(){o(this,"handlers",[])}append(e){this.handlers.push(e)}remove(e){this.handlers=this.handlers.filter(i=>i!==e)}async trigger(e){(await Promise.all(this.handlers.slice(0).map(async a=>{const n=await a(e);return{h:a,result:n}}))).filter(a=>a.result==="RemoveMe").map(a=>a.h).forEach(a=>this.remove(a))}clear(){this.handlers.splice(0)}expose(){return this}}class ft{constructor(){o(this,"handler")}set(e){this.handler=e}async call(e){if(!this.handler)throw Error("illegal state error");return await this.handler(e)}expose(){return this}}class tt{constructor(e,i,a,n){o(this,"_name");o(this,"_createVersion");o(this,"mountResolver",()=>{});o(this,"_indexedDb");o(this,"onInsertEvent",new B);o(this,"onBeforeInsertEvent",new ft);o(this,"onUpdateEvent",new B);o(this,"onBeforeUpdateEvent",new ft);o(this,"onDeleteEvent",new B);o(this,"prepareInitialRecords",()=>{const e=new Date;return this._prepareInitialRecords().map(i=>Object.assign(i,{createdAt:e,updatedAt:e,dbVersion:this._createVersion}))});o(this,"resolveMount",()=>this.mountResolver());o(this,"patchForInsert",(e,i)=>{e.newRecords.forEach(a=>{i[a.id]=a})});o(this,"patchForUpdate",(e,i)=>{e.recordPairs.forEach(a=>{i[a.newRecord.id]={...a.newRecord}})});o(this,"patchForDelete",(e,i)=>{e.oldRecords.forEach(a=>{delete i[a.id]})});this._indexedDb=e,this._name=i,this._createVersion=e.dbversion,this.getAll().then(r=>r.reduce((s,l)=>(s[l.id]=l,s),{})).then(r=>{console.log(this.name,r),this.onBeforeInsertEvent.set(a??(()=>Promise.resolve())),this.onBeforeUpdateEvent.set(n??(()=>Promise.resolve()))})}get name(){return this._name}get createVersion(){return this._createVersion}get oninsert(){return this.onInsertEvent.expose()}get onbeforeinsert(){return this.onBeforeInsertEvent.expose()}get onupdate(){return this.onUpdateEvent.expose()}get onbeforeupdate(){return this.onBeforeUpdateEvent.expose()}get ondelete(){return this.onDeleteEvent.expose()}getAll(){return this._indexedDb.getAll(this.name)}get(e){return this._indexedDb.get(this.name,e)}async insertMany(e){const i=new Date,a=e.map(r=>{const s={createdAt:i,updatedAt:i,dbVersion:this._createVersion};return Object.assign(r,s)});await this.onBeforeInsertEvent.call({sender:this,newRecords:a,timestamp:i});const n=await this._indexedDb.putRecords(this.name,a);return this.onInsertEvent.trigger({sender:this,newRecords:n,timestamp:i}),n}async insert(e){return(await this.insertMany([e]))[0]}async updateMany(e,i){const a=new Date,n=[];return(await this._indexedDb.getMany(this.name,e)).forEach(s=>{const l={...s},u={...l};n.push({newRecord:Object.assign(i(u),{updatedAt:a,dbVersion:this._createVersion}),oldRecord:l})}),await this.onBeforeUpdateEvent.call({sender:this,recordPairs:n,timestamp:a}),await this._indexedDb.putRecords(this.name,n.map(s=>s.newRecord)),this.onUpdateEvent.trigger({sender:this,recordPairs:n,timestamp:a}),n.map(s=>s.newRecord)}async update(e,i){return(await this.updateMany([e],i))[0]}async delete(e){const i=new Date,a=await this._indexedDb.getMany(this.name,e);await this._indexedDb.deleteRecords(this.name,e),this.onDeleteEvent.trigger({sender:this,oldRecords:a,timestamp:i})}}const Ur=["Deck","ExtraDeck"],Vr={Deck:"メインデッキ",ExtraDeck:"エクストラデッキ"},Ki=["Monster","Spell","Trap","XyzMaterial"],zr={Monster:"モンスター",Spell:"魔法",Trap:"罠",XyzMaterial:"XYZ素材"},be=["Fusion","Syncro","Xyz","Link"],Dt=[...be,"SpecialSummon","Ritual"],Pt=[...Dt,"NormalSummonOnly","RegularSpecialSummonOnly","FreeReborn"],Ji=["Toon","Spirit","Union","Gemini","FlipEffect"],Yi=["Tuner","Effect","Normal","Pendulum","Token"],Wr=[...Ji,...Yi,...Pt],Qr={Syncro:"シンクロ",Fusion:"融合",Xyz:"エクシーズ",Link:"リンク",Ritual:"儀式",SpecialSummon:"特殊召喚",Toon:"トゥーン",Spirit:"スピリット",Union:"ユニオン",Gemini:"デュアル",FlipEffect:"リバース",Tuner:"チューナー",Effect:"効果",Normal:"通常",Pendulum:"ペンデュラム",Token:"トークン",FreeReborn:"特殊召喚モンスター（蘇生制限なし）",NormalSummonOnly:"特殊召喚不可",RegularSpecialSummonOnly:"正規の方法以外での特殊召喚不可"},Xr={Syncro:"🎵",Fusion:"🌀",Xyz:"📰",Link:"⛓️",Ritual:"📜",SpecialSummon:"🔯",Toon:"📖",Spirit:"👻",Union:"🚗",Gemini:"👫",FlipEffect:"🔄",Tuner:"🎶",Effect:"✨",Normal:"🔘",Pendulum:"💠",Token:"🐏",FreeReborn:"🆓",NormalSummonOnly:"🔲",RegularSpecialSummonOnly:"❗"},Kr=["Light","Dark","Earth","Water","Fire","Wind","Divine"],Jr={Light:"光",Dark:"闇",Earth:"地",Water:"水",Fire:"炎",Wind:"風",Divine:"神"},Yr=["Aqua","Beast","BeastWarrior","CreatorGod","Cyberse","Dinosaur","DivineBeast","Dragon","Fairy","Fiend","Fish","Insect","Illusion","Machine","Plant","Psychic","Pyro","Reptile","Rock","SeaSerpent","Spellcaster","Thunder","Warrior","WingedBeast","Wyrm","Zombie"],Ir=["Normal","Continuous","Field","QuickPlay","Equip","Ritual","PendulumScale"],es={Normal:"通常",Continuous:"永続",Field:"フィールド",QuickPlay:"速攻",Equip:"装備",Ritual:"儀式",PendulumScale:"ペンデュラム"},ts=["Normal","Continuous","Counter"],is={Normal:"通常",Continuous:"永続",Counter:"カウンター"},S=["Attack","Defense"],we={Attack:"攻撃表示",Defense:"守備表示",Set:"裏側守備表示"},Mt=["level","rank","attack","defense","pendulumScaleR","pendulumScaleL"],as={Aqua:"水",Beast:"獣",BeastWarrior:"獣戦士",CreatorGod:"創造神",Cyberse:"サイバース",Dinosaur:"恐竜",DivineBeast:"幻獣神",Dragon:"ドラゴン",Fairy:"天使",Fiend:"悪魔",Fish:"魚",Insect:"昆虫",Illusion:"幻想魔",Machine:"機械",Plant:"植物",Psychic:"サイキック",Pyro:"炎",Reptile:"爬虫類",Rock:"岩石",SeaSerpent:"海竜",Spellcaster:"魔法使い",Thunder:"雷",Warrior:"戦士",WingedBeast:"鳥獣",Wyrm:"幻竜",Zombie:"アンデット"},ns={Aqua:"🚰",Beast:"🐅",BeastWarrior:"🦁",CreatorGod:"🔆",Cyberse:"💻️",Dinosaur:"🦖",DivineBeast:"💫",Dragon:"🐲",Fairy:"👼",Fiend:"👿",Fish:"🐟️",Insect:"🦋",Illusion:"🤡",Machine:"🤖",Plant:"🌱",Psychic:"👁️",Pyro:"🔥",Reptile:"🦎",Rock:"⛰",SeaSerpent:"🐍",Spellcaster:"🧙",Thunder:"⚡️",Warrior:"⚔️",WingedBeast:"🦅",Wyrm:"🐉",Zombie:"🦴"},Ii=["TopLeft","TopCenter","TopRight","MiddleLeft","MiddleRight","BottomLeft","BottomCenter","BottomRight"],At={TopLeft:{name:"左上",linkArrow:{offsetRow:-1,offsetColumn:-1}},TopCenter:{name:"上",linkArrow:{offsetRow:-1,offsetColumn:0}},TopRight:{name:"右上",linkArrow:{offsetRow:-1,offsetColumn:1}},MiddleLeft:{name:"左",linkArrow:{offsetRow:0,offsetColumn:-1}},MiddleRight:{name:"右",linkArrow:{offsetRow:0,offsetColumn:1}},BottomLeft:{name:"左下",linkArrow:{offsetRow:1,offsetColumn:-1}},BottomCenter:{name:"下",linkArrow:{offsetRow:1,offsetColumn:0}},BottomRight:{name:"右下",linkArrow:{offsetRow:1,offsetColumn:1}}};Ii.reduce((t,e)=>(t[At[e].name]=e,t),{});const rs=t=>t.cardId??!1?`https://www.db.yugioh-card.com/yugiohdb/card_search.action?ope=2&cid=${t.cardId}`:`https://www.db.yugioh-card.com/yugiohdb/card_search.action?ope=1&sess=1&rp=10&mode=&sort=1&keyword=${t.name}&stype=1&ctype=&othercon=2&starfr=&starto=&pscalefr=&pscaleto=&linkmarkerfr=&linkmarkerto=&link_m=2&atkfr=&atkto=&deffr=&defto=&releaseDStart=1&releaseMStart=1&releaseYStart=1999&releaseDEnd=&releaseMEnd=&releaseYEnd=`,xt=(t,e)=>{const i=t.monsterCategories??[],a=e.monsterCategories??[];for(const n of be.toReversed()){if(i.includes(n)&&!a.includes(n))return 1;if(!i.includes(n)&&a.includes(n))return-1}if(t.kind===e.kind){if(t.kind==="Monster"){if((t.link??0)!==(e.link??0))return(t.link??0)-(e.link??0);if((t.rank??0)!==(e.rank??0))return(t.rank??0)-(e.rank??0);if((t.level??0)!==(e.level??0))return(t.level??0)-(e.level??0);if((t.attack??0)!==(e.attack??0))return(t.attack??0)-(e.attack??0);if((t.defense??0)!==(e.defense??0))return(t.defense??0)-(e.defense??0)}return t.name.localeCompare(e.name,"Ja")}for(const n of Ki){if(t.kind===n)return-1;if(e.kind===n)return 1}return t.name.localeCompare(e.name,"Ja")},Ft=["Deck","ExtraDeck"],Nt=["Graveyard","Banished"],Bt=[...Ft,...Nt],ea=[...Bt,"Hand"],R=["MonsterZone","ExtraMonsterZone"],ye=["SpellAndTrapZone","FieldSpellZone"],Y=[...R,...ye],Ot=["XyzMaterialZone","WaitingRoom"],I=[...ea,...Y,...Ot],ze={0:{0:"Hand"},1:{0:"Deck",1:"SpellAndTrapZone",2:"SpellAndTrapZone",3:"SpellAndTrapZone",4:"SpellAndTrapZone",5:"SpellAndTrapZone",6:"ExtraDeck"},2:{0:"Graveyard",1:"MonsterZone",2:"MonsterZone",3:"MonsterZone",4:"MonsterZone",5:"MonsterZone",6:"FieldSpellZone"},3:{0:"Banished",1:"XyzMaterialZone",2:"ExtraMonsterZone",3:"WaitingRoom",4:"ExtraMonsterZone",5:"XyzMaterialZone",6:"Banished"},4:{0:"FieldSpellZone",1:"MonsterZone",2:"MonsterZone",3:"MonsterZone",4:"MonsterZone",5:"MonsterZone",6:"Graveyard"},5:{0:"ExtraDeck",1:"SpellAndTrapZone",2:"SpellAndTrapZone",3:"SpellAndTrapZone",4:"SpellAndTrapZone",5:"SpellAndTrapZone",6:"Deck"},6:{0:"Hand"}};class ta{constructor(e,i,a,n){o(this,"onUpdateEvent",new B);o(this,"field");o(this,"row");o(this,"column");o(this,"cellType");o(this,"_owner");o(this,"_requiresRecalcLinkArrows");o(this,"_linkArrowSources");o(this,"_needsShuffle",!1);o(this,"recalcLinkArrows",()=>{this.isMonsterZoneLikeCell&&(this._requiresRecalcLinkArrows=!1,this._linkArrowSources=this.neighbors.filter(e=>e.isMonsterZoneLikeCell).filter(e=>e.cardEntities.length).filter(e=>e.cardEntities[0].linkArrows.some(i=>this.row===e.row+i.offsetRow&&this.column===e.column+i.offsetColumn)).map(e=>e.cardEntities[0]))});o(this,"_entities");o(this,"releaseEntities",e=>{var i;return this._entities=this._entities.filter(a=>a!==e),this.isMonsterZoneLikeCell&&((i=e.origin.monsterCategories)!=null&&i.includes("Link"))&&(this._requiresRecalcLinkArrows=!0),this.onUpdateEvent.trigger(),e});o(this,"acceptEntities",(e,i)=>{var a;if(i==="Fix"){if(!this._entities.includes(e))throw new v("引数とセルの状態が矛盾している。",this,e,i)}else i==="Top"?this._entities.unshift(e):this._entities.push(e),i==="Random"&&(console.log(this._needsShuffle,i),this._needsShuffle=!0),this._entities.forEach(n=>{n.fieldCell=this}),this.isMonsterZoneLikeCell&&((a=e.origin.monsterCategories)!=null&&a.includes("Link"))&&(this._requiresRecalcLinkArrows=!0);this.onUpdateEvent.trigger()});o(this,"shuffle",()=>{this._entities=this.entities.shuffle(),this._needsShuffle=!1,this.field.duel.log.info("デッキをシャッフル。",this.owner)});o(this,"toString",()=>this.isMonsterZoneLikeCell||this.cellType==="SpellAndTrapZone"?`${this.cellType}(${this.row},${this.column})`:this.cellType);this.field=e,this.row=i,this.column=a,this.cellType=ze[i][a],this._owner=n,this._entities=[],this._linkArrowSources=[],this._requiresRecalcLinkArrows=!1}get onUpdate(){return this.onUpdateEvent.expose()}get owner(){var e;return this._owner||((e=this.cardEntities[0])==null?void 0:e.owner)}get requiresRecalcLinkArrows(){return this._requiresRecalcLinkArrows}get linkArrowSources(){return this._linkArrowSources}get needsShuffle(){return this._needsShuffle}get entities(){return this._entities}get visibleEntities(){return this._entities.filter(e=>mt.find(i=>i===e.entityType))}get cardEntities(){return this._entities.filter(e=>mt.find(i=>i===e.entityType)).filter(e=>e.kind!=="XyzMaterial")}get xyzMaterials(){return this._entities.filter(e=>e.kind==="XyzMaterial")}get targetForAttack(){return this.cellType==="Hand"?this._entities.find(e=>e.entityType==="Duelist"):this.cardEntities[0]}get isAvailable(){return this.cardEntities.length===0&&this._entities.filter(e=>Za.find(i=>i===e.entityType)).length===0}get isAvailableForPendulum(){return this.isAvailable&&this.isSpellTrapZoneLikeCell&&(this.column===1||this.column===5)}get isStackCell(){return Bt.some(e=>e===this.cellType)}get isPlayFieldCell(){return Y.some(e=>e===this.cellType)}get isMonsterZoneLikeCell(){return R.some(e=>e===this.cellType)}get isSpellTrapZoneLikeCell(){return ye.some(e=>e===this.cellType)}get isDisabledCell(){return Ot.some(e=>e===this.cellType)}get isTrashCell(){return Nt.some(e=>e===this.cellType)}get neighbors(){const e=[this.row-1,this.row,this.row+1].filter(a=>a>=0&&a<=6),i=[this.column-1,this.column,this.column+1].filter(a=>a>=0&&a<=6);return e.flatMap(a=>i.map(n=>this.field.cells[a][n])).filter(a=>a.isMonsterZoneLikeCell).filter(a=>a!==this)}}Array.prototype.shuffle=function(){return this.map(e=>({item:e,seq:Math.random()})).toSorted((e,i)=>e.seq-i.seq).map(e=>e.item)};Array.prototype.randomPickMany=function(t){return this.shuffle().slice(0,t)};Array.prototype.randomPick=function(){return this.shuffle().slice(0,1)[0]};Array.prototype.reset=function(...t){this.splice(0),this.push(...t)};Array.prototype.union=function(t){return this.filter(e=>t.find(i=>e===i))};Array.prototype.getAllOnOffPattern=function*(){const t=[[]];yield[];for(const e of this){const i=t.map(a=>[...a,e]);yield*i,t.push(...i)}};Array.prototype.getDistinct=function(){return Array.from(new Set(this))};Array.prototype.distinct=function(){this.reset(...this.getDistinct())};class Se{constructor(){o(this,"pooledOperators",[]);o(this,"bundles",[]);o(this,"excludesExpired",()=>{this.bundles.forEach(e=>e.excludesExpired()),this.pooledOperators=this.pooledOperators.filter(e=>e.validateAlive())});o(this,"append",e=>{this.bundles.push(e)});o(this,"push",e=>{if(!e.isContinuous)throw new v("staticへの追加は永続以外不可",e);this.excludesExpired(),this.distribute(e),this.pooledOperators.push(e)});o(this,"distributeAll",e=>(this.excludesExpired(),this.pooledOperators.flatMap(this.distribute).getDistinct().forEach(i=>i.operators.sort((a,n)=>a.seq-n.seq)),this.afterDistributeAll(e)));o(this,"distribute",e=>this.bundles.filter(i=>i.entity.exist).filter(i=>i.operators.every(a=>a.seq!==e.seq)).filter(i=>e.isApplicableTo(i.entity)).filter(i=>i.entity.canBeEffected(e.effectOwner,e.isSpawnedBy,e.actionAttr)).map(i=>(i.push(e),i)));o(this,"removeItem",e=>{this.pooledOperators=this.pooledOperators.filter(i=>i.seq!==e)})}}class Ce{constructor(e,i){o(this,"pool");o(this,"entity");o(this,"_operators");o(this,"excludesExpired",()=>{this._operators=this._operators.filter(e=>{const i=e.validateAlive()&&e.isApplicableTo(this.entity);return i||(console.info(`before remove ${this.entity.toString} ${e.title}`),e.beforeRemove(this)),i})});o(this,"push",e=>{this.entity.procFilterBundle.effectiveOperators.filter(i=>i.procTypes.includes("Effect")).some(i=>!i.filter(i.effectOwner,i.isSpawnedBy,i.actionAttr,[]))||(this.beforePush(e),this._operators.push(e))});o(this,"removeItem",e=>{this._operators=this._operators.filter(i=>i.seq!==e?!0:(i.beforeRemove(this),!1))});this.pool=e,this.entity=i,this._operators=[],this.pool.append(this)}get operators(){return this._operators}get effectiveOperators(){return this.operators.filter(e=>e.isSpawnedBy.isEffective||!e.isContinuous)}}const Ne=class Ne{constructor(e,i,a,n,r,s){o(this,"seq");o(this,"title");o(this,"validateAlive");o(this,"isContinuous");o(this,"isSpawnedBy");o(this,"isSpawnedAt");o(this,"activateType");o(this,"actionAttr");o(this,"isApplicableTo");o(this,"effectOwner");this.seq=Ne.nextSeq++,this.title=e,this.validateAlive=()=>i(this),this.isContinuous=a,this.isSpawnedBy=n,this.isSpawnedAt=n.duel.clock.getClone(),this.isApplicableTo=l=>s(this,l),this.actionAttr=r,this.activateType=this.actionAttr.playType?tn(this.actionAttr.playType):"NonActivate",this.effectOwner=this.isSpawnedBy.controller}get isEffective(){return!this.isContinuous||this.activateType==="NonActivate"?!0:this.isSpawnedBy.isEffective}};o(Ne,"nextSeq",0);let oe=Ne;class ia extends Se{constructor(){super(...arguments);o(this,"afterDistributeAll",()=>this.bundles.every(i=>i.applyEffectFilter()))}}class aa extends Ce{constructor(){super(...arguments);o(this,"applyEffectFilter",()=>{const i=this.entity.allStickyEffectOperators.length,a=[];for(;;){const n=this.effectiveOperators.filter(r=>r.procTypes.includes("Effect")).filter(r=>r.isContinuous).find(r=>!a.includes(r.seq));if(!n)break;a.push(n.seq),n.eraseOperators(this.entity)}return this.entity.allStickyEffectOperators.length===i});o(this,"beforePush",i=>i.eraseOperators(this.entity))}}const pe=class pe extends oe{constructor(i,a,n,r,s,l,u,c){super(i,a,n,r,s,l);o(this,"beforeRemove",()=>{});o(this,"procTypes");o(this,"filter");o(this,"eraseOperators",i=>{if(!this.procTypes.includes("Effect"))return 0;const a=i.allStickyEffectOperators.filter(n=>n.isContinuous).filter(n=>!this.filter(n.effectOwner,n.isSpawnedBy,n.actionAttr,[])).map(n=>n.seq);return a.forEach(i.procFilterBundle.removeItem),a.forEach(i.statusOperatorBundle.removeItem),a.forEach(i.numericOprsBundle.removeItem),a.length});this.procTypes=u,this.filter=c}};o(pe,"createContinuous",(i,a,n,r,s,l,u)=>new pe(i,a,!0,n,r,s,l,u)),o(pe,"createLingering",(i,a,n,r,s,l,u)=>new pe(i,a,!1,n,r,s,l,u));let me=pe;const ht={level:1,rank:1,attack:0,defense:0,pendulumScaleR:0,pendulumScaleL:0};class na extends Se{constructor(){super(...arguments);o(this,"afterDistributeAll",i=>{if(this.bundles.forEach(n=>n.calcStateAll()),i.field.getMonstersOnFieldStrictly().flatMap(n=>n.numericOprsBundle).flatMap(n=>n.effectiveOperators).some(n=>n.targetStateGen==="calculated")){const r=i.field.getMonstersOnFieldStrictly().filter(s=>(s.atk??0)>=0).map(s=>s.atk??0).reduce((s,l)=>s>l?s:l,0);i.field.getMonstersOnFieldStrictly().forEach(s=>{s.numericOprsBundle.effectiveOperators.filter(l=>l.targetStateGen==="calculated").forEach(l=>{var u;if(!((u=s.status.monsterCategories)!=null&&u.includes("Link")&&l.targetState==="defense")){if(l.stateOperationType==="THE_DEVILS_AVATAR"){s.numericStatus.calculated[l.targetState]=r+100;return}s.numericStatus.calculated[l.targetState]=l.calcValue(s,s.numericStatus.calculated[l.targetState]??0)}})})}return!0})}}class ra extends Ce{constructor(){super(...arguments);o(this,"beforePush",i=>{const a=this.effectiveOperators.filter(r=>r.targetState===i.targetState).filter(r=>r.isEffective);if(i.kind==="O-L-F"||i.kind==="O-C-F"?(a.filter(r=>r.kind==="O-L-F").forEach(r=>r.negate()),a.filter(r=>r.kind==="L-F").forEach(r=>r.negate())):i.kind==="L-F"||i.kind==="C-F"?a.filter(r=>r.kind==="L-F"||r.kind==="L-A").forEach(r=>r.negate()):i.kind==="X-C-X"&&a.filter(r=>!r.isContinuous).forEach(r=>r.negate()),a.filter(r=>r.isEffective).some(r=>r.kind==="X-C-X")&&!i.isContinuous)return;if(i.stateOperationType!=="Addition"&&i.targetStateGen==="wip"&&a.filter(r=>!r.isContinuous).forEach(r=>r.negate()),i.stateOperationType==="THE_DEVILS_AVATAR"||i.stateOperationType==="Gradius'_Option"){this.entity.numericStatus.calculated[i.targetState]=-Number.MAX_VALUE;return}const n=this.entity.numericStatus.calculated[i.targetState]??0;if(i.stateOperationType==="THE_DEVILS_DREAD-ROOT"){this.entity.numericStatus.calculated[i.targetState]=i.calcValue(this.entity,n);return}if(i.kind==="L-F"){this.entity.numericStatus.wip[i.targetState]=i.calcValue(this.entity,n);return}});o(this,"calcStateAll",()=>Mt.forEach(this.calcState));o(this,"calcState",i=>{if(this.entity.kind!=="Monster"&&!this.entity.isPendulumScale){this.entity.numericStatus.calculated[i]=void 0;return}if(!this.entity.status.monsterCategories){this.entity.numericStatus.calculated[i]=void 0;return}if(this.entity.status.monsterCategories.includes("Link")&&i!=="attack"){this.entity.numericStatus.calculated[i]=void 0;return}if(this.entity.status.monsterCategories.includes("Xyz")&&i==="level"){this.entity.numericStatus.calculated[i]=void 0;return}if(!this.entity.status.monsterCategories.includes("Xyz")&&i==="rank"){this.entity.numericStatus.calculated[i]=void 0;return}if(!this.entity.status.monsterCategories.includes("Pendulum")&&(i==="pendulumScaleL"||i==="pendulumScaleR")){this.entity.numericStatus.calculated[i]=void 0;return}if(i!=="level"&&!this.entity.isOnFieldStrictly){this.entity.numericStatus.origin[i]=this.entity.origin[i],this.entity.numericStatus.wip[i]=this.entity.origin[i],this.entity.numericStatus.calculated[i]=this.entity.origin[i];return}const a=this.entity.origin[i]??0,n=this.entity.numericStatus.wip[i]??0,r=this._operators.filter(d=>d.targetState===i).filter(d=>d.isEffective);if(r.some(d=>d.stateOperationType==="THE_DEVILS_AVATAR"||d.stateOperationType==="Gradius'_Option")&&this.entity.isEffective){this.entity.numericStatus.calculated[i]=-Number.MAX_VALUE;return}const s=r.filter(d=>d.targetState===i).findLast(d=>d.targetStateGen==="origin"),l=s?s.calcValue(this.entity,a??0):a;this.entity.numericStatus.origin[i]=l;let u=l;const c=r.filter(d=>d.targetState===i).filter(d=>d.targetStateGen==="wip").findLast(d=>d.stateOperationType==="Fixation");if(!c)u=r.filter(d=>d.stateOperationType==="Addition").reduce((d,p)=>p.calcValue(this.entity,d),u),this.entity.numericStatus.wip[i]=u;else if(c.isContinuous)u=c.calcValue(this.entity,u),u=r.filter(d=>d.stateOperationType==="Addition").reduce((d,p)=>p.calcValue(this.entity,d),u),this.entity.numericStatus.wip[i]=u;else{let d=!1;u=r.filter(p=>(d=d||p===c,d&&p!==c)).filter(p=>p.stateOperationType==="Addition").reduce((p,f)=>f.calcValue(this.entity,p),n)}u<ht[i]&&(u=ht[i]),this.entity.numericStatus.calculated[i]=u})}}const W=class W extends oe{constructor(i,a,n,r,s,l,u,c,d,p){super(i,a,n,r,s,l);o(this,"beforeRemove",()=>{});o(this,"targetState");o(this,"targetStateGen");o(this,"stateOperationType");o(this,"calcValue");o(this,"_isEffective");o(this,"negate",()=>{this._isEffective=!1});this._isEffective=!0,this.targetState=u,this.targetStateGen=c,this.stateOperationType=d,this.calcValue=(f,g)=>p(this.isSpawnedBy,f,g)}get isEffective(){return this._isEffective&&super.isEffective}get kind(){if(this.targetStateGen==="origin"){if(this.stateOperationType==="Fixation")return this.isContinuous?"O-C-F":"O-L-F";throw new v("矛盾したプロパティ",this)}if(this.targetStateGen==="wip"){if(this.stateOperationType==="Addition")return this.isContinuous?"C-A":"L-A";if(this.stateOperationType==="Fixation")return this.isContinuous?"C-F":"L-F";throw new v("矛盾したプロパティ",this)}if(this.stateOperationType==="THE_DEVILS_DREAD-ROOT")return"X-C-F";if(this.stateOperationType==="THE_DEVILS_AVATAR"||this.stateOperationType==="Gradius'_Option")return"X-C-X";throw new v("矛盾したプロパティ",this)}};o(W,"createContinuous",(i,a,n,r,s,l,u,c)=>new W(i,a,!0,n,{},r,s,l,u,c)),o(W,"createLingering",(i,a,n,r,s,l,u)=>new W(i,a,!1,n,r,(c,d)=>d.isOnFieldAsMonsterStrictly,s,"wip",l,u)),o(W,"createLingeringFixation",(i,a,n,r,s,l)=>W.createLingering(i,a,n,r,s,"Fixation",l)),o(W,"createLingeringAddition",(i,a,n,r,s,l)=>W.createLingering(i,a,n,r,s,"Addition",l));let H=W;const sa=t=>Object.keys(t),oa={draw:"ドローフェイズ",standby:"スタンバイフェイズ",main1:"メインフェイズ１",battle1:"バトルフェイズ",battle2:"バトルフェイズ（追加）",main2:"メインフェイズ２",end:"エンドフェイズ"},la={start:"スタートステップ",battle:"バトルステップ",damage:"ダメージステップ",end:"エンドステップ"},ca={start:"ダメージステップ開始時",beforeDmgCalc:"ダメージ計算前",dmgCalc:"ダメージ計算時",afterDmgCalc:"ダメージ計算後",end:"ダメージステップ終了時"},D=["draw","stanby","main1","b1Start","b1Battle","b1End","b2Start","b2Battle","b2End","main2","end"],N=["b1DStart","b1DBeforeDmgCalc","b1DAfterDmgCalc","b1DEnd","b2DStart","b2DBeforeDmgCalc","b2DAfterDmgCalc","b2DEnd"],ua=["b1DDmgCalc","b2DDmgCalc"],U=[...D,...N,...ua],gt={draw:{phase:"draw",step:void 0,stage:void 0},stanby:{phase:"standby",step:void 0,stage:void 0},main1:{phase:"main1",step:void 0,stage:void 0},b1Start:{phase:"battle1",step:"start",stage:void 0},b1Battle:{phase:"battle1",step:"battle",stage:void 0},b1DStart:{phase:"battle1",step:"battle",stage:"start"},b1DBeforeDmgCalc:{phase:"battle1",step:"battle",stage:"beforeDmgCalc"},b1DDmgCalc:{phase:"battle1",step:"battle",stage:"dmgCalc"},b1DAfterDmgCalc:{phase:"battle1",step:"battle",stage:"afterDmgCalc"},b1DEnd:{phase:"battle1",step:"battle",stage:"end"},b1End:{phase:"battle1",step:"end",stage:void 0},b2Start:{phase:"battle2",step:"start",stage:void 0},b2Battle:{phase:"battle2",step:"battle",stage:void 0},b2DStart:{phase:"battle2",step:"battle",stage:"start"},b2DBeforeDmgCalc:{phase:"battle2",step:"battle",stage:"beforeDmgCalc"},b2DDmgCalc:{phase:"battle2",step:"battle",stage:"dmgCalc"},b2DAfterDmgCalc:{phase:"battle2",step:"battle",stage:"afterDmgCalc"},b2DEnd:{phase:"battle2",step:"battle",stage:"end"},b2End:{phase:"battle2",step:"end",stage:void 0},main2:{phase:"main2",step:void 0,stage:void 0},end:{phase:"end",step:void 0,stage:void 0}},da=t=>t.stage?ca[t.stage]:t.step?la[t.step]:oa[t.phase],ne=sa(gt).reduce((t,e)=>(t[e].key=e,t[e].name=da(t[e]),t),gt),Be=class Be{constructor(e,i){o(this,"entity");o(this,"isRegular");o(this,"_isStarted");o(this,"info");o(this,"continuousEffectBase");o(this,"updateState",async()=>{if(this.hasToStart!==this.isStarted){if(this.isStarted){if(!this.info)throw new v("illegal state");this._isStarted=!1,await this.continuousEffectBase.finish(this.entity,this.info),this.info=void 0;return}this.info=await this.continuousEffectBase.start(this.entity),this._isStarted=!0}});this._isStarted=!1,this.entity=e,this.continuousEffectBase=i,this.isRegular=this.appliableCellTypes.every(a=>Y.find(n=>n===a))&&this.faceList.length===1&&this.faceList[0]==="FaceUp"}get isStarted(){return this._isStarted}get appliableCellTypes(){return this.continuousEffectBase.appliableCellTypes}get appliableDuelPeriodKeys(){return this.continuousEffectBase.appliableDuelPeriodKeys}get faceList(){return this.continuousEffectBase.faceList}get hasToStart(){return!this.appliableCellTypes.includes(this.entity.fieldCell.cellType)||!this.appliableDuelPeriodKeys.includes(this.entity.duel.clock.period.key)||!this.faceList.includes(this.entity.face)?!1:this.continuousEffectBase.canStart(this.entity)}};o(Be,"createNew",(e,i)=>new Be(e,i));let We=Be;const pa=(t,e,i,a)=>({title:t,appliableCellTypes:e==="Monster"?["MonsterZone","ExtraMonsterZone"]:["FieldSpellZone","SpellAndTrapZone"],appliableDuelPeriodKeys:U,faceList:["FaceUp"],canStart:n=>!n.info.isPending&&!n.info.isDying,start:async n=>{const r=i(n);return r.forEach(a(n).push),r.map(s=>s.seq)},finish:async(n,r)=>{r.forEach(s=>a(n).removeItem(s))}}),qe=(t,e,i,a,n)=>({title:t,appliableCellTypes:e==="Monster"?["MonsterZone","ExtraMonsterZone"]:["FieldSpellZone","SpellAndTrapZone"],appliableDuelPeriodKeys:U,faceList:["FaceUp"],canStart:r=>!r.info.isPending&&!r.info.isDying,start:async r=>{const s=a(r),l=i(r);return console.info(`start : ${r.toString()} ⇒ ${l.map(u=>u.toString()).join(" ")} (${s.map(u=>u.title).join(" ")})`),l.map(n).forEach(u=>s.forEach(u.push)),{targets:l,seqList:s.map(u=>u.seq)}},finish:async(r,s)=>{s.targets.map(n).forEach(l=>s.seqList.forEach(u=>l.removeItem(u)))}}),Lt=(t,e,i,a)=>qe(t,e,i,a,n=>n.procFilterBundle),De=(t,e,i)=>pa(t,e,i,a=>a.field.numericStateOperatorPool),Te=(t,e,i,a)=>qe(t,e,i,a,n=>n.numericOprsBundle),it=(t,e,i,a)=>qe(t,e,i,a,n=>n.statusOperatorBundle),fa=(t,e,i,a)=>qe(t,e,i,a,n=>n.damageFilterBundle),Pe=(...t)=>t.length?t.reduce((e,i)=>e>i?e:i):-Number.MAX_VALUE,Me=(...t)=>t.length?t.reduce((e,i)=>e<i?e:i):Number.MAX_VALUE,ue=(t,e)=>{if((t[0]??Number.MAX_VALUE)>e)return 0;if(t.slice(-1)[0]<e)return t.length;let i=0,a=t.length-1;for(;;){const n=Math.round((i+a)/2);if(n===a||n===i)return t[i]<e?a:i;if(t[n]<e){i=n;continue}a=n}},z=[3,5,5,6,6,6,7,8,9,10,11,11,11,12,12,13,13,14,15,15,15,15,15,15,16,16,16,17,18,18,18,21,21,21,22,23,25,25,26,28,28,28,30,30,31,32,32,33,33,34,35,35,36,36,36,37,37,38,38,38,39,41,42,42,43,45,45,45,45,48,48,48,50,51,52,54,54,54,54,56,57,58,59,59,59,59,60,61,63,65,65,65,65,66,67,67,67,69,69,71,71,72,73,73,73,73,73,74,75,75,76,76,77,78,79,80,80,80,80,84,84,84,84,84,84,85,85,85,87,90,91,94,96,96,97,98,101,101,101,101,101];z.forEach((t,e)=>{((z[ue(z,e)-1]||-Number.MAX_VALUE)>=e||(z[ue(z,e)]||Number.MAX_VALUE)<e)&&console.log(e,ue(z,e),(z[ue(z,e)-1]||-Number.MAX_VALUE)<e,(z[ue(z,e)]||Number.MAX_VALUE)>=e)});class ha{constructor(e){o(this,"_field");o(this,"_records",[]);o(this,"getIndexOfStartPoint",e=>ue(this._records.map(i=>i.movedAt.totalProcSeq),e));o(this,"push",e=>{this._records.push(e)});o(this,"getCurrentTurnLog",()=>this.getTermLog("Current","turn"));o(this,"getPriviousChainLog",()=>this.getTermLog("Previous","chainSeq"));this._field=e}*getTermLog(e,i){const a=e==="Current"?this._field.duel.clock.currentStartPoints[i]:this._field.duel.clock.previousStartPoints[i];for(let n=this.getIndexOfStartPoint(a);n<this._records.length;n++)yield this._records[n]}}class ga{constructor(e){o(this,"entity");o(this,"_records");o(this,"_push",e=>{this.entity.field.moveLog.push(e),this._records.push(e)});o(this,"pushForRuleAction",e=>{this._push({entity:this.entity,kind:this.entity.origin.kind,cell:this.entity.fieldCell,face:this.entity.face,orientation:this.entity.orientation,isPending:this.entity.info.isPending,movedAt:this.entity.duel.clock.getClone(),movedAs:[...e,"Rule"]})});o(this,"push",(e,i,a,n,r)=>{let s=this.entity.fieldCell;this.entity.kind==="XyzMaterial"&&(s=this.entity.controller.getXyzMaterialZone()),this._push({entity:this.entity,kind:e,cell:s,face:this.entity.face,orientation:this.entity.orientation,isPending:this.entity.info.isPending,movedAt:this.entity.duel.clock.getClone(),movedAs:i.getDistinct(),movedBy:a,actionOwner:n,chooser:r??n})});o(this,"finalize",()=>{if(!this.latestRecord.isPending)throw new v("想定されない状況");if(this.entity.info.isPending)throw new v("想定されない状況");this._push({...this.latestRecord,isPending:!1,movedAt:this.entity.duel.clock.getClone()})});o(this,"negateSummon",(e,i)=>{const a=this.records.slice(-1)[0];a.cell=this.entity.field.getWaitingRoomCell(),a.movedBy=e,a.movedAs=["SummonNegated"],a.actionOwner=i});this.entity=e,this._records=[]}get records(){return this._records}get latestRecord(){return this.records.slice(-1)[0]}get previousPlaceRecord(){return this.records.findLast(e=>e.cell.cellType!==this.entity.fieldCell.cellType)??this._records[0]}get currentProcRecords(){return this.records.filter(e=>e.movedAt.totalProcSeq===this.entity.duel.clock.totalProcSeq)}}const ya={name:"SpellCounter",type:"Actual",text:"魔力カウンター",emoji:"🔮",sticky:!1,temporary:!1,isOnlyOnField:!0},ma={name:"KaijuCounter",type:"Actual",text:"壊獣カウンター",emoji:"☢",sticky:!1,temporary:!1,isOnlyOnField:!0},va={name:"NamelessCounter",type:"Actual",text:"カウンター",emoji:"💠",sticky:!1,temporary:!1,isOnlyOnField:!0},Sa={name:"IceCounter",type:"Actual",text:"アイスカウンター",emoji:"❄",sticky:!1,temporary:!1,isOnlyOnField:!0},Ca={name:"SelfDestruction",type:"System",text:"自壊",emoji:"",sticky:!1,temporary:!1,isOnlyOnField:!0},Ta={name:"CycleFlip",type:"System",text:"サイクルリバース",emoji:"",sticky:!0,temporary:!0,isOnlyOnField:!0},Ea={name:"SonicBarrier",type:"System",text:"波動音壁",emoji:"",sticky:!0,temporary:!0,isOnlyOnField:!0},_a={name:"SonicVerse",type:"System",text:"波動聖句（適用済）",emoji:"",sticky:!0,temporary:!0,isOnlyOnField:!0},ka={name:"IntoTheVoid",type:"System",text:"無の煉獄",emoji:"",sticky:!0,temporary:!0,isOnlyOnField:!1},wa={name:"GoldSarcophagus",type:"System",text:"封印の黄金櫃",emoji:"",sticky:!0,temporary:!1,isOnlyOnField:!1},ba={SpellCounter:ya,KaijuCounter:ma,NamelessCounter:va,IceCounter:Sa,SelfDestruction:Ca,CycleFlip:Ta,SonicBarrier:Ea,SonicVerse:_a,IntoTheVoid:ka,GoldSarcophagus:wa},de=ba,yt=Object.values(de).filter(t=>t.type==="Actual").filter(t=>t.sticky||t.temporary||!t.isOnlyOnField);if(yt.length)throw new Error(`カウンターの設定誤り。${yt.map(t=>t.name).join(", ")}`);const ss=t=>de[t].emoji;class Da{constructor(e){o(this,"dic");o(this,"temporaryCounterNames");o(this,"entity");o(this,"add",(e,i=1,a)=>{this.dic[e]=[...this.dic[e]??[],...Array(i).fill(a)];const n=this.entity.status.maxCounterQty[e]??0;return n&&(this.dic[e]=this.dic[e].slice(0,n)),this.dic[e]});o(this,"setQty",(e,i=1,a)=>(this.dic[e]=[...Array(i).fill(a)],this.dic[e]));o(this,"remove",(e,i=1,a)=>{const n=this.dic[e].length;if(n===void 0)return[];if(i>=n)return delete this.dic[e],[];if(a){const r=this.dic[e].filter(l=>l===a),s=this.dic[e].filter(l=>l!==a);this.dic[e]=[...r.slice(i),...s]}else this.dic[e]=this.dic[e].slice(i);return this.dic[e]});o(this,"removeAll",(e,i)=>{if(i){const n=this.dic[e].filter(r=>r===i).length;return this.dic[e]=this.dic[e].filter(r=>r!==i),n}const a=this.dic[e];return delete this.dic[e],a});o(this,"getQty",(e,i)=>this.dic[e]?i?this.dic[e].filter(a=>a===i).length:this.dic[e].length??0:0);o(this,"setSelfDestructionFlg",e=>{this.add("SelfDestruction",1,e)});o(this,"getSelfDestructionFlg",e=>this.getQty("SelfDestruction",e)>0);o(this,"incrementActionCountPerTurn",e=>{this.temporaryCounterNames.push(e.title),this.incrementActionCount(e)});o(this,"incrementActionCount",e=>{this.dic[e.title]=[e.entity,...this.dic[e.title]??[]]});o(this,"getActionCount",e=>this.dic[e.title]?this.dic[e.title].filter(i=>i===e.entity).length:0);o(this,"corpseDisposal",()=>{this.temporaryCounterNames.forEach(e=>delete this.dic[e]),this.temporaryCounterNames.reset(),Object.values(de).filter(e=>e.temporary).forEach(e=>delete this.dic[e.name])});o(this,"removeAllActualCounters",()=>{Object.values(de).filter(e=>e.type==="Actual").forEach(e=>delete this.dic[e.name])});o(this,"removeAllWhenfaceDown",()=>{this.temporaryCounterNames.forEach(e=>delete this.dic[e]),this.temporaryCounterNames.reset(),Object.values(de).filter(e=>!e.sticky).forEach(e=>delete this.dic[e.name])});o(this,"clear",()=>{this.temporaryCounterNames.forEach(e=>delete this.dic[e]),this.temporaryCounterNames.reset(),Object.values(de).filter(e=>e.isOnlyOnField).forEach(e=>delete this.dic[e.name])});this.dic={},this.temporaryCounterNames=[],this.entity=e}}class Pa extends Se{constructor(){super(...arguments);o(this,"afterDistributeAll",i=>i.field.getAllEntities().map(a=>a.statusOperatorBundle).every(a=>a.calcStatus()))}}class Ma extends Ce{constructor(){super(...arguments);o(this,"calcStatus",()=>{const i=this.entity.isEffective;return this.entity.resetStatus(),this.entity.status=this._operators.filter(a=>a.isSpawnedBy.isEffective||!a.isContinuous).reduce((a,n)=>({...a,...n.statusCalculator(n,a)}),this.entity.status),this.entity.isEffective===i});o(this,"beforePush",()=>{})}}class V extends oe{constructor(i,a,n,r,s,l,u){super(i,a,n,r,s,l);o(this,"beforeRemove",()=>{});o(this,"statusCalculator");this.statusCalculator=u}}const Oe=class Oe{constructor(e,i,a){o(this,"seq");o(this,"entity");o(this,"_definition");o(this,"validateDuelist",e=>this.entity.controller===e?this.definition.executableDuelistTypes.includes("Controller"):this.definition.executableDuelistTypes.includes("Opponent"));this.seq=e==="AutoSeq"?Oe.nextSeq++:e,this.entity=i,this._definition=a}get definition(){return this._definition}get title(){return this.definition.title}get isMandatory(){return this.definition.isMandatory}get executableCells(){return this.definition.executableCells}get executablePeriods(){return this.definition.executablePeriods}get executableDuelistTypes(){return this.definition.executableDuelistTypes}get isOnlyNTimesPerDuel(){return this.definition.isOnlyNTimesPerDuel??0}get isOnlyNTimesPerTurn(){return this.definition.isOnlyNTimesPerTurn??0}get isOnlyNTimesPerTurnIfFaceup(){return this.definition.isOnlyNTimesPerTurnIfFaceup??0}get isOnlyNTimesIfFaceup(){return this.definition.isOnlyNTimesIfFaceup??0}get isOnlyNTimesPerChain(){return this.definition.isOnlyNTimesPerChain??0}get actionGroupName(){return this.definition.actionGroupName}get duel(){return this.entity.duel}};o(Oe,"nextSeq",0);let Ae=Oe;const ge=class ge extends Ae{constructor(){super(...arguments);o(this,"isApplicableTo",(i,a,n)=>{const r=this.entity.counterHolder.getActionCount(this);return this.isOnlyNTimesPerTurnIfFaceup>0&&r>=this.isOnlyNTimesPerTurnIfFaceup?this.entity.counterHolder.incrementActionCountPerTurn(this):this.isOnlyNTimesIfFaceup>0&&r>=this.isOnlyNTimesIfFaceup&&this.entity.counterHolder.incrementActionCount(this),this.definition.isApplicableTo(this,i,a,n)});o(this,"substitute",async(i,a,n)=>{const r=await this.definition.substitute(this,i,a,n);return this.isOnlyNTimesPerTurnIfFaceup>0?this.entity.counterHolder.incrementActionCountPerTurn(this):this.isOnlyNTimesIfFaceup>0&&this.entity.counterHolder.incrementActionCount(this),r});o(this,"getClone",()=>new ge(this.seq,this.entity,this.definition))}get definition(){return super.definition}};o(ge,"createNew",(i,a)=>new ge("AutoSeq",i,a));let Qe=ge;class Aa extends Se{constructor(){super(...arguments);o(this,"afterDistributeAll",()=>!0)}}class xa extends Ce{constructor(){super(...arguments);o(this,"beforePush",()=>{});o(this,"filter",(i,a,n,r,s,l,u)=>this.effectiveOperators.filter(c=>c.summonKinds.includes(a)).reduce((c,d)=>({...c,...d.filter(this.entity,i,s.summoner,[a,...n],r,s.monster,l,c.posList,c.cells,u)}),s))}}class Fa extends oe{constructor(i,a,n,r,s,l,u,c){super(i,a,n,r,s,l);o(this,"beforeRemove",()=>{});o(this,"summonKinds");o(this,"filter");this.summonKinds=u,this.filter=(...d)=>c(this,...d)}}const A=class A{constructor(){}};o(A,"_tryMarkForDestory",(e,i)=>{if(e.info.isDying||e.kind==="XyzMaterial"||!e.isOnFieldStrictly&&e.fieldCell.cellType!=="Deck"&&e.fieldCell.cellType!=="Hand")return!1;const a=i.action.playType==="Battle"?"BattleDestroy":"EffectDestroy",n=a==="BattleDestroy"&&i.action.entity===e?i.selectedEntities[0]:i.action.entity;return e.info.isDying=e.validateDestory(a,i.activator,n,i.action),e.info.isDying&&(e.info.causeOfDeath=[a],e.info.isKilledBy=n,e.info.isKilledByWhom=i.activator,a==="BattleDestroy"&&(e.info.isKilledByWhom=n.controller)),e.info.isDying}),o(A,"excavateManyFromDeck",async(e,i,a,n,r)=>{const s=e.getDeckCell().cardEntities.slice(0,i);return await M.moveMany(s.map(l=>[l,l.fieldCell,l.kind,"FaceUp",l.orientation,"Fix",["Excavate",...a],n,r,void 0])),s}),o(A,"releaseManyForTheSameReason",(e,i,a,n)=>e.length?(i.includes("Cost")&&n.writeInfoLog(`${e.map(r=>r.toString()).join(" ")}をリリースし――、`),A.bringManyToSameCellForTheSameReason("Graveyard","Top",e,"FaceUp","Vertical",["Release",...i],a,n)):Promise.resolve([])),o(A,"sendManyToGraveyardForTheSameReason",(e,i,a,n)=>e.length?(n&&i.includes("Cost")&&(i.includes("FusionMaterial")?n.writeInfoLog(`${e.map(r=>r.toString()).join(" ")}を融合素材とし――、`):i.includes("SyncroMaterial")?n.writeInfoLog(`${e.map(r=>r.toString()).join(" ")}をシンクロと素材し――、`):i.includes("LinkMaterial")?n.writeInfoLog(`${e.map(r=>r.toString()).join(" ")}をリンクマーカーにセッティング――、`):n.writeInfoLog(`${e.map(r=>r.toString()).join(" ")}を墓地に送り――、`)),A.bringManyToSameCellForTheSameReason("Graveyard","Top",e,"FaceUp","Vertical",i,a,n)):Promise.resolve([])),o(A,"addManyToHand",(e,i,a,n)=>e.length?A.bringManyToSameCellForTheSameReason("Hand","Bottom",e,"FaceDown","Vertical",i,a,n):Promise.resolve([])),o(A,"discardManyForTheSameReason",(e,i,a,n)=>e.length?(n&&i.includes("Cost")&&n.writeInfoLog(`${e.map(r=>r.toString()).join(" ")}を手札から捨て――、`),A.bringManyToSameCellForTheSameReason("Graveyard","Top",e,"FaceUp","Vertical",["Discard",...i],a,n)):Promise.resolve([])),o(A,"banishManyForTheSameReason",(e,i,a,n)=>e.length?(n&&i.includes("Cost")&&n.writeInfoLog(`${e.map(r=>r.toString()).join(" ")}をゲームから除外し――、`),A.bringManyToSameCellForTheSameReason("Banished","Top",e,"FaceUp","Vertical",i,a,n)):Promise.resolve([])),o(A,"returnManyToDeckForTheSameReason",(e,i,a,n,r)=>i.length?(r&&a.includes("Cost")&&r.writeInfoLog(`${i.map(s=>s.toString()).join(" ")}をデッキに戻し――、`),A.bringManyToSameCellForTheSameReason("Deck",e,i,"FaceDown","Vertical",a,n,r)):Promise.resolve([])),o(A,"returnManyToHandForTheSameReason",(e,i,a,n)=>e.length?(n&&i.includes("Cost")&&n.writeInfoLog(`${e.map(r=>r.toString()).join(" ")}を手札に戻し――、`),A.bringManyToSameCellForTheSameReason("Hand","Bottom",e,"FaceDown","Vertical",i,a,n)):Promise.resolve([])),o(A,"convertManyToXyzMaterials",(e,i,a,n)=>e.length?(n&&i.includes("Cost")&&n.writeInfoLog(`${e.map(r=>r.toString()).join(" ")}によって、オーバーレイネットワークを構築――、`),M.moveMany(e.map(r=>[r,r.fieldCell,"XyzMaterial","FaceUp","Vertical","Top",i,a,n,n]))):Promise.resolve()),o(A,"moveToXyzOwner",(e,i,a,n,r)=>i.length?(a.includes("Effect")&&r.writeInfoLog(`${i.map(s=>s.toString()).join(" ")}をXYZ素材として吸収。`),M.moveMany(i.map(s=>[s,e,"XyzMaterial","FaceUp","Vertical","Top",a,n,r,r]))):Promise.resolve()),o(A,"banishMany",(e,i)=>M.bringManyToSameCell("Banished","Top",e.map(a=>({...a,face:"FaceUp",orientation:"Vertical"})),i)),o(A,"bringManyToSameCellForTheSameReason",(e,i,a,n,r,s,l,u)=>M.bringManyToSameCell(e,i,a.map(c=>({entity:c,face:n,orientation:r,causedAs:s,causedBy:l,activator:u})))),o(A,"tryDestroy",async(e,i)=>{const a=await A.tryMarkForDestory(e,i);return await A.waitCorpseDisposal(i.activator.duel),a}),o(A,"waitCorpseDisposal",e=>M.sendManyToGraveyard([...e.field.getCardsOnFieldStrictly(),...e.field.getPendingCardsOnField()].filter(i=>i.info.isDying).map(i=>({entity:i,causedAs:i.info.causeOfDeath??[],causedBy:i.info.isKilledBy,activator:i.info.isKilledByWhom})))),o(A,"tryMarkForDestory",async(e,i)=>{let a=e.filter(l=>A._tryMarkForDestory(l,i));if(!a.length)return[];const n=i.action.playType==="Battle"?"BattleDestroy":"EffectDestroy";(await Promise.all(e[0].field.getAllEntities().flatMap(l=>l.substituteEffects.filter(u=>u.isMandatory).filter(u=>u.executableCells.includes(l.fieldCell.cellType)).filter(u=>u.isApplicableTo(n,e,i).length).flatMap(u=>u.substitute(n,e,i))))).flatMap(l=>l).forEach(l=>{l.resetCauseOfDeath()}),a=a.filter(l=>l.info.isDying);let r=e[0].field.getAllEntities().flatMap(l=>l.substituteEffects.filter(u=>!u.isMandatory).filter(u=>u.executableCells.includes(l.fieldCell.cellType)).filter(u=>u.isApplicableTo(n,e,i).length).map(u=>({chooser:l.owner,effect:u,sacrifice:l})));for(const l of r.map(u=>u.sacrifice.controller).getDistinct()){const u=r.filter(d=>d.sacrifice.controller===l),c=await l.duel.view.waitSelectAction(l,u.map(d=>({entity:d.sacrifice,title:d.effect.title,origin:d.effect})),"身代わり効果を適用する？",!0);if(c){if((await c.substitute(n,a,i)).forEach(d=>{d.resetCauseOfDeath()}),a=a.filter(d=>d.info.isDying),!a.length)return[];r=r.filter(d=>d.effect.isApplicableTo(n,e,i).length)}}const s=a.filter(l=>l.info.isDying);return s.forEach(l=>l.duel.log.info(`${l.toString()}を${Ha[n]}。`,l.info.isKilledByWhom)),s}),o(A,"tryBanish",async(e,i,a)=>{const n=i.filter(r=>r.canBeBanished(e,a.activator,a.action.entity,a.action));return await A.banishManyForTheSameReason(n,["Effect"],a.action.entity,a.activator),n.filter(r=>r.fieldCell.cellType==="Banished").filter(r=>r.moveLog.latestRecord.movedBy===a.action.entity)}),o(A,"negateSummonMany",(e,i)=>{const a=i.duel.field.getPendingMonstersOnField();return a.forEach(n=>{n.info.summonKinds=[],n.info.materials=[],n.moveLog.negateSummon(e,i)}),i.writeInfoLog(`${a.map(n=>n.toString()).join(" ")}.の召喚は無効にされた。`),a}),o(A,"drawAtSameTime",async(e,i,a,n)=>{const r=[],s=[],l=[e.draw(a,i,e),e.getOpponentPlayer().draw(n,i,e)].map(u=>u.catch(c=>{c instanceof $?c.winner&&r.push(c.winner):s.push(c)}));if(await Promise.all(l),s.length)throw new v("ドロー処理で想定されない例外が発生した。",e,a,n,i,...s);if(r.length!==0)throw r.length===1?new $(r[0],"対戦相手がデッキからドローできなかった。"):new $(void 0,"お互いにデッキからカードをドローできなかった。")});let m=A;class Na extends Se{constructor(){super(...arguments);o(this,"afterDistributeAll",()=>!0)}}class Ba extends Ce{constructor(){super(...arguments);o(this,"beforePush",()=>{})}}class qt extends oe{constructor(i,a,n,r,s,l,u,c){super(i,a,n,r,s,l);o(this,"beforeRemove",()=>{});o(this,"calcType");o(this,"filter");this.calcType=u,this.filter=(...d)=>c(this,...d)}}const He=(t,e,...i)=>t.filter(a=>e.includes(a.calcType)).reduce((a,n)=>({...a,...n.filter(...i)}),{}),Rt=(...t)=>{const[e,i,a,n,r,s,l]=t,u=[a.entity,n,r].filter(p=>!!p).flatMap(p=>p.damageFilterBundle.effectiveOperators);let c=He(u,["double_typeA","eachOther_typeA","eachOther_typeB","asEffectDamage"],...t);const d={point:e,damageToOpponent1:0,damageToOpponent2:0,damageType:s};return c.double_typeA&&(d.point*=2),c.asEffectDamage&&(d.damageType="EffectDamage"),c={...He(u,["heal","zero_typeA","half","double_typeB","fix"],d.point,i,a,n,r,d.damageType,l),...c},c.fix!==void 0?d.point=c.fix:c.zero_typeA?d.point=0:(c.half&&(d.point=Math.round(d.point/2)),c.double_typeA&&(d.point*=2)),c={...He(u,["zero_typeB"],d.point,i,a,n,r,d.damageType,l),...c},c.zero_typeB&&(d.point=0),c.heal?d.damageType="Heal":(c.eachOther_typeA&&(d.damageToOpponent1=d.point),c.eachOther_typeB&&(d.damageToOpponent2=d.point,c.eachOther_typeB==="Substitude"&&(d.point=0))),d},Oa=(t,e,i)=>Rt(t,e.activator,i,e.action.entity,void 0,"EffectDamage",e.action),La=(t,e,i,a,n,r)=>Rt(t,e,i,a,n.entityType==="Duelist"?void 0:n,"BattleDamage",r),Xe=t=>new Promise(e=>setTimeout(e,t)),Ht=()=>{let t=()=>{},e=()=>{};return{promise:new Promise((a,n)=>{t=a,e=n}),resolve:t,reject:e}},Zt=["FusionSummon","SyncroSummon","XyzSummon","PendulumSummon","LinkSummon","RitualSummon","FlipSummon"],qa={FusionSummon:"融合召喚",SyncroSummon:"シンクロ召喚",XyzSummon:"エクシーズ召喚",PendulumSummon:"ペンデュラム召喚",LinkSummon:"リンク召喚",RitualSummon:"儀式召喚",FlipSummon:"反転召喚"},Ra=[...Zt,"AdvanceSummon","NormalSummon","SpecialSummon"],Ha={BattleDestroy:"戦闘破壊",EffectDestroy:"効果破壊",RuleDestroy:"ルール破壊"},$t=t=>t+"Summon",mt=["Card","Token"],Za=["Duelist","Squatter"],os=(t,e)=>xt(t.origin,e.origin),x=class x{constructor(e,i,a,n,r,s,l){o(this,"onBeforeMoveEvent",new pt);o(this,"onAfterMoveEvent",new pt);o(this,"seq");o(this,"origin");o(this,"entityType");o(this,"summonFilterBundle");o(this,"procFilterBundle");o(this,"numericOprsBundle");o(this,"statusOperatorBundle");o(this,"damageFilterBundle");o(this,"moveLog");o(this,"counterHolder");o(this,"parent");o(this,"face");o(this,"orientation");o(this,"owner");o(this,"fieldCell");o(this,"_status");o(this,"_numericStatus");o(this,"_info");o(this,"actions",[]);o(this,"continuousEffects",[]);o(this,"substituteEffects",[]);o(this,"canBeReleased",(e,i,a,n)=>!this.isInTrashCell&&this.procFilterBundle.effectiveOperators.filter(r=>r.procTypes.union(a).length).every(r=>r.filter(e,i,n,[this])));o(this,"canBeSentToGraveyard",(e,i,a,n)=>!this.status.willBeBanished&&!this.status.willReturnToDeck&&this.procFilterBundle.effectiveOperators.filter(r=>r.procTypes.includes(a)).every(r=>r.filter(e,i,n,[this])));o(this,"_exists",!0);o(this,"validateFusionMaterials",e=>this.definition.fusionMaterialInfos?this.definition.validateFusionMaterials?this.definition.validateFusionMaterials(e):!0:!1);o(this,"definition");o(this,"toString",()=>this.entityType==="Card"?`《${this.nm}》`:this.nm);o(this,"onUsedAsMaterial",(e,i)=>{this.definition&&this.definition.onUsedAsMaterial&&this.definition.onUsedAsMaterial(e,i)});o(this,"setBattlePosition",async(e,i,a,n)=>{let r=`表示形式の変更：${this.toString()}（${this.battlePositionName}⇒${we[e]}）`;const s=[...i];this.battlePosition==="Set"&&(s.push("Flip"),i.includes("Rule")&&(this.info.isPending=!0,r=`${this.toString()}を反転召喚`,this.info.summonKinds.push("FlipSummon"),s.push("FlipSummon"),s.push("AttackSummon"))),this.duel.log.info(r,n),await this.moveAlone(this.fieldCell,"Monster",e==="Set"?"FaceDown":"FaceUp",e==="Attack"?"Vertical":"Horizontal","Top",s,a,n,n)});o(this,"activateAsPendulumScale",(e,i,a,n)=>this.moveAlone(e,"Spell","FaceUp","Vertical","Top",["CardActivation",...i],a,n,n));o(this,"setNonFieldMonsterPosition",async(e,i,a,n,r)=>{this.moveAlone(this.fieldCell,e,i==="FaceUp"?"FaceUp":"FaceDown","Vertical","Top",a,n,r,r)});o(this,"setAsSpellTrap",async(e,i,a,n,r)=>{await this.moveAlone(e,i,"FaceDown","Vertical","Top",[...a,"SpellTrapSet"],n,r,r)});o(this,"activateSpellTrapFromHand",async(e,i,a,n,r)=>{await this.moveAlone(e,i,"FaceUp","Vertical","Top",[...a,"CardActivation"],n,r,r)});o(this,"putDirectly",async(e,i,a,n,r)=>{await this.moveAlone(e,i,"FaceUp","Vertical","Top",[...a,"PutDirectly"],n,r,r)});o(this,"activateSpellTrapOnField",async(e,i,a,n)=>{await this.moveAlone(this.fieldCell,e,"FaceUp","Vertical","Top",[...i,"CardActivation"],a,n,n)});o(this,"draw",async(e,i,a)=>await this.addToHand([...e,"Draw"],i,a));o(this,"addToHand",async(e,i,a)=>await this.moveAlone(this.owner.getHandCell(),this.origin.kind,"FaceDown","Vertical","Bottom",[...e],i,a,a));o(this,"summon",(e,i,a,n,r,s,l)=>x.summonMany([{monster:this,dest:e,summoner:l??s,pos:i}],a,n,r,s));o(this,"moveForcibly",async(e,i,a,n,r,s,l)=>{await this.moveAlone(e,this.origin.kind,i,a,n,["Rule",...r],s,l,l)});o(this,"moveAlone",async(e,i,a,n,r,s,l,u,c)=>(await x.moveMany([[this,e,i,a,n,r,s,l,u,c]],void 0),this.fieldCell));o(this,"determine",()=>{this.info.isPending&&(this.info.isPending=!1,this.moveLog.finalize(),this.continuousEffects.forEach(e=>e.updateState()))});o(this,"_move",async(e,i,a,n,r,s,l,u,c)=>{if(!e)throw new Error("illegal argument: to");await this.onBeforeMoveEvent.trigger({entity:this,args:[e,i,a,n,r,s,l,u,c]}),this.face=a,this.orientation=n;let d=!1;return e!==this.fieldCell&&(this.fieldCell.cellType==="WaitingRoom"?(this.duel.log.info(`生成：${this.toString()}`,u),d=!0):e.cellType==="WaitingRoom"?(this.duel.log.info(`消滅：${this.toString()}`,u),this._exists=!1,await this.duel.view.waitTokenAnimation()):this.field.duel.clock.turn&&(this.duel.log.info(`移動：${this.toString()}  ${this.fieldCell.toString()} ⇒ ${e.toString()}`,u),await this.field.duel.view.waitAnimation({entity:this,to:e,index:r,count:0}))),(e!==this.fieldCell||r==="Random")&&(this.fieldCell.releaseEntities(this),this.fieldCell.isPlayFieldCell&&!e.isPlayFieldCell&&(this.counterHolder.clear(),this.resetCauseOfDeath()),this.kind!=="XyzMaterial"&&(this.fieldCell.isMonsterZoneLikeCell&&!e.isMonsterZoneLikeCell||i!=="Monster")&&(this.info.equipEntities.filter(p=>p.isOnFieldAsSpellTrapStrictly).forEach(p=>{p.info.isDying=!0,p.info.causeOfDeath=["RuleDestroy"],this.controller.writeInfoLog(`装備対象${this.toString()}不在により${p.toString()}は破壊された。`)}),this.info.equipEntities=[],this.fieldCell.xyzMaterials.forEach(p=>{p.info.isDying=!0,p.info.causeOfDeath=["LostXyzOwner"],this.controller.writeInfoLog(`エクシーズモンスター${this.toString()}不在により${p.toString()}は墓地に送られた。`)}),this.resetNumericStatus(),this.info.isEffectiveIn.push(...Y)),this.fieldCell.cellType==="SpellAndTrapZone"&&e.cellType!=="SpellAndTrapZone"&&(this.info.equipedBy=void 0,this.info.equipedAs=void 0,this.info.isEffectiveIn.push(...Y)),e.acceptEntities(this,r),d&&(await Xe(1),this._exists=!0,await this.duel.view.waitTokenAnimation()),(e===this.isBelongTo||e.cellType==="Hand"||e.cellType==="Banished"&&this.face==="FaceDown")&&(this.counterHolder.clear(),this.resetInfoAll(),this.resetStatusAll())),(this.isOnFieldStrictly&&this.face==="FaceDown"||i==="XyzMaterial")&&(this.info.equipEntities.forEach(p=>{p.info.isDying=!0,p.info.causeOfDeath=["RuleDestroy"],this.controller.writeInfoLog(`装備対象${this.toString()}不在により${p.toString()}は破壊された。`)}),this.counterHolder.removeAllWhenfaceDown(),this.info.materials=[],this._status.isEffective=!0,this.info.isEffectiveIn=[...I],this.resetNumericStatus(),this.info.isSettingSickness=this.kind==="Trap"||this.status.spellCategory==="QuickPlay"),this._info.kind=i,this.moveLog.push(i,s,l,u,c),await this.onAfterMoveEvent.trigger(this),e});o(this,"initForTurn",()=>{this.info.isSettingSickness=!1,this.info.attackDeclareCount=0,this.info.battlePotisionChangeCount=0,this.counterHolder.corpseDisposal()});o(this,"resetInfoIfLeavesTheField",()=>{this._info={...this._info,isDying:!1,isPending:!1,causeOfDeath:[],isKilledBy:void 0,isKilledByWhom:void 0,effectTargets:{},attackDeclareCount:0,battlePotisionChangeCount:0,materials:[],equipedBy:void 0,equipedAs:void 0,equipEntities:[]},this._info.isEffectiveIn.push(...Y),this._info.isEffectiveIn.distinct()});o(this,"resetInfoAll",()=>{var e;this._info={kind:this.origin.kind,isDying:!1,isPending:!1,isEffectiveIn:[...I],causeOfDeath:[],isKilledBy:void 0,isKilledByWhom:void 0,isVanished:!1,isRebornable:((e=this.origin.monsterCategories)==null?void 0:e.union(Dt).length)===0,isSettingSickness:!1,summonKinds:[],materials:[],effectTargets:{},attackDeclareCount:0,battlePotisionChangeCount:0,equipedBy:void 0,equipedAs:void 0,validateEquipOwner:()=>!0,equipEntities:[],battleLog:[]},this.counterHolder.clear()});o(this,"resetNumericStatus",()=>{const e=Mt.reduce((i,a)=>(i[a]=this.origin[a],i),{});this._numericStatus={origin:{...e},wip:{...e},calculated:{...e}}});o(this,"resetStatus",()=>{this._status={...this.origin,canAttack:!0,isEffective:!0,canDirectAttack:!1,canActivateEffect:!0,isSelectableForAttack:!0,allowHandSyncro:!1,allowHandLink:!1,willBeBanished:!1,willReturnToDeck:void 0,fusionSubstitute:!1,maxCounterQty:{},piercingTo:[]}});o(this,"resetStatusAll",()=>{this.resetNumericStatus(),this.resetStatus()});o(this,"resetCauseOfDeath",()=>{this.info.isDying=!1,this.info.causeOfDeath=[],this.info.isKilledBy=void 0,this.info.isKilledByWhom=void 0});this.seq=x.nextEntitySeq++,this.counterHolder=new Da(this),this.definition=n,this.owner=e,this.fieldCell=i,this.entityType=a,this.parent=l,this.origin=n.staticInfo,this._status=JSON.parse(JSON.stringify(n.staticInfo)),this._numericStatus=JSON.parse(JSON.stringify(n.staticInfo)),this.resetStatusAll(),this._info={kind:this.origin.kind,isEffectiveIn:[...I],attackDeclareCount:0,battlePotisionChangeCount:0,isDying:!1,isPending:!1,causeOfDeath:[],isKilledBy:void 0,isKilledByWhom:void 0,isVanished:!1,isRebornable:!0,isSettingSickness:!1,summonKinds:[],materials:[],effectTargets:{},equipedBy:void 0,equipedAs:void 0,validateEquipOwner:()=>!0,equipEntities:[],battleLog:[]},this.resetInfoAll(),this.face=r,this.orientation=s,this.summonFilterBundle=new xa(i.field.summonFilterPool,this),this.procFilterBundle=new aa(i.field.procFilterPool,this),this.numericOprsBundle=new ra(i.field.numericStateOperatorPool,this),this.statusOperatorBundle=new Ma(i.field.statusOperatorPool,this),this.damageFilterBundle=new Ba(i.field.damageFilterPool,this),this._exists=this.entityType==="Card",i.acceptEntities(this,"Top"),this.moveLog=new ga(this),this.moveLog.pushForRuleAction(["Spawn"]);let u=[];u=n.continuousEffects??[],this.substituteEffects.push(...(n.substituteEffects??[]).map(c=>Qe.createNew(this,c))),this.origin.kind==="Monster"&&this.entityType==="Card"&&n.summonFilter&&this.summonFilterBundle.push(new Fa("default",()=>!0,!0,this,{},()=>!0,Ra,n.summonFilter)),n.defaultStatus&&this.statusOperatorBundle.push(new V("default",()=>!0,!0,this,{},()=>!0,()=>n.defaultStatus??{})),this.actions.push(...n.actions.map(c=>fe.createNew(this,c))),this.continuousEffects.push(...u.map(c=>We.createNew(this,c)))}get onBeforeMove(){return this.onBeforeMoveEvent.expose()}get onAfterMove(){return this.onAfterMoveEvent.expose()}get isUnderControl(){return this.face==="FaceUp"||Ft.every(e=>e!==this.fieldCell.cellType)}get controller(){return this.fieldCell.owner??this.owner}get field(){return this.owner.duel.field}get duel(){return this.owner.duel.field.duel}get actionLogRecords(){return this.duel.chainBlockLog.records.filter(e=>e.chainBlockInfo.action.entity===this)}get status(){return this._status}set status(e){this._status={...e}}get numericStatus(){return this._numericStatus}get info(){return this._info}get kind(){return this.info.kind}get nm(){return this.status.name}get atk(){return this._numericStatus.calculated.attack}get def(){return this._numericStatus.calculated.defense}get lvl(){return this._numericStatus.calculated.level}get rank(){return this._numericStatus.calculated.rank}get attr(){return this.status.attributes??[]}get types(){return this.status.types??[]}get psL(){return this._numericStatus.calculated.pendulumScaleL}get psR(){return this._numericStatus.calculated.pendulumScaleR}get linkArrows(){let e=(this.origin.linkArrowKeys??[]).map(i=>At[i].linkArrow);return this.controller.seat==="Above"&&(e=e.map(i=>({offsetColumn:i.offsetColumn*-1,offsetRow:i.offsetRow*-1}))),e}get linkArrowDests(){var e;return(e=this.origin.monsterCategories)!=null&&e.includes("Link")?this.isOnFieldAsMonsterStrictly?this.linkArrows.map(i=>[this.fieldCell.row+i.offsetRow,this.fieldCell.column+i.offsetColumn]).map(([i,a])=>this.field.cells[i][a]).filter(i=>i.isMonsterZoneLikeCell):[]:[]}get linkedEntities(){return this.isOnFieldAsMonsterStrictly?[...this.linkArrowDests.map(e=>e.cardEntities[0]).map(e=>e),...this.fieldCell.linkArrowSources].getDistinct():[]}get coLinkedEntities(){var e;return this.isOnFieldAsMonsterStrictly?(e=this.origin.monsterCategories)!=null&&e.includes("Link")?this.linkArrowDests.map(i=>i.cardEntities[0]).filter(i=>i).union(this.fieldCell.linkArrowSources):[]:[]}get isEffective(){return this.status.isEffective&&this.info.isEffectiveIn.includes(this.fieldCell.cellType)}get canBeSet(){var e;return this.entityType==="Card"&&!((e=this.status.monsterCategories)!=null&&e.includes("Link"))}get isEffectiveWeakly(){return this.status.isEffective}get battlePosition(){if(this.isOnFieldStrictly&&this.kind==="Monster")return this.orientation==="Vertical"?"Attack":this.face==="FaceUp"?"Defense":"Set"}get battlePositionName(){const e=this.battlePosition;if(e)return we[e]}get wasMovedAtCurrentProc(){return this.field.duel.clock.totalProcSeq===this.moveLog.latestRecord.movedAt.totalProcSeq}get wasMovedAtPreviousProc(){return this.field.duel.clock.totalProcSeq===this.moveLog.latestRecord.movedAt.totalProcSeq+1}get wasMovedAtCurrentTurn(){return this.field.duel.clock.isSameTurn(this.moveLog.latestRecord.movedAt)}get wasMovedAtCurrentChain(){return this.field.duel.clock.isSameChain(this.moveLog.latestRecord.movedAt)}get wasMovedAtPreviousChain(){return this.field.duel.clock.isPreviousChain(this.moveLog.latestRecord.movedAt)}get wasMovedAtPreviousTurn(){return this.field.duel.clock.isPreviousTurn(this.moveLog.latestRecord.movedAt)}get wasMovedFrom(){return this.moveLog.previousPlaceRecord.cell}get isPendulumScale(){var e;return!(!((e=this.origin.monsterCategories)!=null&&e.includes("Pendulum"))||!this.isOnField||!this.fieldCell.isSpellTrapZoneLikeCell||this.status.spellCategory)}get isOnField(){return this.fieldCell.isPlayFieldCell}get isOnFieldStrictly(){return this.isOnField&&!this.info.isPending&&this.kind!=="XyzMaterial"}get isOnFieldAsMonsterStrictly(){return this.fieldCell.isMonsterZoneLikeCell&&this.isOnFieldStrictly}get isOnFieldAsSpellTrapStrictly(){return this.fieldCell.isSpellTrapZoneLikeCell&&this.isOnFieldStrictly}get isInTrashCell(){return this.fieldCell.isTrashCell}get isLikeContinuousSpell(){return this.status.spellCategory==="Continuous"||this.status.spellCategory==="Field"||this.status.spellCategory==="Equip"||this.status.trapCategory==="Continuous"||(this.status.monsterCategories??[]).includes("Pendulum")}get isBelongTo(){return this.origin.monsterCategories&&this.origin.monsterCategories.union(be).length?this.owner.getExtraDeck():this.owner.getDeckCell()}get exist(){return this._exists}get allStickyEffectOperators(){return[...this.procFilterBundle.effectiveOperators,...this.numericOprsBundle.effectiveOperators]}get fusionMaterialInfos(){return this.definition.fusionMaterialInfos??[]}};o(x,"nextEntitySeq",0),o(x,"splitBattlePos",e=>({face:e==="Set"?"FaceDown":"FaceUp",orientation:e==="Attack"?"Vertical":"Horizontal"})),o(x,"recreateArray",(e,i)=>{if(!i.length)return[];const a=e.getAllCells().flatMap(n=>n.entities);return i.map(n=>n.seq).map(n=>a.find(r=>r.seq===n)).filter(n=>n!==void 0)}),o(x,"createPlayerEntity",e=>{const i=e.getHandCell();return new x(e,i,"Duelist",qr(e),"FaceUp","Vertical")}),o(x,"createCardEntity",(e,i)=>{const a=i.staticInfo.monsterCategories&&i.staticInfo.monsterCategories.union(be).length?e.getExtraDeck():e.getDeckCell();return new x(e,a,"Card",i,"FaceDown","Vertical")}),o(x,"createTokenEntity",(e,i,a)=>new x(e,e.duel.field.getWaitingRoomCell(),"Token",a,"FaceUp","Vertical",i)),o(x,"moveMany",async(e,i)=>{if(!e.length)return;const a=e[0][0].duel,r=[...e.filter(([l,u])=>l.fieldCell!==u).map(([l])=>l).filter(l=>!(i??[]).includes(l)),...a.field.getCardsOnFieldStrictly().filter(l=>l.info.isDying)],s=new Map;for(e.forEach(([l,u,c,d,p,f,...g])=>{var Z;let y=u,b=c,h=d,k=f,L=p;l.status.willBeBanished?(y=l.owner.getBanished(),h="FaceUp",L="Vertical"):l.status.willReturnToDeck?(y=l.isBelongTo,h="FaceDown",k=l.status.willReturnToDeck,L="Vertical"):(Z=l.status.monsterCategories)!=null&&Z.includes("Pendulum")&&l.isOnFieldStrictly&&l.face==="FaceUp"&&u.isTrashCell&&(y=l.owner.getExtraDeck(),h="FaceUp",k="Top",L="Vertical"),y.cellType==="ExtraDeck"&&(k=h==="FaceUp"?"Top":"Bottom"),l.isBelongTo.cellType==="ExtraDeck"&&(y.cellType==="Hand"||y.cellType==="Deck")&&(y=l.isBelongTo,h="FaceDown",L="Vertical"),y.isPlayFieldCell||(b=l.origin.kind,l.entityType==="Token"&&(y=l.field.getWaitingRoomCell())),y.isMonsterZoneLikeCell||(L="Vertical"),s.set(y,[[l,y,b,h,L,k,...g],...s.get(y)??[]])});;){const l=Array.from(s.values()).map(c=>c.pop()).filter(c=>c!==void 0).map(([c,...d])=>c._move(...d));if(!l.length)break;await Promise.all(l);const u=a.field.getCardsOnFieldStrictly().filter(c=>c.info.isDying).filter(c=>!r.includes(c)).map(c=>({entity:c,causedAs:c.info.causeOfDeath??[],causedBy:c.info.isKilledBy,activator:c.info.isKilledByWhom}));u.length&&await x.sendManyToGraveyard(u,r)}x.settleEntityMove(a)}),o(x,"summonMany",async(e,i,a,n,r)=>{if(!e.length)return;const s={Attack:"AttackSummon",Defense:"DefenseSummon",Set:"SetSummon"},l=e.map(({monster:u,dest:c,pos:d,summoner:p})=>{if(u.info.summonKinds=[i],i==="NormalSummon"||i==="AdvanceSummon"){u.info.summonKinds.push("NormalSummon");const y=i==="AdvanceSummon"?"アドバンス":"";d==="Attack"?u.field.duel.log.info(`${u.toString()}を${y}召喚`,p):u.duel.log.info(`${u.toString()}を${y}セット`,p),a.includes("Rule")?p.info.ruleNormalSummonCountQty++:p.info.effectNormalSummonCountQty++}else i==="SpecialSummon"?u.duel.log.info(`${u.toString()}を${we[d]}で特殊召喚`,p):(u.info.summonKinds.push("SpecialSummon"),u.duel.log.info(`${u.toString()}を${we[d]}で${qa[i]}！`,p)),p.info.specialSummonCountQty++;u.info.summonKinds=u.info.summonKinds.getDistinct(),u.info.battlePotisionChangeCount=1;const{face:f,orientation:g}=x.splitBattlePos(d);return a.includes("Rule")&&(u.info.isPending=!0),{entity:u,args:[c,"Monster",f,g,"Top",[i,s[d],...a],n,r,p]}}).map(u=>u.entity._move(...u.args));await Promise.all(l),e.map(u=>u.summoner).forEach(u=>{i==="NormalSummon"||i==="AdvanceSummon"?a.includes("Rule")?u.info.ruleNormalSummonCount++:u.info.effectNormalSummonCount++:u.info.specialSummonCount++}),x.settleEntityMove(e[0].monster.duel)}),o(x,"sendManyToGraveyard",(e,i)=>x.bringManyToSameCell("Graveyard","Top",e.map(a=>({...a,face:"FaceUp",orientation:"Vertical"})),i)),o(x,"bringManyToSameCell",async(e,i,a,n)=>(await x.moveMany(a.map(r=>[r.entity,r.entity.field.getCells(e).filter(s=>s.owner===r.entity.owner)[0],r.entity.origin.kind,r.face,r.orientation,i,r.causedAs,r.causedBy,r.activator,r.activator]),n),a.map(r=>r.entity).filter(r=>r.fieldCell.cellType===e))),o(x,"settleEntityMove",e=>{e.field.recalcLinkArrows(),e.distributeOperators(e.clock);const i=e.field.getAllEntities().filter(a=>a.wasMovedAtCurrentProc);i.filter(a=>!a.isOnFieldStrictly&&!a.info.isPending).forEach(a=>a.resetInfoIfLeavesTheField()),i.filter(a=>a.face==="FaceDown").filter(a=>a.fieldCell===a.isBelongTo).forEach(a=>{a.resetInfoAll(),a.resetStatusAll()}),i.flatMap(a=>a.continuousEffects).forEach(a=>a.updateState()),e.field.getAllCells().filter(a=>a.needsShuffle).map(a=>a.shuffle())});let M=x;M.prototype.hasBeenSummonedNow=function(t,e=["Attack","Defense"]){const i=this,a=e.map($t),n=i.moveLog.latestRecord.movedAs;return!(!i.wasMovedAtPreviousChain||!n.union(t).length||!n.union(a).length)};M.prototype.hasBeenSummonedJustNow=function(t,e=["Attack","Defense"]){const i=this,a=e.map($t),n=i.moveLog.latestRecord.movedAs;return!(!i.wasMovedAtPreviousProc||!n.union(t).length||!n.union(a).length)};M.prototype.getAttackTargets=function(){const t=this.controller.getOpponentPlayer().getMonstersOnField().filter(e=>e.status.isSelectableForAttack);return console.log(this.toString(),t,this.status.canDirectAttack),(this.status.canDirectAttack||!t.length)&&(console.log(this.toString(),t,this.status.canDirectAttack),t.push(this.controller.getOpponentPlayer().entity)),console.log(this.toString(),t,this.status.canDirectAttack,t.filter(e=>e.canBeTargetOfBattle(this.controller,this)).filter(e=>this.procFilterBundle.effectiveOperators.filter(i=>i.procTypes.includes("BattleTarget")).every(i=>i.filter(this.controller,this,{},[e])))),t.filter(e=>e.canBeTargetOfBattle(this.controller,this)).filter(e=>this.procFilterBundle.effectiveOperators.filter(i=>i.procTypes.includes("BattleTarget")).every(i=>i.filter(this.controller,this,{},[e])))};M.prototype.canBeEffected=function(t,e,i){return this.procFilterBundle.effectiveOperators.filter(n=>n.procTypes.some(r=>r==="Effect")).every(n=>n.filter(t,e,i,[this]))};const $a=(t,e,i,a,n)=>t.canBeEffected(i,a,n)&&t.procFilterBundle.effectiveOperators.filter(r=>r.procTypes.some(s=>s===e)).every(r=>r.filter(i,a,n,[t]));M.prototype.canBeTargetOfEffect=function(t){return this.procFilterBundle.effectiveOperators.filter(e=>e.procTypes.some(i=>i==="EffectTarget")).every(e=>e.filter(t.activator,t.action.entity,t.action,[this]))};M.prototype.canBeBanished=function(t,e,i,a){return this.fieldCell.cellType==="Banished"?!1:$a(this,t,e,i,a)};M.prototype.canBeTargetOfBattle=function(t,e){const i=this;return i.procFilterBundle.effectiveOperators.filter(a=>a.procTypes.some(n=>n==="BattleTarget")).every(a=>a.filter(t,e,{},[i]))};M.prototype.validateDestory=function(t,e,i,a){const n=this;let r=n.procFilterBundle.effectiveOperators.filter(s=>s.procTypes.includes(t)).every(s=>s.filter(e,i,a??{},[n]));return r&&t==="EffectDestroy"&&(r=n.canBeEffected(e,i,a)),r};M.prototype.getIndexInCell=function(){const t=this;if(t.info.isVanished)return-1;const e=t.fieldCell.cardEntities.indexOf(t);if(e<0)throw new v("エンティティとセルの状態が矛盾している。",[t,t.fieldCell]);return e};M.prototype.getXyzMaterials=function(){const t=this;return(t.status.monsterCategories??[]).includes("Xyz")?t.fieldCell.xyzMaterials:[]};M.prototype.wasMovedAfter=function(t){return this.moveLog.latestRecord.movedAt.totalProcSeq>t.totalProcSeq};M.prototype.hadArrivedToFieldAt=function(){let t=this.moveLog.latestRecord.movedAt;return this.moveLog.records.findLast(e=>!e.cell.isPlayFieldCell||e.isPending||e.kind!==this.kind||e.face==="FaceDown"?!0:(t=e.movedAt,!1)),t};M.prototype.release=async function(t,e,i){return await this.sendToGraveyard([...t,"Release"],e,i),this.info.isVanished?void 0:this.fieldCell};M.prototype.ruleDestory=async function(){return await this.sendToGraveyard(["RuleDestroy"],void 0,void 0),this.info.isVanished?void 0:this.fieldCell};M.prototype.sendToGraveyard=async function(t,e,i){await m.sendManyToGraveyardForTheSameReason([this],t,e,i)};M.prototype.discard=async function(t,e,i){await m.discardManyForTheSameReason([this],t,e,i)};M.prototype.returnToDeck=async function(t,e,i,a){await m.returnManyToDeckForTheSameReason(t,[this],e,i,a)};M.prototype.banish=async function(t,e,i){await m.banishManyForTheSameReason([this],t,e,i)};class Ga{constructor(e){o(this,"cells");o(this,"duel");o(this,"summonFilterPool");o(this,"procFilterPool");o(this,"numericStateOperatorPool");o(this,"statusOperatorPool");o(this,"damageFilterPool");o(this,"moveLog");o(this,"getAllCells",()=>this.cells.flat());o(this,"getCells",(...e)=>this.getAllCells().filter(i=>e.includes(i.cellType)));o(this,"getAvailableExtraMonsterZones",()=>this.getCells("ExtraMonsterZone").filter(e=>e.isAvailable));o(this,"getWaitingRoomCell",()=>this.getCells("WaitingRoom")[0]);o(this,"getAllEntities",()=>this.getAllCells().map(e=>e.entities).flat());o(this,"getAllCardEntities",()=>this.getAllCells().map(e=>e.cardEntities).flat());o(this,"getCardsOnFieldStrictly",()=>this.getCells(...Y).map(e=>e.cardEntities).filter(e=>e.length>0).map(e=>e[0]).filter(e=>e.isOnFieldStrictly));o(this,"getMonstersOnFieldStrictly",()=>this.getCardsOnFieldStrictly().filter(e=>e.isOnFieldAsMonsterStrictly));o(this,"getSpellTrapsOnFieldStrictly",()=>this.getCardsOnFieldStrictly().filter(e=>e.isOnFieldAsSpellTrapStrictly));o(this,"getPendulumScalesOnFieldStrictly",()=>this.getCardsOnFieldStrictly().filter(e=>{var i;return(i=e.origin.monsterCategories)==null?void 0:i.includes("Pendulum")}).filter(e=>e.isOnFieldAsSpellTrapStrictly).filter(e=>!e.status.spellCategory));o(this,"getPendingCardsOnField",()=>this.getCells(...Y).map(e=>e.cardEntities).filter(e=>e.length>0).map(e=>e[0]).filter(e=>e.info.isPending));o(this,"getPendingMonstersOnField",()=>this.getPendingCardsOnField().filter(e=>e.kind==="Monster"));o(this,"getEntities",e=>this.getAllEntities().filter(i=>i.controller===e));o(this,"recalcLinkArrows",()=>{const e=this.getAllCells().filter(i=>i.isMonsterZoneLikeCell);e.some(i=>i.recalcLinkArrows)&&e.forEach(i=>i.recalcLinkArrows())});o(this,"canExtraLink",(e,i)=>{if(!e.linkArrows.length)return!1;const a=i.map(c=>c.material),n=this.getCells("ExtraMonsterZone").filter(c=>c.isAvailable||a.includes(c.cardEntities[0]));if(n.length!==1)return!1;const r=n[0],s=e.linkArrows.map(c=>this.cells[r.row+c.offsetRow][r.column+c.offsetColumn]);let l=r.linkArrowSources.filter(c=>!a.includes(c)).filter(c=>s.includes(c.fieldCell));if(!l.length)return!1;let u=-1;for(;u!==l.length;){const c=l.flatMap(d=>d.coLinkedEntities).filter(d=>!a.includes(d));if(c.some(d=>d.fieldCell.cellType==="ExtraMonsterZone"))return!0;l=[...l,...c].getDistinct(),u=l.length}return!1});o(this,"drawAtSameTime",async(e,i,a,n,r,s)=>{const l=[],u=[],c=[e.draw(i,r,s),a.draw(n,r,s)].map(d=>d.catch(p=>{p instanceof $?p.winner&&l.push(p.winner):u.push(p)}));if(await Promise.all(c),u.length)throw new v("ドロー処理で想定されない例外が発生した。",e,i,a,n,r,...u);if(l.length!==0)throw l.length===1?new $(l[0],"対戦相手がデッキからドローできなかった。"):new $(void 0,"お互いにデッキからカードをドローできなかった。")});o(this,"sendToGraveyard",async(e,i,a,n,r,s,l,u)=>{if(n>0&&a.length<n)return;const c=await this.duel.view.waitSelectEntities(i,{selectables:a,qty:n,validator:r,cancelable:u??!1},e);if(c)return await M.sendManyToGraveyard(c.map(d=>({entity:d,causedAs:s,causedBy:l,activator:i}))),this.duel.log.info(`${c.map(d=>d.status.name).join(", ")}を墓地に送った（${s.getDistinct().join(", ")}）。`,i),c});this.duel=e,this.cells=[...Array(7)].map(()=>[]);for(const i of Object.keys(ze).map(Number))for(const a of Object.keys(ze[i]).map(Number))this.cells[i][a]=new ta(this,i,a,i<3?e.duelists.Above:i>3?e.duelists.Below:a<2?e.duelists.Above:a>4?e.duelists.Below:void 0);this.summonFilterPool=new Aa,this.procFilterPool=new ia,this.numericStateOperatorPool=new na,this.statusOperatorPool=new Pa,this.damageFilterPool=new Na,this.moveLog=new ha(this)}}class ja{constructor(e){o(this,"onUpdateEvent",new B);o(this,"nextSeq");o(this,"records",[]);o(this,"duel");o(this,"dispose",()=>{this.onUpdateEvent.clear()});o(this,"error",e=>{console.error(e);const i=["エラー発生"];e instanceof Error?(e instanceof v&&(i.push("-- エラーメッセージ --"),i.push(e.message),i.push("-- 関連オブジェクト --"),e.items.forEach(a=>i.push(JSON.stringify(a))),console.error(e.items)),i.push("-- エラー名称 --"),i.push(e.name||"エラー名称取得失敗"),i.push("-- スタックトレース --"),i.push(e.stack||"スタックトレース取得失敗")):(i.push("-- エラー型特定失敗 --"),i.push(JSON.stringify(e))),this.write("error","System",i,void 0,void 0,void 0,void 0,void 0)});o(this,"warn",e=>{this.write("warn","System",["【注意】",e],void 0,void 0,void 0,void 0,void 0)});o(this,"info",(e,i)=>{this.write("info","Others",[e],i,void 0,void 0,void 0,void 0)});o(this,"pushMoveLog",(e,i,a,n)=>{this.write("info","EntityMove",["移動"],e,i,void 0,a,n)});o(this,"write",(e,i,a,n,r,s,l,u)=>{const c=a.join(`
`);this.records.push({seq:this.nextSeq++,lvl:e,type:i,clock:this.duel.clock.getClone(),text:c,duelist:n,mainEntity:r,subEntities:s??[],from:l,to:u}),this.onUpdateEvent.trigger(this.nextSeq-1)});this.nextSeq=0,this.duel=e}get onUpdate(){return this.onUpdateEvent.expose()}get lastRecord(){return this.records.slice(-1)[0]}}class Ze{constructor(e){o(this,"onUpdateEvent",new B);o(this,"_state","Disable");o(this,"defaultArgs");o(this,"_args");o(this,"resolve",()=>{});o(this,"show",e=>{this._args=e,this._state="Shown",this.onUpdateEvent.trigger();const{promise:i,resolve:a}=Ht();return this.resolve=n=>{this._state="Disable",a(n),this.resolve=()=>{},this.onUpdateEvent.trigger()},i});o(this,"cancel",()=>{console.log(this),this.args.cancelable&&(this._state!=="Disable"&&this.resolve(void 0),this.terminate())});o(this,"terminate",()=>{this._state="Disable",this._args=this.defaultArgs,this.resolve=()=>{}});this.defaultArgs=e,this._args=e}get onUpdate(){return this.onUpdateEvent.expose()}get state(){return this._state}get args(){return this._args}}class Ua{constructor(e){o(this,"onUpdateEvent",new B);o(this,"actionSelector",new Ze({title:"カード操作を選択。",activator:void 0,dummyActionInfos:[],cancelable:!1}));o(this,"entitySelector",new Ze({title:"対象を選択",entitiesChoices:{selectables:[],validator:()=>!0,cancelable:!1},cancelable:!1,chainBlockInfos:[]}));o(this,"textSelector",new Ze({title:"カード操作を選択。",choises:[],cancelable:!1}));o(this,"modals",[this.actionSelector,this.entitySelector,this.textSelector]);o(this,"view");o(this,"terminateAll",()=>{this.modals.forEach(e=>e.terminate()),this.onUpdateEvent.trigger()});this.view=e,this.modals.forEach(i=>i.onUpdate.append(()=>this.onUpdateEvent.trigger()))}get onUpdate(){return this.onUpdateEvent.expose()}}const vt=t=>{let e=[];do{const i=t.qty&&t.qty>0?t.qty:Math.floor(Math.random()*t.selectables.length+1);e=t.selectables.randomPickMany(i)}while(!t.validator(e));return e},Va=[{seq:10,name:"Internet Explorer",key:"msie"},{seq:20,name:"Internet Explorer",key:"trident"},{seq:30,name:"Edge",key:"edge"},{seq:40,name:"Google Chrome",key:"chrome"},{seq:50,name:"Safari",key:"safari"},{seq:60,name:"Mozilla Firefox",key:"firefox"},{seq:70,name:"Opera",key:"opera"}],za=[{seq:10,name:"Microsoft Windows",key:"windows nt"},{seq:20,name:"Android",key:"android"},{seq:30,name:"iOS",key:"iphone"},{seq:40,name:"iOS",key:"ipad"},{seq:50,name:"macOS",key:"mac os x"}],ve=window.navigator.userAgent.toLowerCase();var wt;const Wa=((wt=Va.find(t=>ve.indexOf(t.key)!==-1))==null?void 0:wt.name)??"Unknown Browser";var bt;const at=((bt=za.find(t=>ve.indexOf(t.key)!==-1))==null?void 0:bt.name)??"Unknown OS",Gt=ve.indexOf("iphone")!==-1||at==="Android"&&ve.indexOf("mobile")!==-1,Qa=ve.indexOf("ipad")!==-1||at==="Android"&&!Gt,St=Gt?"Smart Phone":Qa?"Tablet Device":"PC",$e={canDragElement:St==="PC",text:`${St} ${at} ${Wa}`};class Xa{constructor(e){o(this,"onDuelUpdateEvent",new B);o(this,"requireUpdate",()=>{this.onDuelUpdateEvent.trigger()});o(this,"onWaitStartEvent",new B);o(this,"onWaitEndEvent",new B);o(this,"onDragStartEvent",new B);o(this,"onDragEndEvent",new B);o(this,"onAnimationStartEvent",new B);o(this,"onShowCardEntityEvent",new B);o(this,"duel");o(this,"modalController");o(this,"_message");o(this,"waitMode");o(this,"infoBoardState");o(this,"infoBoardCell");o(this,"getCell",(e,i)=>this.duel.field.cells[e][i]);o(this,"showCardInfo",(e,i)=>{this.onShowCardEntityEvent.trigger({card:e,mode:i})});o(this,"dispose",()=>{this.onDragStartEvent.clear(),this.onDragEndEvent.clear(),this.onDuelUpdateEvent.clear(),this.onWaitStartEvent.clear(),this.onWaitEndEvent.clear()});o(this,"waitFieldAction",async e=>{if(this.duel.getTurnPlayer().duelistType==="NPC"){const r=this.duel.getTurnPlayer().selectActionForNPC(e,[]);return r?{actionInfo:r}:{phaseChange:this.duel.nextPhaseList[0]}}const i=await this._waitDuelistAction(this.duel.getTurnPlayer(),e,"Free","",void 0,void 0,!1);if(!i.actionInfo)return{...i,actionInfo:void 0};const a={...i.actionInfo},n=e.find(r=>{var s;return((s=i.actionInfo)==null?void 0:s.originSeq)===r.originSeq});if(!n)throw new v("想定されない状態",e,i);return{...i,actionInfo:{dest:a.dest,battlePosition:a.battlePosition,action:n.action,originSeq:n.originSeq}}});o(this,"waitQuickEffect",async(e,i,a,n,r)=>{if(i.length===0)return;if(e.duelistType==="NPC")return e.selectActionForNPC(i,a);const s=[this.modalController.actionSelector.show({title:n,activator:e,dummyActionInfos:i,cancelable:r}),this._waitDuelistAction(e,i,"Modal",this.message,void 0,void 0,!1).then(c=>c.actionInfo)],l=await Promise.any(s);if(!l)return;this.infoBoardState="Default";const u=i.find(c=>l.originSeq===c.originSeq);if(!u)throw new v("想定されない状態",l);return{...u,dest:l.dest}});o(this,"waitSubAction",async(e,i,a,n=!1)=>{if(e.duelistType==="NPC")throw Error("Not implemented");const r=await this._waitDuelistAction(e,i,"Modal",a,void 0,void 0,n);if(r&&r.actionInfo)return r.actionInfo});o(this,"waitSelectEntities",async(e,i,a)=>{if(!i.selectables.length)return;if(i.qty&&i.selectables.length===i.qty)return[...i.selectables];if(e.duelistType==="NPC")return vt(i);let n;i.selectables.some(s=>s.entityType==="Duelist")&&(n={...i,selectables:i.selectables.filter(s=>s.entityType==="Duelist").map(s=>s.fieldCell),qty:1,validator:s=>s.length===1});const r=await this._waitDuelistAction(e,[],"Modal",a,i,n,i.cancelable);return(r.selectedEntities||r.selectedCells)&&[...r.selectedEntities??[],...(r.selectedCells??[]).flatMap(s=>s.entities).filter(s=>s.entityType==="Duelist")]});o(this,"waitYesOrNo",async(e,i)=>{const a=await this.waitSelectText(e,[{seq:0,text:"Yes"},{seq:1,text:"No"}],i,!1);return(a==null?void 0:a.seq)===0});o(this,"waitSelectText",async(e,i,a,n=!1)=>{if(e.duelistType==="NPC")return i.randomPick();const r=await this.modalController.textSelector.show({title:a,choises:i,cancelable:n});if(r===void 0){if(!n)throw new F(e,i,a,n);return}return i.find(s=>s.seq===r)});o(this,"waitAnimation",async e=>{var i;return this._message="",this.waitMode="Animation",window.getSelection&&((i=window.getSelection())==null||i.removeAllRanges()),this.onDuelUpdateEvent.trigger(),new Promise(a=>this.onAnimationStartEvent.trigger({...e,resolve:a}))});o(this,"waitTokenAnimation",async()=>{this.requireUpdate(),await Xe(450)});o(this,"setDraggingActions",e=>{this.onDragStartEvent.trigger(e),this.requireUpdate()});o(this,"removeDraggingActions",()=>{this.onDragEndEvent.trigger()});o(this,"waitSelectAction",async(e,i,a,n)=>{var u;const r=i.map(c=>fe.createDummyAction(c.entity,c.title,[],void 0,c.origin)),s=await this._waitDammyAction(e,r,a,n);if(!s)return;const l=(u=i.find(c=>c.origin.seq===s.originSeq))==null?void 0:u.origin;if(!l)throw new v("想定されない状態",i,s);return l});o(this,"waitSelectSummonDestination",async(e,i,a,n,r)=>{const s=a.length>1&&$e.canDragElement?"カードを召喚先へドラッグ。":"表示形式を選択。";if(!a.length&&!n.length){if(r)return;throw new v("想定されない状態",e,i,a,n,r)}let l=[...n];for(;;){const u={dest:a.randomPick(),battlePosition:l[0]};if(l.length===1&&!$e.canDragElement){const p=await this.waitSelectCell(e,a,r,"召喚先を選択。");return p?{...u,dest:p}:void 0}const c=l.map(p=>fe.createDummyAction(i,p,a,p)),d=await this._waitDammyAction(e,c,s,r);if(!d)return;if(d.battlePosition&&(l=[d.battlePosition]),!(a.length>1&&!d.dest))return u.dest=d.dest??u.dest,u.battlePosition=d.battlePosition??u.battlePosition,u}});o(this,"waitSelectDestination",async(e,i,a,n,r,s=!1)=>{if(!a.length)return;if(a.length===1)return a[0];if(!$e.canDragElement)return await this.waitSelectCell(e,a,s,n);let l=a.randomPick();const u=[fe.createDummyAction(i,r,a,void 0)],c=await this._waitDammyAction(e,u,n,s);if(c)return l=c.dest??l,l});o(this,"_waitDammyAction",async(e,i,a,n=!1)=>{if(!i.length)return;const r=i.randomPick();let s={...r,dest:r.dest??r.dests.randomPick()};if(e.duelistType!=="NPC"){const l=[this.modalController.actionSelector.show({title:a,activator:e,dummyActionInfos:i,cancelable:n}),this.duel.view.waitSubAction(e,i,a,n)],u=await Promise.any(l);if(!u&&!n)throw new F(u,l);if(!u)return;s=u??s}return s});o(this,"waitSelectCell",async(e,i,a,n)=>i.length?e.duelistType==="NPC"?i.randomPick():(await this.waitSelectCells(e,{selectables:i,qty:1,validator:s=>s.length===1,cancelable:a},n)??[])[0]:void 0);o(this,"waitSelectCells",async(e,i,a)=>{if(!i.selectables.length)return;if(e.duelistType==="NPC")return vt(i);const n=await this._waitDuelistAction(e,[],"Modal",a,void 0,i,i.cancelable);if((!n||!n.selectedCells)&&!i.cancelable)throw new F(e,i,a);return n.selectedCells});o(this,"_waitDuelistAction",async(e,i,a,n,r,s,l=!1)=>{for(this.waitMode=a,this._message=n;this.onDuelUpdateEvent.length<38;)console.log(this.onDuelUpdateEvent.length),await Xe(1);this.onDuelUpdateEvent.trigger();const u=Ht(),c={resolve:u.resolve,activator:e,dummyActionInfos:i,chainBlockInfos:e.duel.chainBlockInfos,entitiesChoices:r,cellsChoices:s};console.info("wait start",c),this.onWaitStartEvent.trigger(c);const d=await u.promise;if(console.info("response",d),this.modalController.terminateAll(),this.waitMode="None",this.onWaitEndEvent.trigger(),d.surrender)throw new $(e.getOpponentPlayer(),`${e.profile.name}がサレンダーした。`);if(!l&&d.cancel)throw new v("キャンセル不可のアクションがキャンセルされた。",d,i,a,r,s);return this.infoBoardState="Default",d});this.duel=e,this._message="",this.waitMode="None",this.infoBoardState="Default",this.infoBoardCell=e.duelists.Below.getExtraDeck(),this.modalController=new Ua(this)}get onDuelUpdate(){return this.onDuelUpdateEvent.expose()}get onWaitStart(){return this.onWaitStartEvent.expose()}get onWaitEnd(){return this.onWaitEndEvent.expose()}get onDragStart(){return this.onDragStartEvent.expose()}get onDragEnd(){return this.onDragEndEvent.expose()}get onAnimation(){return this.onAnimationStartEvent.expose()}get onShowCardEntity(){return this.onShowCardEntityEvent.expose()}get message(){var e;return(this._message||((e=this.duel.log.lastRecord)==null?void 0:e.text))??""}}const Ke=["turn","phaseSeq","stepSeq","stageSeq","chainSeq","chainBlockSeq","procSeq"];[...Ke];class Ka{constructor(){o(this,"onClockChangeEvents",{turn:new B,phaseSeq:new B,stepSeq:new B,stageSeq:new B,chainSeq:new B,chainBlockSeq:new B,procSeq:new B});o(this,"_turn",0);o(this,"_phaseSeq",0);o(this,"_stepSeq",0);o(this,"_stageSeq",0);o(this,"_chainSeq",0);o(this,"_chainBlockSeq",0);o(this,"_procSeq",0);o(this,"_totalProcSeq",0);o(this,"_periodKey");o(this,"_previousStartPoints",{turn:0,phaseSeq:0,stepSeq:0,stageSeq:0,chainSeq:0,chainBlockSeq:0,procSeq:0});o(this,"_currentStartPoints",{turn:0,phaseSeq:0,stepSeq:0,stageSeq:0,chainSeq:0,chainBlockSeq:0,procSeq:0});o(this,"setPhase",(e,i)=>{const a=Object.values(ne).filter(n=>n.phase===i).find(n=>(n.step??"start")==="start");if(!a)throw new v("想定されない状態",this.period,i,ne);i==="draw"?(this.turn>0&&e.log.info("ターン終了。",e.getTurnPlayer()),this._turn++,this._phaseSeq=0):(e.log.info(`フェイズ移行（${this.period.name}→${a.name}）`,e.getTurnPlayer()),this._phaseSeq++),this._stepSeq=0,this._stageSeq=0,this.periodKey=a.key});o(this,"setStep",(e,i)=>{const a=this.period.phase,n=Object.values(ne).filter(r=>r.phase===a).find(r=>(r.step??"")===i);if(!n)throw new v("想定されない状態",this.period,i,ne);this.period.name!==n.name&&(e.log.info(`ステップ移行（${this.period.name}→${n.name}）`,e.getTurnPlayer()),this._stepSeq++,this._stageSeq=0,this.periodKey=n.key)});o(this,"setStage",(e,i)=>{const a=this.period,n=Object.values(ne).filter(r=>r.phase===a.phase).filter(r=>r.step===a.step).find(r=>(r.stage??"")===i);if(!n)throw new v("想定されない状態",this.period,i,ne);e.log.info(`タイミング移行（${this.period.name}→${n.name}）`,e.getTurnPlayer()),this._stageSeq++,this.periodKey=n.key});o(this,"incrementChainSeq",()=>{this._chainSeq++,this._chainBlockSeq=0,this._procSeq=0,this.incrementTotalProcSeq()});o(this,"incrementChainBlockSeq",()=>{this._chainBlockSeq++,this._procSeq=0,this.incrementTotalProcSeq()});o(this,"incrementProcSeq",()=>{this._procSeq++,this.incrementTotalProcSeq()});o(this,"incrementTotalProcSeq",()=>{this._totalProcSeq++;let e=!0;Ke.toReversed().forEach(i=>{e&&(this._previousStartPoints[i]=this.currentStartPoints[i],this._currentStartPoints[i]=this.totalProcSeq),e=e&&this[i]===0}),Ke.toReversed().filter(i=>this._currentStartPoints[i]===this.totalProcSeq).filter(i=>i!=="procSeq").forEach(i=>this.onClockChangeEvents[i].trigger(this)),this.onClockChangeEvents.procSeq.trigger(this)});o(this,"toString",()=>`${this.totalProcSeq}(t${this.turn}-phs${this.phaseSeq}-stp${this.stepSeq}-stg${this.stepSeq}-c${this.chainSeq}-cb${this.chainBlockSeq}-prc${this.procSeq})`);o(this,"getClone",()=>({turn:this.turn,phaseSeq:this.phaseSeq,stepSeq:this.stepSeq,stageSeq:this.stageSeq,chainSeq:this.chainSeq,chainBlockSeq:this.chainBlockSeq,procSeq:this.procSeq,totalProcSeq:this.totalProcSeq,period:this.period}));o(this,"isSameTurn",e=>this.turn===e.turn);o(this,"isSameChain",e=>this.turn===e.turn&&this.phaseSeq===e.phaseSeq&&this.stepSeq===e.stepSeq&&this.stageSeq===e.stageSeq&&this.chainSeq===e.chainSeq);o(this,"isPreviousChain",e=>this.turn===e.turn&&this.phaseSeq===e.phaseSeq&&this.stepSeq===e.stepSeq&&this.stageSeq===e.stageSeq&&this.chainSeq===e.chainSeq+1);o(this,"isPreviousStage",e=>this.turn===e.turn&&this.phaseSeq===e.phaseSeq&&this.stepSeq===e.stepSeq&&this.stageSeq===e.stageSeq+1);o(this,"isPreviousTurn",e=>this.turn===e.turn+1);o(this,"isPreviousProc",e=>this.totalProcSeq===e.totalProcSeq+1);o(this,"isUponAttackDeclaration",()=>this.period.step==="battle"&&this.chainSeq===1);this._periodKey="end"}get onTurnChange(){return this.onClockChangeEvents.turn.expose()}get onStageChange(){return this.onClockChangeEvents.stageSeq.expose()}get onProcSeqChange(){return this.onClockChangeEvents.procSeq.expose()}get previousStartPoints(){return this._previousStartPoints}get currentStartPoints(){return this._currentStartPoints}set periodKey(e){this._periodKey!==e&&(this._periodKey=e,this._chainSeq=0,this._chainBlockSeq=0,this._procSeq=0,this.incrementTotalProcSeq())}get periodKey(){return this._periodKey}get period(){return ne[this.periodKey]}get turn(){return this._turn}get phaseSeq(){return this._phaseSeq}get stepSeq(){return this._stepSeq}get stageSeq(){return this._stageSeq}get chainSeq(){return this._chainSeq}get chainBlockSeq(){return this._chainBlockSeq}get procSeq(){return this._procSeq}get totalProcSeq(){return this._totalProcSeq}get isFirstChain(){return this.chainSeq===0}}class Ja{constructor(e){o(this,"onInsertEvent",new B);o(this,"nextSeq");o(this,"records",[]);o(this,"duel");o(this,"push",e=>{const i={seq:this.nextSeq++,clock:this.duel.clock.getClone(),chainBlockInfo:e};this.records.push(i),this.onInsertEvent.trigger(i)});this.nextSeq=0,this.duel=e}get onInsert(){return this.onInsertEvent.expose()}}const Ya=["PlayFirst","DrawFirst","Random"],ls={PlayFirst:"先攻",DrawFirst:"後攻",Random:"ランダム"};class $ extends Error{constructor(i,a){super(i?`デュエルが終了した。勝者：${i.profile.name}`:"デュエルが終了した。ドロー。");o(this,"winner");o(this,"message");this.winner=i,this.message=a}}class v extends Error{constructor(i,...a){super(i);o(this,"message");o(this,"items");this.message=i,this.items=a}}class F extends v{constructor(...e){super("キャンセル不可のアクションがキャンセルされた。",...e)}}class cs{constructor(e,i,a,n=[],r,s,l,u=[],c="Random"){o(this,"onDuelEndEvent",new B);o(this,"view");o(this,"log");o(this,"chainBlockLog");o(this,"clock");o(this,"nextPhaseList");o(this,"field");o(this,"attackingMonster");o(this,"targetForAttack");o(this,"_chainBlockInfos");o(this,"duelists");o(this,"priorityHolder");o(this,"isEnded");o(this,"winner");o(this,"coin",!1);o(this,"startMode");o(this,"distributeOperators",e=>{console.info(`[totalProcSeq]:${e.totalProcSeq}`);let i=0;for(;;){if(i++,i>10)throw new v("無限ループ発生");if(this.field.procFilterPool.distributeAll(this)&&this.field.statusOperatorPool.distributeAll(this)&&this.field.numericStateOperatorPool.distributeAll(this)&&this.field.summonFilterPool.distributeAll(this)&&this.field.damageFilterPool.distributeAll(this))return}});o(this,"getTurnPlayer",()=>this.clock.turn%2===0?this.secondPlayer:this.firstPlayer);o(this,"getNonTurnPlayer",()=>this.clock.turn%2===0?this.firstPlayer:this.secondPlayer);o(this,"main",async()=>{console.info("main start!"),this.coin=this.startMode==="PlayFirst"?!0:this.startMode==="DrawFirst"?!1:Math.random()>.5,this.priorityHolder=this.firstPlayer;const e=Lr(...Object.values(this.duelists).flatMap(i=>i.deckInfo.cardNames).getDistinct()).reduce((i,a)=>(i[a.name]=a,{...i}),{});for(const i of Object.values(this.duelists))i.pushDeck(e),i.getDeckCell().shuffle(),i.initHand.length&&i.initHand.forEach(a=>{const n=i.getDeckCell().cardEntities.find(r=>r.origin.name===a);if(!n){this.log.info(`初手操作により${a}を手札に加えようとしたが、デッキに存在しない。`);return}n.addToHand(["System"],void 0,void 0),this.log.info(`初手操作により${n.toString()}を手札に加えた`,i)}),await i.draw(5-i.getHandCell().cardEntities.length,void 0,void 0);this.log.info(`【デュエル開始】${this.firstPlayer.profile.name} V.S. ${this.secondPlayer.profile.name}`),this.log.info(`先攻：${this.firstPlayer.profile.name} 後攻：${this.secondPlayer.profile.name}`),this.moveNextPhase("draw");try{for(const i of Object.values(this.duelists))for(const a of this.getEnableActions(i,["Exodia"],["Normal"],[]))await a.action.directExecute(i,void 0,!1);for(;!this.isEnded&&(this.clock.period.phase==="draw"?await this.procDrawPhase():this.phase==="standby"?await this.procStanbyPhase():this.phase==="main1"?await this.procMainPhase():this.phase==="battle1"?await this.procBattlePhase():this.phase==="battle2"?await this.procBattlePhase():this.phase==="main2"?await this.procMainPhase():this.phase==="end"&&await this.procEndPhase(),!(this.clock.turn>1e3)););}catch(i){i instanceof $?(this.clock.incrementChainSeq(),console.info(i),this.isEnded=!0,this.winner=i.winner,this.log.info(i.winner?`デュエル終了。勝者${i.winner.profile.name}。${i.message}`:`デュエル終了。引き分け。${i.message}`),this.onDuelEndEvent.trigger()):i instanceof Error&&this.log.error(i)}finally{this.log.dispose()}});o(this,"moveNextPhase",e=>{this.clock.setPhase(this,e),this.phase==="main2"||this.clock.turn===1?this.nextPhaseList=["end"]:this.phase==="battle1"||this.phase==="battle2"?this.nextPhaseList=["main2"]:this.phase==="main1"?this.nextPhaseList=["battle1","end"]:this.nextPhaseList=[]});o(this,"declareAnAttack",(e,i,a=!1)=>{var s;this.attackingMonster=e,this.targetForAttack=i;let n=" ("+((s=i.battlePosition==="Attack"?i.atk:i.def)==null?void 0:s.toString())+")";i.face==="FaceDown"&&(n=" (????)"),i.entityType==="Duelist"&&(n="");const r=a?"攻撃対象再選択":"攻撃宣言";a||e.info.attackDeclareCount++,this.log.info(`${r}:${e.toString()} (${e.atk})⇒ ${i.toString()}${n}`,e.controller)});o(this,"procDrawPhase",async()=>{if(Object.values(this.duelists).forEach(e=>e.initForDrawPhase()),this.log.info("ドローフェイズ開始。",this.getTurnPlayer()),this.clock.turn===1)this.log.info("先攻プレイヤーはドローできない。",this.getTurnPlayer());else{await this.getTurnPlayer().draw(1,void 0,void 0);for(const e of this.getEnableActions(this.getTurnPlayer(),["Exodia"],["Normal"],[]))await e.action.directExecute(this.getTurnPlayer(),void 0,!1)}this.field.getCardsOnFieldStrictly().forEach(e=>e.initForTurn()),await this.procSpellSpeed1(),this.moveNextPhase("standby")});o(this,"procStanbyPhase",async()=>{await this.procSpellSpeed1(),this.moveNextPhase("main1")});o(this,"procMainPhase",async()=>{for(;;){this.priorityHolder=this.getTurnPlayer();const e=await this.view.waitFieldAction(this.getEnableActions(this.priorityHolder,["NormalSummon","SpellTrapSet","SpecialSummon","FlipSummon","ChangeBattlePosition","IgnitionEffect","QuickEffect","CardActivation"],["Normal","Quick","Counter"],[]));if(e.actionInfo){if(await this.procChain({activator:this.priorityHolder,actionInfo:e.actionInfo},void 0)==="cancel")continue;await this.procFreeChain();continue}const i=e.phaseChange;if(i){this.priorityHolder=this.getNonTurnPlayer();let a="done";for(;;){const n=await this.view.waitQuickEffect(this.priorityHolder,this.getEnableActions(this.priorityHolder,["QuickEffect","CardActivation"],["Quick","Counter"],[]),[],"相手がフェイズを終了しようとしている。",!0);if(!n){this.moveNextPhase(i);return}if(a=await this.procChain({activator:this.priorityHolder,actionInfo:n},void 0),a==="done")break}if(a==="done"){await this.procFreeChain();continue}}}});o(this,"procBattlePhase",async()=>{await this.procBattlePhaseStartStep()&&await this.procBattlePhaseBattleStep(),await this.procBattlePhaseEndStep()});o(this,"procBattlePhaseStartStep",async()=>(this.clock.setStep(this,"start"),this.priorityHolder=this.getTurnPlayer(),this.attackingMonster=void 0,this.targetForAttack=void 0,await this.procSpellSpeed1()));o(this,"procBattlePhaseBattleStep",async()=>{for(;;){this.clock.setStep(this,"battle"),this.priorityHolder=this.getTurnPlayer();const e=await this.view.waitFieldAction(this.getEnableActions(this.priorityHolder,["Battle"],["Normal"],[]));if(e.phaseChange)break;if(e.actionInfo){const i=await e.actionInfo.action.prepare(this.priorityHolder,e.actionInfo.dest,void 0,[],!0,!1);if(!i)continue;for(await e.actionInfo.action.execute(i,[]),this.clock.incrementChainSeq();this.attackingMonster&&this.targetForAttack;){const a=this.clock.totalProcSeq,n=this.getNonTurnPlayer().getMonstersOnField(),r=await this.procChain(void 0,void 0);if(!this.attackingMonster)throw new v("想定されない状態");if(!this.canContinueBattle())break;const s=this.attackingMonster.getAttackTargets();if(n.some(l=>!l.isOnFieldAsMonsterStrictly)||this.getNonTurnPlayer().getMonstersOnField().flatMap(l=>l.moveLog.records).filter(l=>l.movedAt.totalProcSeq>a).some(l=>!l.cell.isMonsterZoneLikeCell)?(this.log.info("モンスターの数が増減したためバトルステップの巻き戻しが発生。"),this.targetForAttack=void 0):this.targetForAttack.entityType==="Duelist"&&s.every(l=>l!==this.targetForAttack)&&!this.attackingMonster.status.canDirectAttack&&(this.log.info(`${this.attackingMonster.toString()}が直接攻撃能力を喪失したため、バトルステップの巻き戻しが発生。`),this.targetForAttack=void 0),!this.targetForAttack){if(!s.length){this.log.info("攻撃可能な対象が存在しないため、攻撃対象選択を選択肢しなおせない。");break}if(this.getTurnPlayer().duelistType==="Player"&&!await this.view.waitYesOrNo(this.getTurnPlayer(),"攻撃対象選択を選択し直す？")){this.getTurnPlayer().writeInfoLog(`${this.attackingMonster.toString()}の攻撃宣言をキャンセル。`);break}if(this.targetForAttack=await this.getTurnPlayer().waitSelectEntity(s,"攻撃対象を選択。",!0),!this.targetForAttack){this.getTurnPlayer().writeInfoLog(`${this.attackingMonster.toString()}の攻撃宣言をキャンセル。`);break}this.declareAnAttack(this.attackingMonster,this.targetForAttack,!0);continue}if(r==="pass")break}this.attackingMonster&&this.targetForAttack&&await this.procBattlePhaseDamageStep(i)}}});o(this,"procBattlePhaseDamageStep",async e=>{if(!this.attackingMonster||!this.targetForAttack)throw new v("想定されない状態",this.attackingMonster,this.targetForAttack);if(this.targetForAttack.entityType!=="Duelist"&&!this.targetForAttack.isOnFieldAsMonsterStrictly)throw new v("想定されない状態",this.attackingMonster,this.targetForAttack);for(const i of[this.procBattlePhaseDamageStep1,this.procBattlePhaseDamageStep2,this.procBattlePhaseDamageStep3,this.procBattlePhaseDamageStep4,this.procBattlePhaseDamageStep5])if(!await i(e))return});o(this,"procBattlePhaseDamageStep1",async()=>(this.clock.setStage(this,"start"),await this.procFreeChain(this.canContinueBattle)));o(this,"procBattlePhaseDamageStep2",async()=>{if(!this.attackingMonster)throw new v("想定されない状態",this.attackingMonster);if(!this.targetForAttack)throw new v("想定されない状態",this.targetForAttack);const e=this.attackingMonster,i=this.targetForAttack;return this.clock.setStage(this,"beforeDmgCalc"),i.battlePosition==="Set"&&i.setBattlePosition("Defense",["Flip","FlipByBattle"],e,e.controller),await this.procFreeChain(this.canContinueBattle)});o(this,"procBattlePhaseDamageStep3",async e=>{if(!this.attackingMonster)throw new v("想定されない状態",this.attackingMonster);if(!this.targetForAttack)throw new v("想定されない状態",this.targetForAttack);const i=this.attackingMonster,a=this.targetForAttack;if(i.atk===void 0)throw new v("想定されない状態",this.attackingMonster,this.targetForAttack);if(this.clock.setStage(this,"dmgCalc"),!await this.procFreeChain(this.canContinueBattle))return!1;const n=i.atk,r=(a.battlePosition==="Attack"?a.atk:a.def)??0;a.entityType==="Duelist"?(e.activator.writeInfoLog(`ダメージ計算：${i.toString()} (${n}) ⇒ ${a.toString()}`),i.controller.getOpponentPlayer().battleDamage(n-r,i,a,e)):(e.activator.writeInfoLog(`ダメージ計算：${i.toString()} (${n}) ⇒ ${a.toString()} (${r})`),n>0&&n>r?a.battlePosition==="Attack"?i.controller.getOpponentPlayer().battleDamage(n-r,i,a,e):i.status.piercingTo.getDistinct().forEach(l=>l.battleDamage(n-r,i,a,e)):n<r&&i.controller.battleDamage(r-n,a,i,e),n>0&&(n>r||n===r&&a.battlePosition==="Attack")&&await m.tryMarkForDestory([a],e),a.battlePosition==="Attack"&&n<=r&&await m.tryMarkForDestory([i],e)),i.info.battleLog.push({enemy:a,timestamp:this.clock.getClone()}),a.info.battleLog.push({enemy:i,timestamp:this.clock.getClone()});const s=Object.values(this.duelists).filter(l=>l.lp<=0);if(s.length)throw s.length===1?new $(s[0].getOpponentPlayer(),"戦闘ダメージによって、相手のライフポイントをゼロにした。"):new $(void 0,"戦闘ダメージによって、お互いのライフポイントがゼロになった。");return!0});o(this,"procBattlePhaseDamageStep4",async()=>(this.clock.setStage(this,"afterDmgCalc"),!!await this.procFreeChain()));o(this,"procBattlePhaseDamageStep5",async()=>(this.clock.setStage(this,"end"),await m.waitCorpseDisposal(this),this.clock.incrementChainSeq(),!!await this.procFreeChain()));o(this,"procBattlePhaseEndStep",async()=>{this.clock.setStep(this,"end"),this.priorityHolder=this.getTurnPlayer(),await this.procSpellSpeed1(),this.moveNextPhase("main2")});o(this,"procEndPhase",async()=>{for(await this.procSpellSpeed1();;){const i=this.getTurnPlayer().getHandCell().cardEntities.length;if(i<7)break;await this.getTurnPlayer().discard(i-6,"Rule")}this.moveNextPhase("draw")});o(this,"canContinueBattle",()=>this.attackingMonster?(this.attackingMonster.isOnFieldStrictly?this.attackingMonster.face==="FaceDown"?(this.log.info(`${this.attackingMonster.toString()}が裏側守備表示になったため、戦闘が中断された。`),this.attackingMonster=void 0):this.attackingMonster.orientation==="Horizontal"&&(this.log.info(`${this.attackingMonster.toString()}が守備表示になったため、戦闘が中断された。`),this.attackingMonster=void 0):(this.log.info(`${this.attackingMonster.toString()}がフィールドに存在しなくなっため、戦闘が中断された。`),this.attackingMonster=void 0),!!this.attackingMonster):!1);o(this,"procSpellSpeed1",async()=>{this.priorityHolder=this.getTurnPlayer();let e=0;const i={Above:Number.MAX_VALUE,Below:Number.MAX_VALUE};for(;;){const a=this.getEnableActions(this.priorityHolder,["IgnitionEffect","QuickEffect","CardActivation","LingeringEffect"],["Normal","Quick","Counter"],[]);if(i[this.priorityHolder.seat]=a.filter(l=>l.action.isMandatory).length,Object.values(i).every(l=>l===0)&&e>1)break;const n=a.find(l=>l.action.isMandatory);let r=n?{action:n.action,originSeq:n.action.seq}:void 0,s=!r;if(this.priorityHolder.isTurnPlayer?e===0&&(s=!0):i[this.getTurnPlayer().seat]&&(s=!0),a.length&&(a.length>1||!r)&&(this.priorityHolder.chainConfig.noticeFreeChain||a.some(l=>l.action.isNoticedForcibly))&&(r=await this.view.waitQuickEffect(this.priorityHolder,a,[],this.clock.period.name,s)),r){if(await this.procChain({activator:this.priorityHolder,actionInfo:r},void 0)==="cancel")continue;if(!await this.procFreeChain())return!1;this.priorityHolder=this.getTurnPlayer(),e=0;continue}this.priorityHolder=this.priorityHolder.getOpponentPlayer(),e++}return!0});o(this,"procFreeChain",async(e=()=>!0)=>{const i=this.clock.period.key;for(;await this.procChain(void 0,void 0)!=="pass";)if(this.clock.period.key!==i||!e())return!1;return!0});o(this,"procChain",async(e,i)=>{const a=this.chainBlockInfos.length===0;let n=e?[]:i??Object.values(this.duelists).flatMap(s=>this.getEnableActions(s,["TriggerEffect"],[this.chainBlockInfos.length?"Quick":"Normal"],this.chainBlockInfos).map(l=>({activator:s,actionInfo:l,targetChainBlock:this.chainBlockInfos.slice(-1)[0]}))),r;if(e)r={activator:e.activator,action:e.actionInfo.action,dest:e.actionInfo.dest,targetChainBlock:void 0},this.priorityHolder=r.activator;else if(n.length>0){const s=await this.selectTriggerEffect(n);s?(n=n.filter(l=>l!==s),r={...s,action:s.actionInfo.action},this.priorityHolder=r.activator):n=[]}if(!r){let s=0;for(;s<2;){this.priorityHolder=this.priorityHolder.getOpponentPlayer();const l=["Counter"];this.chainBlockInfos.every(d=>d.action.spellSpeed!=="Counter")&&l.push("Quick");let c=this.getEnableActions(this.priorityHolder,["QuickEffect","CardActivation"],l,this.chainBlockInfos).some(d=>d.action.isNoticedForcibly)||!!this.attackingMonster;if(c||(this.chainBlockInfos.length?c=this.priorityHolder.chainConfig.noticeSelfChain||this.chainBlockInfos.slice(-1)[0].activator!==this.priorityHolder:c=this.priorityHolder.chainConfig.noticeFreeChain),c){const d=this.chainBlockInfos.some(f=>f.action.isWithChainBlock)?"チェーンして効果を発動しますか？":"クイックエフェクト発動タイミング。効果を発動しますか？",p=await this.view.waitQuickEffect(this.priorityHolder,this.getEnableActions(this.priorityHolder,["QuickEffect","CardActivation"],l,this.chainBlockInfos),this.chainBlockInfos,d,!0);if(p){r={...p,activator:this.priorityHolder,targetChainBlock:this.chainBlockInfos.slice(-1)[0]};break}}s++}}if(console.info("selected action: ",r),r){const s=r.activator,l=await r.action.prepare(s,r.dest,r.targetChainBlock,this.chainBlockInfos,a,!1);if(!l)return"cancel";this.chainBlockLog.push(l);const u=[...l.action.entity.info.isEffectiveIn];if(this._chainBlockInfos.push(l),this.clock.incrementProcSeq(),this.clock.incrementChainBlockSeq(),n=n.filter(c=>c.actionInfo.action.seq!==(r==null?void 0:r.action.seq)).filter(c=>c.actionInfo.action.validateCount(c.activator,this.chainBlockInfos)),en.some(c=>c===l.action.playType)&&await this.procChain(void 0,n.length?n:void 0),l.chainNumber&&this.log.info(`チェーン${l.chainNumber}: ${l.action.toString()}の効果処理。`,s),l.isNegatedActivationBy)l.chainNumber&&this.log.info(`チェーン${l.chainNumber}: ${l.action.toString()}を${l.isNegatedActivationBy.toString()}によって発動を無効にした。`,l.activator);else{let c=l.action.entity.isEffective,d="";if(c){if(l.isNegatedEffectBy)d=`チェーン${l.chainNumber}: ${l.action.toString()}を${l.isNegatedEffectBy.toString()}によって効果を無効にした。`,c=!1;else if(!u.includes(l.isActivatedIn.cellType)){const p=l.action.entity.moveLog.records.findLast(f=>f.face==="FaceDown"&&f.orientation==="Horizontal");c=(p&&this.clock.isSameChain(p.movedAt))??!1}}if(c?(await l.action.execute(l,this.chainBlockInfos),l.state="done"):(l.state="failed",l.chainNumber&&(d=d||`チェーン${l.chainNumber}: カードの効果が無効となっているため${l.action.toString()}の効果処理を行えない。`),this.log.info(d,l.activator)),await r.action.settle(l,this.chainBlockInfos),l.state==="done")for(const p of[this.getTurnPlayer(),this.getNonTurnPlayer()]){for(const f of this.getEnableActions(p,["Exodia"],["Normal"],[l]))await f.action.directExecute(p,l,!1);for(const f of this.getEnableActions(p,["AfterChainBlock"],["Normal"],[l])){await f.action.directExecute(p,l,!1);for(const g of this.getEnableActions(p,["Exodia"],["Normal"],[l]))await g.action.directExecute(p,l,!1)}}}a?(await m.sendManyToGraveyardForTheSameReason(this._chainBlockInfos.filter(c=>c.action.playType==="CardActivation").filter(c=>!c.action.isLikeContinuousSpell).map(c=>c.action.entity).filter(c=>c.isOnFieldStrictly).filter(c=>c.face==="FaceUp"),["Rule"],void 0,void 0),this._chainBlockInfos.reset(),l.nextActionInfo&&await this.procChain({activator:l.activator,actionInfo:l.nextActionInfo},void 0),this.clock.incrementChainSeq()):(l.nextActionInfo&&await l.nextActionInfo.action.directExecute(l.activator,void 0,!1),this.clock.incrementChainBlockSeq())}return r?"done":"pass"});o(this,"selectTriggerEffect",async e=>{if(e.length>0)for(const i of[!0,!1])for(const a of[this.getTurnPlayer(),this.getNonTurnPlayer()]){const n=e.filter(s=>s.actionInfo.action.isMandatory===i&&s.activator===a);if(n.length===0)continue;if(n.length===1&&i)return n[0];const r=await this.view.waitQuickEffect(a,n.map(s=>s.actionInfo),this.chainBlockInfos,"トリガーエフェクトを選択。",!i);if(r)return n.find(s=>s.actionInfo.action===r.action)}});o(this,"executeSystemPeriodActions",()=>{Object.values(this.duelists).forEach(e=>this.getEnableActions(e,["SystemPeriodAction"],["Normal"],[]))});o(this,"getEnableActions",(e,i,a,n)=>{var s;const r=((s=n.slice(-1)[0])==null?void 0:s.nextChainBlockFilter)??(()=>!0);return[...this.field.getAllCardEntities(),e.entity].flatMap(l=>l.actions).filter(l=>l.executableCells.includes(l.entity.fieldCell.cellType)).filter(l=>l.executablePeriods.includes(this.clock.period.key)).filter(l=>a.includes(l.spellSpeed)).filter(l=>l.validateDuelist(e)).filter(l=>i.includes(l.playType)).filter(l=>r(e,l)).map(l=>l.validate(e,n)).filter(l=>l!==void 0)});this.clock=new Ka,this.nextPhaseList=[],this.isEnded=!1,this.startMode=c,this.duelists={Below:new xe(this,"Below",e,i,a,n),Above:new xe(this,"Above",r,s,l,u)},this.priorityHolder=this.firstPlayer,this._chainBlockInfos=[],this.field=new Ga(this),this.clock.onProcSeqChange.append(this.distributeOperators),this.clock.onStageChange.append(this.executeSystemPeriodActions),this.view=new Xa(this),this.log=new ja(this),this.chainBlockLog=new Ja(this)}get onDuelEnd(){return this.onDuelEndEvent.expose()}get phase(){return this.clock.period.phase}get step(){return this.clock.period.step}get stage(){return this.clock.period.stage}get chainBlockInfos(){return this._chainBlockInfos}get firstPlayer(){return this.coin?this.duelists.Below:this.duelists.Above}get secondPlayer(){return this.coin?this.duelists.Above:this.duelists.Below}}const G=class G{constructor(e){o(this,"id");o(this,"name");o(this,"description");o(this,"chainConfig");o(this,"previousGameMode");o(this,"previousNpcId");o(this,"previousNpcDeckId");o(this,"previousStartMode");o(this,"npcLvl",Number.MAX_VALUE);o(this,"npcType","None");o(this,"save",async e=>{const i={id:this.id,name:this.name,description:this.description,chainConfig:this.chainConfig??{noticeSelfChain:!1,noticeFreeChainPhase:!1,noticeFreeChainStep:!1,noticeAfterChainInMainPhase:!1},previousGameMode:this.previousGameMode??"Preset",previousNpcId:this.previousNpcId??Number.MIN_SAFE_INTEGER,previousStartMode:this.previousStartMode,previousNpcDeckId:this.previousNpcDeckId>-1?this.previousNpcDeckId:Number.MIN_SAFE_INTEGER,...e},a=await G.tblHeader.update(this.id,n=>({...n,...i}));return console.log(this.previousNpcDeckId,Number.MIN_SAFE_INTEGER,i,a),new G(a)});var i;this.id=e.id,this.name=e.name,this.description=e.description,this.chainConfig=e.chainConfig,this.previousGameMode=e.previousGameMode,this.previousNpcId=((i=Tt.find(a=>a.id===e.previousNpcId))==null?void 0:i.id)??Me(...Tt.map(a=>a.id)),this.previousStartMode=Ya.includes(e.previousStartMode)?e.previousStartMode:"Random",this.previousNpcDeckId=e.previousNpcDeckId}};o(G,"tblHeader"),o(G,"getOrCreateNew",async e=>{G.tblHeader||(G.tblHeader=new Ia(e));const i=await G.tblHeader.getAll();if(i.length){let n=i[0];return n.chainConfig||(n={...n,chainConfig:{noticeSelfChain:!1,noticeFreeChain:!1}}),new G(n)}const a=await G.tblHeader.insert({name:"あなた",description:"ここの文字列を何に使うかは未定。",chainConfig:{noticeSelfChain:!1,noticeFreeChain:!1},previousGameMode:"Preset",previousNpcId:0,previousNpcDeckId:Number.MIN_SAFE_INTEGER,previousStartMode:"Random"});return new G(a)});let Ct=G;class Ia extends tt{constructor(i){super(i,"TblDuelistProfile");o(this,"_prepareInitialRecords",()=>[])}}let Ge=-1;const Tt=[{id:Ge--,name:"サンドバッグくん棒立ち",description:"攻撃宣言なし、強制効果以外の効果の発動なし。",npcLvl:0,npcType:"Normal"},{id:Ge--,name:"サンドバッグくん非暴力",description:"攻撃宣言なし。",npcLvl:100,npcType:"Normal"},{id:Ge--,name:"サンドバッグくん白帯",description:"とくに制限なし。",npcLvl:200,npcType:"Normal"},{id:Number.MIN_SAFE_INTEGER,name:"FTK or Die",description:"FTKに失敗すると敗北。",npcLvl:Number.MIN_SAFE_INTEGER,npcType:"FtkChallenge"}],us=["noticeSelfChain","noticeFreeChain"],ds={noticeSelfChain:"セルフチェーン",noticeFreeChain:"フリーチェーン"},Le=class Le{constructor(e,i,a,n,r,s=[]){o(this,"duel");o(this,"seat");o(this,"profile");o(this,"deckInfo");o(this,"info");o(this,"infoOrigin");o(this,"status");o(this,"statusOrigin");o(this,"duelistType");o(this,"lifeLog");o(this,"actionBlackListForNPC");o(this,"_lp");o(this,"initHand");o(this,"chainConfig");o(this,"writeInfoLog",e=>{this.duel.log.info(e,this)});o(this,"initForDrawPhase",()=>{this.info={...this.infoOrigin}});o(this,"canDiscard",e=>(this.status.canDiscardAsCost&&console.log(e),!0));o(this,"canSendToGraveyard",e=>(console.log(e),!0));o(this,"canRelease",e=>(console.log(e),!0));o(this,"canTryBanish",(e,i,a)=>this.entity.procFilterBundle.effectiveOperators.filter(n=>n.procTypes.includes(i)).every(n=>n.filter(this,this.entity,a,[e])));o(this,"battleDamage",(e,i,a,n)=>{const r=La(e,n.activator,this,i,a,n.action);return this.damage(i,r)});o(this,"effectDamage",(e,i)=>{const a=Oa(e,i,this);return this.damage(i.action.entity,a)});o(this,"damage",(e,i)=>{const a=[];if(i.point){const n=i.damageType==="Heal"?i.point:i.point*-1;a.push(this.setLp(this._lp+n,e,i.damageType))}return i.damageToOpponent1&&a.push(this.getOpponentPlayer().setLp(this._lp-i.damageToOpponent1,e,i.damageType)),i.damageToOpponent2&&a.push(this.getOpponentPlayer().setLp(this._lp-i.damageToOpponent2,e,i.damageType)),a});o(this,"lostLp",(e,i)=>this.setLp(this._lp-e,i,"Lost"));o(this,"payLp",(e,i)=>this.setLp(this._lp-e,i,"Pay"));o(this,"heal",(e,i)=>this.setLp(this._lp+e,i,"Heal"));o(this,"setLp",(e,i,a)=>{const n={clock:this.duel.clock.getClone(),reason:a||"Set",beforeLp:this._lp,afterLp:e,entity:i};return this.lifeLog.push(n),this._lp=e,this.writeInfoLog(`ライフポイント変動：${n.afterLp-n.beforeLp}（${n.beforeLp} ⇒ ${n.afterLp}）`),n});o(this,"getOpponentPlayer",()=>this.duel.firstPlayer===this?this.duel.secondPlayer:this.duel.firstPlayer);o(this,"getCells",(...e)=>this.duel.field.getCells(...e).filter(i=>{var a;return i.owner===this||((a=i.cardEntities[0])==null?void 0:a.owner)===this}));o(this,"getHandCell",()=>this.getCells("Hand")[0]);o(this,"getDeckCell",()=>this.getCells("Deck")[0]);o(this,"getExtraDeck",()=>this.getCells("ExtraDeck")[0]);o(this,"getGraveyard",()=>this.getCells("Graveyard")[0]);o(this,"getFieldZone",()=>this.getCells("FieldSpellZone")[0]);o(this,"getBanished",()=>this.getCells("Banished")[0]);o(this,"getMonsterZones",()=>this.getCells("MonsterZone"));o(this,"getExtraMonsterZones",()=>this.getCells("ExtraMonsterZone"));o(this,"getSpellTrapZones",()=>this.getCells("SpellAndTrapZone"));o(this,"getXyzMaterialZone",()=>this.getCells("XyzMaterialZone")[0]);o(this,"getEmptyMonsterZones",()=>this.getMonsterZones().filter(e=>e.cardEntities.length===0));o(this,"getAvailableMonsterZones",()=>this.getMonsterZones().filter(e=>e.isAvailable));o(this,"getAvailableExtraMonsterZones",()=>this.getExtraMonsterZones().length===0?this.duel.field.getCells("ExtraMonsterZone").filter(e=>e.isAvailable):[]);o(this,"getAvailableSpellTrapZones",()=>this.getSpellTrapZones().filter(e=>e.isAvailable));o(this,"getMonstersOnField",()=>this.duel.field.getMonstersOnFieldStrictly().filter(e=>e.controller===this));o(this,"getSpellTrapsOnField",()=>this.duel.field.getSpellTrapsOnFieldStrictly().filter(e=>e.controller===this));o(this,"getPendingMonstersOnField",()=>this.duel.field.getPendingMonstersOnField().filter(e=>e.controller===this));o(this,"getPendulumScaleMonsters",()=>this.duel.field.getCardsOnFieldStrictly().filter(e=>e.isPendulumScale).filter(e=>e.controller===this));o(this,"getPendulumScales",()=>{const e=this.getPendulumScaleMonsters();if(e.length<2)return;const i=e.find(s=>s.fieldCell.column===(this.seat==="Below"?1:5)),a=e.find(s=>s.fieldCell.column===(this.seat==="Below"?5:1));if(!i||!a)throw new v("想定されない状態",e);const n=i.psR,r=a.psL;if(n===void 0||r===void 0)throw new v("想定されない状態",e);return n>r?{upperBound:n,lowerBound:r}:{upperBound:r,lowerBound:n}});o(this,"getEntiteisOnField",()=>this.duel.field.getCardsOnFieldStrictly().filter(e=>e.controller===this));o(this,"pushDeck",e=>{this.deckInfo.cardNames.map(i=>e[i]).filter(i=>i).forEach(i=>M.createCardEntity(this,i)),this.duel.log.info(`デッキをセット。メイン${this.getDeckCell().cardEntities.length}枚。エクストラ${this.getExtraDeck().cardEntities.length}枚。`,this)});o(this,"draw",async(e,i,a)=>{var s;if(e<1)return;const n=this.getDeckCell(),r=[];this.writeInfoLog(`デッキからカードを${e}枚ドロー。`);for(const l of Array(e)){if(!n.cardEntities.length)throw this.writeInfoLog(r.length>0?`デッキからカードを${e}枚ドローしようとしたが、${r.length}枚しかドローできなかった。${r}`:"デッキからカードをドローできなかった。"),this.duel.isEnded=!0,this.setLp(0),new $(this.getOpponentPlayer(),"対戦相手がデッキからカードをドローできなかった。");const u=n.cardEntities[0];await u.draw(i?["Effect"]:["Rule"],i,a),r.push(((s=u.origin)==null?void 0:s.name)||"!名称取得失敗!")}});o(this,"summon",async(e,i,a,n,r,s,l,u)=>(await this.summonMany(this,e,i,a,[{monster:n,posList:r,cells:s}],l,!1,1,d=>d.length===1,u)??[])[0]);o(this,"waitSelectEntities",(e,i,a,n,r=!1)=>this.duel.view.waitSelectEntities(this,{selectables:e,qty:i,validator:a,cancelable:r},n));o(this,"waitSelectEntity",async(e,i,a=!1)=>{const n=await this.waitSelectEntities(e,1,r=>r.length===1,i,a);return n?n[0]:void 0});o(this,"waitSelectText",(e,i,a=!1)=>this.duel.view.waitSelectText(this,e,i,a));o(this,"discard",async(e,i,a=()=>!0,n,r,s,l=!1)=>{const u=this.getHandCell().cardEntities.filter(a);if(u.length<e)return[];let c=[];if(u.length===e)c=u;else if((s||this).duelistType==="NPC")c=u.randomPickMany(e);else{const d=await this.duel.view.waitSelectEntities(s||this,{selectables:u,qty:e,validator:p=>p.length===e,cancelable:l},`${e}枚カードを捨てる。`);if(!d)return;c=d}return this.writeInfoLog(`手札からカードを${c.length}枚捨てた。${c.map(d=>{var p;return(p=d.origin)==null?void 0:p.name})}。`),await m.discardManyForTheSameReason(c,["Discard",i],n,r),c});o(this,"getEnableSummonList",(e,i,a,n,r,s,l)=>{const u=this.duel.field.getCells("ExtraMonsterZone"),c=u.filter(p=>!s.map(f=>f.material).includes(p.cardEntities[0])).filter(p=>p.owner===this),d=[];return c.length&&d.push(...u.filter(p=>!c.includes(p)).filter(p=>p.isAvailable)),r.map(p=>({...p,summoner:this})).map(p=>{var f;return(i!=="LinkSummon"||!this.duel.field.canExtraLink(p.monster,s))&&(p.cells=p.cells.filter(g=>!d.includes(g))),(f=p.monster.status.monsterCategories)!=null&&f.includes("Link")&&(p.posList=p.posList.filter(g=>g==="Attack")),p}).map(p=>({...p,cells:p.cells.filter(f=>f.cardEntities.length===0||s.some(g=>g.material===f.cardEntities[0]))})).map(p=>{var f,g;if(p.monster.fieldCell.cellType==="ExtraDeck"){if((f=p.monster.status.monsterCategories)!=null&&f.includes("Link")||(g=p.monster.status.monsterCategories)!=null&&g.includes("Pendulum"))return{...p,cells:p.cells.filter(y=>y.cellType==="ExtraMonsterZone"||y.linkArrowSources.filter(b=>!s.map(h=>h.material).includes(b)).length)}}else return{...p,cells:p.cells.filter(y=>y.cellType!=="ExtraMonsterZone")};return p}).filter(p=>p.cells.length&&p.posList.length).map(p=>this.entity.summonFilterBundle.filter(e,i,a,n,p,s,l)).filter(p=>p.cells.length&&p.posList.length).map(p=>p.monster.summonFilterBundle.filter(e,i,a,n,p,s,l)).filter(p=>p.cells.length&&p.posList.length).map(p=>s.map(f=>f.material.summonFilterBundle).reduce((f,g)=>g.filter(e,i,a,n,f,s,l),p)).filter(p=>p.cells.length&&p.posList.length)});o(this,"prepareToSummonMany",async(e,i,a,n,r,s,l,u,c,d,p="特殊召喚するモンスターを選択。")=>{const f=this.getEnableSummonList(e,i,a,n,r,s,l);if(!f.length)return[];let g=f.map(b=>({...b,cells:[...b.cells],posList:[...b.posList]}));const y=[];for(;g.length&&y.length<(u??Number.MAX_SAFE_INTEGER);){const b=d&&!y.length||c(y.map(O=>O.monster));let h=g.randomPick();if(g.length>1){const O=await this.waitSelectEntity(g.map(ae=>ae.monster),p,b);if(!O)return y;h=g.find(ae=>ae.monster===O)??h}let k=[...h.posList].randomPick(),L=[...h.cells].randomPick();if((h.cells.length||h.posList.length)&&this.duelistType!=="NPC"){const O=await this.duel.view.waitSelectSummonDestination(h.summoner,h.monster,h.cells,h.posList,b);if(!O)return y;L=O.dest,k=O.battlePosition}y.push({summoner:this,monster:h.monster,pos:k,dest:L});const Z=L.cellType==="ExtraMonsterZone";g.forEach(O=>{O.cells=O.cells.filter(ae=>!y.map(zi=>zi.dest).includes(ae)),Z&&(O.cells=O.cells.filter(ae=>ae.cellType!=="ExtraMonsterZone"))}),g=g.filter(O=>O!==h).filter(O=>O.cells.length)}return y});o(this,"summonAll",(e,i,a,n,r,s,l,u,c)=>this.summonMany(e,i,a,n,r,s,l,r.length,d=>d.length===r.length,u,c));o(this,"summonOne",async(e,i,a,n,r,s,l,u,c)=>{const d=await this.summonMany(e,i,a,n,r,s,l,1,p=>p.length===1,u,c);if(d)return d[0]});o(this,"summonMany",(e,i,a,n,r,s,l,u,c,d,p)=>Le.summonMany(e,i,a,n,r.map(f=>({...f,summoner:this})),s,l,u,c,d,p));o(this,"selectAttackTargetForNPC",(e,i)=>{const a=e.atk??0,n=e.getAttackTargets();if(!n.length)return;const r=n.find(s=>s.entityType==="Duelist");return r&&(a>=Me(1600,this.getOpponentPlayer().lp)||e.info.battlePotisionChangeCount>0)?r:n.find(s=>s.battlePosition==="Attack"?a>=(s.atk??0):a<(s.battlePosition==="Set"?1e3:s.def??0)?!1:s.validateDestory("BattleDestroy",this,e,i))});o(this,"selectActionForNPC",(e,i)=>{if(!e.length)return;const a=e.filter(h=>h.action.isMandatory);if(a.length)return a.randomPick();let n=e.filter(h=>!this.actionBlackListForNPC.includes(h.action.playType));console.log(n);const r=n.filter(h=>!Number.isNaN(h.action.priorityForNPC)).shuffle().sort((h,k)=>h.action.priorityForNPC-k.action.priorityForNPC);if(r.length)return r[0];const s=n.filter(h=>h.action.playType==="TriggerEffect");if(s.length)return s.randomPick();if(this.duel.phase!=="main1"&&this.duel.phase!=="main2"){const h=n.filter(k=>k.action.playType==="IgnitionEffect");if(h.length)return h.randomPick()}const l=n.filter(h=>h.action.playType==="Battle").sort((h,k)=>(h.action.entity.atk??0)-(k.action.entity.atk??0));if(l.length)return l.find(h=>this.selectAttackTargetForNPC(h.action.entity,h.action));n=n.filter(h=>h.action.playType!=="Battle");const u=n.length?i.slice(-1)[0]:void 0,c=n.filter(h=>h.action.negatePreviousBlock);if(u&&u.activator!==this&&c)return c.randomPick();if(n=n.filter(h=>!h.action.negatePreviousBlock),!n.length)return;const d=Pe(...this.getOpponentPlayer().getMonstersOnField().filter(h=>h.battlePosition==="Attack").map(h=>h.atk??0),1600),p=Me(...this.getOpponentPlayer().getMonstersOnField().map(h=>h.battlePosition==="Set"?1500:(h.battlePosition==="Attack"?h.atk:h.def)??0),1500),f=this.getMonstersOnField(),g=Pe(...f.filter(h=>h.battlePosition==="Attack").map(h=>h.atk??0),0);let y=n.filter(h=>h.action.playType!=="ChangeBattlePosition").filter(h=>h.action.entity.battlePosition!=="Attack").filter(h=>(h.action.entity.atk??0)>=d||(h.action.entity.atk??0)>p&&(h.action.entity.atk??0)>2300);if(y.length)return y.randomPick();n=n.filter(h=>h.action.playType!=="ChangeBattlePosition").filter(h=>h.action.playType!=="SpellTrapSet").filter(h=>h.action.entity.actions.filter(k=>k.playType!=="NormalSummon"&&k.playType!=="SpecialSummon").flatMap(k=>k.executableCells).every(k=>k!=="Hand")||h.action.playType!=="NormalSummon"&&h.action.playType!=="SpecialSummon");const b=[...n.filter(h=>h.action.playType==="NormalSummon").filter(h=>(h.action.entity.lvl??12)<5),...n.filter(h=>h.action.playType==="SpecialSummon"),...n.filter(h=>h.action.playType==="NormalSummon").filter(h=>(h.action.entity.atk??0)>2600||(h.action.entity.atk??0)>2300&&(h.action.entity.lvl??12)<7).filter(h=>(h.action.entity.atk??0)>=g),...n.filter(h=>h.action.entity.face==="FaceUp").filter(h=>h.action.entity.isOnFieldStrictly)];if(b.length)return b.randomPick();if(n=n.filter(h=>h.action.playType!=="NormalSummon").filter(h=>h.action.playType!=="SpecialSummon"),this.duel.phase==="main2"){if(y=e.filter(h=>h.action.playType==="ChangeBattlePosition").filter(h=>h.action.entity.battlePosition==="Attack").filter(h=>(h.action.entity.atk??0)<d||(h.action.entity.atk??0)>p&&(h.action.entity.atk??0)>2300),y.length)return y.randomPick();if(this.getAvailableSpellTrapZones.length>1)return e.filter(h=>h.action.playType==="SpellTrapSet").filter(h=>h.action.entity.kind!=="Spell"||h.action.entity.status.spellCategory==="QuickPlay").randomPick()}if(console.log(n),Math.random()<n.length/4)return n.randomPick()});this.duel=e,this.seat=i,this.profile=a,this.chainConfig=a.chainConfig??{noticeSelfChain:!0,noticeFreeChain:!0},this.duelistType=n,this.deckInfo=r,this.initHand=s,this.lifeLog=[],this.infoOrigin={maxRuleNormalSummonCount:1,ruleNormalSummonCount:0,ruleNormalSummonCountQty:0,effectNormalSummonCount:0,effectNormalSummonCountQty:0,specialSummonCount:0,specialSummonCountQty:0},this.info={...this.infoOrigin},this.statusOrigin={maxSpecialSummonCount:Number.MAX_VALUE,canDrawByEffect:!0,canSearchFromDeck:!0,canDiscardAsCost:!0,canDiscardAsEffect:!0},this.status={...this.statusOrigin},this._lp=8e3;const l=[];this.duelistType==="NPC"&&(this.profile.npcLvl<0&&l.push("NormalSummon","SpecialSummon","SpellTrapSet"),this.profile.npcLvl<1&&l.push("CardActivation","IgnitionEffect","TriggerEffect","QuickEffect"),this.profile.npcLvl<101&&l.push("Battle")),this.actionBlackListForNPC=l}get entity(){const e=this.getHandCell().entities.find(i=>i.entityType==="Duelist");return e||M.createPlayerEntity(this)}get lp(){return this._lp}get isTurnPlayer(){return this.duel.getTurnPlayer()===this}get canDraw(){return!0}get canAddToHandFromDeck(){return!0}get canSet(){return!0}};o(Le,"summonMany",async(e,i,a,n,r,s,l,u,c,d,p="特殊召喚するモンスターを選択。")=>{const f=r.map(y=>y.summoner).getDistinct(),g=[];for(const y of f){const b=await y.prepareToSummonMany(e,i,a,n,r.filter(h=>h.summoner===y),s,l,u,c,d,p);g.push(...b)}if(g.length)return g.forEach(y=>y.monster.info.materials.reset(...s)),await m.moveToXyzOwner(g[0].dest,s.map(y=>y.material).filter(y=>y.kind==="XyzMaterial"),["XyzMaterial","Rule"],g[0].monster,e),await M.summonMany(g,i,a,n.entity,e),g.map(y=>y.monster)});let xe=Le;const Ee=["Controller","Opponent"],jt=["NormalSummon","SpecialSummon","FlipSummon"],nt=["IgnitionEffect","TriggerEffect","QuickEffect","CardActivation"],en=[...jt,...nt],tn=t=>t==="CardActivation"?"CardActivation":nt.some(e=>e===t)?"EffectActivation":"NonActivate",Et=["NormalSummon","AdvanceSummon","SpecialSummon","SpecialSummonFromDeck","SendToGraveyardFromDeck","Draw","SearchFromDeck","BanishFromDeck","BanishFromGraveyard","AddToHandFromGraveyard","ReturnToDeckFromGraveyard","SpecialSummonFromGraveyard","SpecialSummonFromBanished","ReturnToHandFromGraveyard","ReturnToHandFromField","BanishFromField","BanishFromHand","Destroy","DestroyMultiple","DestroyOnField","DestroyMultipleOnField","DestroyOnOpponentField","DestroyMultipleOnOpponentField","DestroyMonsterOnField","DestroyMonstersOnField","DestroySpellTrapOnField","DestroySpellTrapsOnField","SpecialSummonFromHand","SpecialSummonFromExtraDeck","IfNormarlSummonSucceed","IfSpecialSummonSucceed","DamageToOpponent","DamageToSelf","PayLifePoint","DiscordAsCost","DiscordAsEffect","RollDice","BounceToHand","NegateCardEffect","NegateCardActivation","NegateNormalSummon","NegateSpecialSummon"],re=class re extends Ae{constructor(i,a,n,r){super(i,a,n);o(this,"getTargetableEntities",(i,a)=>{if(this.definition.hasToTargetCards&&!this.definition.getTargetableEntities)throw new v(`処理定義が矛盾している。${this.toString()}`,this);return this.definition.getTargetableEntities?this.definition.getTargetableEntities(i,a):[]});o(this,"toString",()=>this.isWithChainBlock&&this.playType!=="CardActivation"?`${this.entity.toString()}の«${this.title}»`:`${this.entity.toString()}の${this.title}`);o(this,"addhocMaterialLimitation");o(this,"getClone",i=>new re(this.seq,this.entity,this.definition,i));o(this,"validateCount",(i,a)=>{const n=a.filter(s=>this.isSameGroup(s.action)).length;if(this.isOnlyNTimesPerDuel>0&&this.entity.field.duel.chainBlockLog.records.filter(s=>!s.chainBlockInfo.isNegatedActivationBy).filter(s=>this.isSameGroup(s.chainBlockInfo.action)).filter(s=>s.chainBlockInfo.activator===i).length+n>=this.isOnlyNTimesPerDuel||this.isOnlyNTimesPerTurn>0&&this.entity.field.duel.chainBlockLog.records.filter(s=>!s.chainBlockInfo.isNegatedActivationBy).filter(s=>this.isSameGroup(s.chainBlockInfo.action)).filter(s=>s.clock.turn===this.entity.field.duel.clock.turn).filter(s=>s.chainBlockInfo.activator===i).length+n>=this.isOnlyNTimesPerTurn||this.isOnlyNTimesPerChain>0&&n>=this.isOnlyNTimesPerChain)return!1;const r=n+this.entity.counterHolder.getActionCount(this);return!(this.isOnlyNTimesPerTurnIfFaceup>0&&r>=this.isOnlyNTimesPerTurnIfFaceup||this.isOnlyNTimesIfFaceup>0&&r>=this.isOnlyNTimesIfFaceup)});o(this,"validate",(i,a,n=[])=>{const r=n.includes("IgnoreCosts"),s=n.includes("IgnoreConditions"),l=n.includes("CopyEffectOnly");if(this.isWithChainBlock&&!this.entity.status.canActivateEffect||r&&this.needsToPayCost||!this.validateCount(i,a))return;const u=Pe(0,...a.map(p=>p.chainNumber??-1)),c={index:a.length,chainNumber:this.isWithChainBlock?u+1:void 0,action:this,activator:i,targetChainBlock:a.slice(-1)[0],isActivatedIn:this.entity.fieldCell,isActivatedAt:this.duel.clock.getClone(),costInfo:{},state:"unloaded",dest:void 0,ignoreCost:!1};if(this.definition.canPayCosts&&!r&&!this.definition.canPayCosts(c,this.playType==="AfterChainBlock"?[]:a)||this.definition.meetsConditions&&!s&&!this.definition.meetsConditions(c,this.playType==="AfterChainBlock"?[]:a)||this.definition.canExecute&&!this.definition.canExecute(c,this.playType==="AfterChainBlock"?[]:a))return;const d=[];if(this.definition.getDests&&d.push(...this.definition.getDests(c,this.playType==="AfterChainBlock"?[]:a)),this.playType==="CardActivation"&&!l){const p=this.getDestForCardActivation(i);if(!p)return;d.push(...p)}else this.playType==="SpellTrapSet"&&(this.entity.status.spellCategory==="Field"?d.push(i.getFieldZone()):d.push(...i.getAvailableSpellTrapZones()));return{action:this,dests:d,originSeq:this.seq}});o(this,"getDestForCardActivation",i=>{var n;if(this.entity.info.isPending||this.entity.info.isDying||this.entity.info.isSettingSickness)return;if(this.entity.isOnFieldAsSpellTrapStrictly)return this.entity.face==="FaceDown"?[]:void 0;if(this.entity.fieldCell.cellType!=="Hand"||this.definition.canActivateCardDirectly||!i.isTurnPlayer)return;if(this.entity.status.spellCategory==="Field")return[i.getFieldZone()];let a=i.getAvailableSpellTrapZones();return(n=this.entity.status.monsterCategories)!=null&&n.includes("Pendulum")&&(a=a.filter(r=>r.isAvailableForPendulum)),a});o(this,"prepare",async(i,a,n,r,s,l)=>{var b,h;let u=a,c=s;const d=this.isWithChainBlock?Pe(0,...r.map(k=>k.chainNumber??-1))+1:void 0;let p="";if(d!==void 0&&(p+=`チェーン${d}: `),this.playType==="CardActivation"||this.playType==="SpellTrapSet")if(this.entity.fieldCell.cellType==="Hand"){let k=this.entity.status.spellCategory==="Field"?[i.getFieldZone()]:i.getAvailableSpellTrapZones();if((b=this.entity.status.monsterCategories)!=null&&b.includes("Pendulum")&&(k=k.filter(Z=>Z.isAvailableForPendulum)),u&&k.includes(u)&&(k=[u],u=void 0),this.entity.status.spellCategory==="Field"){const Z=i.getFieldZone().cardEntities;if(Z.length){const O=Z[0];await m.sendManyToGraveyardForTheSameReason(i.getFieldZone().cardEntities,["Rule"],this.entity,i),i.writeInfoLog(`フィールド魔法の上書きにより、${O.toString()}は墓地に送られた。`),c=!1}}let L=k[0];if(k.length>1){L=k.randomPick();const Z=this.playType==="SpellTrapSet"?"セット":"カードの発動",O=await this.duel.view.waitSelectDestination(i,this.entity,k,"カードを移動先へドラッグ",Z,c);if(!O)return;L=O}p+="手札から",this.playType==="SpellTrapSet"?p+="魔法・罠カードをセット。":p+=`${this.entity.toString()}を発動。`,i.writeInfoLog(p),c=!1,this.playType==="CardActivation"&&(this.entity.info.isPending=!0),(h=this.entity.status.monsterCategories)!=null&&h.includes("Pendulum")?await this.entity.activateAsPendulumScale(L,["CardActivation"],this.entity,i):this.playType==="CardActivation"?await this.entity.activateSpellTrapFromHand(L,this.entity.kind,["CardActivation"],this.entity,i):await this.entity.setAsSpellTrap(L,this.entity.kind,["SpellTrapSet"],this.entity,i)}else this.entity.isOnField&&this.entity.face==="FaceDown"&&(p+=`セットされていた${this.entity.toString()}を発動。`,i.writeInfoLog(p),c=!1,this.playType==="CardActivation"&&(this.entity.info.isPending=!0),await this.entity.setNonFieldMonsterPosition(this.entity.origin.kind,"FaceUp",["Rule"]));else d!==void 0&&(p+=`${this.toString()}を発動。`,i.writeInfoLog(p));const f={index:r.length,chainNumber:d,action:this,activator:i,targetChainBlock:n,isActivatedIn:this.entity.fieldCell,isActivatedAt:this.duel.clock.getClone(),costInfo:{},state:"ready",dest:u,ignoreCost:!1};if(console.log(this.definition.payCosts,l),this.definition.payCosts&&!l){const k=await this.definition.payCosts(f,r,c);if(!k)return;f.costInfo=k,c=!1}const g=await this.definition.prepare(f,r,c);if(g===void 0)return;const y={...g};if(jt.some(k=>k===this.playType)){const k=g.nextChainBlockFilter??(()=>!0);y.nextChainBlockFilter=(L,Z)=>Z.negateSummon&&k(L,Z)}return{...f,...y}});o(this,"execute",async(i,a)=>{if(i.action.isLikeContinuousSpell&&(i.action.entity.face==="FaceDown"||!i.action.entity.isOnField))return this.entity.info.isPending=!1,!1;const n=await this.definition.execute(i,a);return this.entity.determine(),n});o(this,"settle",(i,a)=>(this.isOnlyNTimesPerTurnIfFaceup>0?this.entity.counterHolder.incrementActionCountPerTurn(this):this.isOnlyNTimesIfFaceup>0&&this.entity.counterHolder.incrementActionCount(this),this.definition.settle(i,a)));o(this,"directExecute",async(i,a,n)=>{const r=await this.prepare(i,void 0,a,[],!1,n);if(!r)throw new v("想定されない状態",this,i,n);const s=await this.execute(r,[]);return await this.settle(r,[]),s});o(this,"isSame",i=>this.entity.origin.name===i.entity.origin.name&&this.title===i.title);o(this,"isSameGroup",i=>this.actionGroupName?this.entity.origin.name===i.entity.origin.name&&this.actionGroupName===i.actionGroupName:this.isSame(i));o(this,"calcChainBlockTagsForDestroy",(i,a)=>{if(!Et.length)return[];const n=["Destroy"];Et.length>1&&n.push("DestroyMultiple");const r=a.filter(c=>c.isOnFieldStrictly);r.length&&(n.push("DestroyOnField"),r.length>1&&n.push("DestroyMultipleOnField"));const s=r.filter(c=>c.kind==="Monster");s.length&&(n.push("DestroyMonsterOnField"),s.length>1&&n.push("DestroyMonstersOnField")),r.filter(c=>c.kind!=="Monster").length&&(n.push("DestroySpellTrapOnField"),s.length>1&&n.push("DestroySpellTrapsOnField"));const u=r.filter(c=>c.controller!==i);return u.length&&(n.push("DestroyOnOpponentField"),u.length>1&&n.push("DestroyMultipleOnOpponentField")),n});this.addhocMaterialLimitation=r??(()=>!0)}get definition(){return super.definition}get playType(){return this.definition.playType}get spellSpeed(){return this.definition.spellSpeed}get needsToPayCost(){return this.definition.needsToPayCost??!1}get hasToTargetCards(){return this.definition.hasToTargetCards??!1}get isWithChainBlock(){return nt.some(i=>i===this.playType)}get isLikeContinuousSpell(){return this.definition.isLikeContinuousSpell||this.entity.isLikeContinuousSpell&&this.playType==="CardActivation"}get isNoticedForcibly(){return this.isMandatory||this.definition.playType==="TriggerEffect"||this.definition.playType==="LingeringEffect"||this.negatePreviousBlock||this.negateSummon}get negatePreviousBlock(){return this.definition.negatePreviousBlock??!1}get negateSummon(){return this.definition.negateSummon??!1}get priorityForNPC(){return this.definition.priorityForNPC??Number.NaN}*getEnableMaterialPatterns(i){this.definition.getEnableMaterialPatterns&&(yield*this.definition.getEnableMaterialPatterns(i).filter(this.addhocMaterialLimitation))}};o(re,"createNew",(i,a)=>new re("AutoSeq",i,a)),o(re,"createDummyAction",(i,a,n,r,s)=>({action:re.createNew(i,{title:a,isMandatory:!1,executableCells:[],executablePeriods:[],executableDuelistTypes:[],playType:"Dammy",spellSpeed:"Dammy",getDests:()=>n,prepare:async()=>{},execute:async()=>!1,settle:async()=>!1}),dests:n,battlePosition:r,originSeq:(s==null?void 0:s.seq)??-1}));let fe=re;const q=async()=>({selectedEntities:[],chainBlockTags:[],prepared:void 0}),_e=async(t,e,i)=>(t.activator.payLp(i,t.action.entity),{lifePoint:i}),an=t=>t.activator.canSendToGraveyard([t.action.entity])&&t.action.entity.canBeSentToGraveyard(t.activator,t.action.entity,"SendToGraveyardAsCost",t.action),nn=async t=>(await t.action.entity.sendToGraveyard(["Cost"],t.action.entity,t.activator),{sendToGraveyard:[t.action.entity]}),ke=t=>t.activator.canTryBanish(t.action.entity,"BanishAsCost",t.action)&&t.action.entity.canBeBanished("BanishAsCost",t.activator,t.action.entity,t.action),Re=async t=>(await t.action.entity.banish(["Cost"],t.action.entity,t.activator),{banish:[t.action.entity]}),rn=(t,e,i=1)=>e.filter(a=>t.activator.canTryBanish(a,"BanishAsCost",t.action)).filter(a=>a.canBeBanished("BanishAsCost",t.activator,t.action.entity,t.action)).length>=i,sn=async(t,e,i,a)=>{const n=e.filter(s=>t.activator.canTryBanish(s,"BanishAsCost",t.action)).filter(s=>s.canBeBanished("BanishAsCost",t.activator,t.action.entity,t.action)),r=await t.activator.waitSelectEntities(n,a,i,"コストとして除外するカードを選択",!1)??[];return await m.banishManyForTheSameReason(r,["Cost"],t.action.entity,t.activator),{banish:r}},rt=(t,e,i=()=>!0,a=1)=>t.activator.getHandCell().cardEntities.filter(i).filter(n=>t.activator.canDiscard([n])).length>=a,st=async(t,e,i=!1,a=()=>!0,n=1)=>({discard:await t.activator.discard(n,"Cost",a,t.action.entity,t.activator,t.activator,i)}),on=(t,e)=>rt(t,e,i=>t.action.entity===i,1),ln=(t,e,i=!1)=>st(t,e,i,a=>t.action.entity===a),cn=(t,e)=>t.action.getTargetableEntities(t,e).filter(i=>i.isOnField).map(i=>i.fieldCell),X=(t,e={})=>({hasToTargetCards:!0,getTargetableEntities:t,canExecute:(i,a)=>t(i,a).filter(n=>n.canBeTargetOfEffect(i)).length>0&&(!e.canExecute||e.canExecute(i,a)),getDests:cn,prepare:async(i,a,n)=>{let r=[];if(i.dest)r=[i.dest.cardEntities[0]];else{const l=i.action.getTargetableEntities(i,a).filter(c=>c.canBeTargetOfEffect(i)),u=await i.activator.waitSelectEntity(l,e.message??"対象とするカードを選択。",n);if(!u)return;r=[u]}const s=e.tags??[];return e.destoryTargets&&s.push(...i.action.calcChainBlockTagsForDestroy(i.activator,r)),{selectedEntities:r,chainBlockTags:s,prepared:void 0}}}),le=async(t,e,i=S,a=r=>r.length===1,n=1)=>{const r=t.activator.getMonsterZones(),s=t.activator.getEnableSummonList(t.activator,"SpecialSummon",["Effect"],t.action,e.filter(c=>c.kind==="Monster").filter(c=>c.canBeTargetOfEffect(t)).map(c=>({monster:c,posList:i,cells:r})),[],!1),l=await t.activator.waitSelectEntities(s.map(c=>c.monster),n,a,"特殊召喚するモンスターを選択",!1)??[];if(!l.length)throw new F(t);const u=l.map(c=>c.fieldCell.cellType).getDistinct().filter(c=>c==="Graveyard"||c==="Banished").map(c=>c==="Graveyard"?"SpecialSummonFromGraveyard":"SpecialSummonFromBanished");return{selectedEntities:l,chainBlockTags:u,prepared:void 0}},ce=async(t,e=["Attack","Defense"],i=!0)=>{const a=t.activator.getMonsterZones(),n=t.selectedEntities.filter(r=>!r.wasMovedAfter(t.isActivatedAt)).map(r=>({monster:r,posList:e,cells:a}));return i&&(n.length!==t.selectedEntities.length||a.length<n.length)?!1:(await t.activator.summonAll(t.activator,"SpecialSummon",["Effect"],t.action,n,[],!1,!1),!0)},un=async(t,e,i=["Attack","Defense"])=>{const a=t.activator.getMonsterZones(),n=e.map(r=>({monster:r,posList:i,cells:a}));return await t.activator.summonAll(t.activator,"SpecialSummon",["Effect"],t.action,n,[],!1,!1),!0},dn=(t,e,i)=>({title:t,playType:"SystemPeriodAction",spellSpeed:"Normal",executableCells:I,executablePeriods:e,executableDuelistTypes:Ee,isMandatory:!0,canExecute:a=>(i(a),!1),prepare:q,execute:async()=>!0,settle:async()=>!0}),C={title:"セット",playType:"SpellTrapSet",spellSpeed:"Normal",executableCells:["Hand"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],isMandatory:!1,prepare:q,execute:async()=>!0,settle:async()=>!0},ee={title:"発動",isMandatory:!1,playType:"CardActivation",spellSpeed:"Normal",executableCells:["Hand","SpellAndTrapZone"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],prepare:q,execute:async()=>!0,settle:async()=>!0},pn=async(t,e,i,a,n)=>{const r=t.action.getTargetableEntities(t,e);if(!r)throw new v("CardAction定義が正しくない",t);const s=await t.activator.waitSelectEntity(r,"装備対象モンスターを選択",i);if(s)return t.action.entity.info.equipedBy=s,t.action.entity.info.effectTargets[t.action.seq]=[s],{chainBlockTags:a??[],selectedEntities:[s],prepared:n}},Ut=async(t,e,i=()=>!0)=>{const a=t.selectedEntities[0];return t.action.entity.info.equipedBy=a,t.action.entity.info.effectTargets[t.action.seq]=[a],i(a,t.action.entity)?(t.action.entity.info.equipedBy=a,t.action.entity.info.validateEquipOwner=i,a.info.equipEntities.push(t.action.entity),!0):(await t.action.entity.ruleDestory(),t.activator.writeInfoLog(`${a.toString()}が装備条件を満たさなくなったため、${t.action.entity.toString()}は破壊された。`),!1)},he=(t=()=>!0)=>({title:"発動",isMandatory:!1,playType:"CardActivation",spellSpeed:"Normal",executableCells:["Hand","SpellAndTrapZone"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],getTargetableEntities:e=>e.action.entity.field.getMonstersOnFieldStrictly().filter(i=>i.face==="FaceUp").filter(i=>i.canBeTargetOfEffect(e)).filter(i=>t(i,e.action.entity)),getDests:(e,i)=>e.action.getTargetableEntities(e,i).filter(a=>a.isOnFieldAsMonsterStrictly).map(a=>a.fieldCell),prepare:(e,i,a)=>pn(e,i,a,[],void 0),execute:Ut,settle:async()=>!0});function*fn(){yield{name:"連合軍",actions:[ee,C],continuousEffects:[De("発動","Spell",t=>[H.createContinuous("発動",e=>e.isSpawnedBy.isOnFieldStrictly&&e.isSpawnedBy.face==="FaceUp",t,(e,i)=>i.controller===e.isSpawnedBy.controller&&i.types.includes("Warrior")&&i.isOnFieldStrictly&&i.face==="FaceUp","attack","wip","Addition",(e,i,a)=>{if(!e.isEffective||i.face==="FaceDown")return a;const n=e.controller.getMonstersOnField().filter(r=>r.face==="FaceUp").filter(r=>r.types.includes("Warrior")||r.types.includes("Spellcaster")).length;return a+n*200})])]}}const Vt=Object.freeze(Object.defineProperty({__proto__:null,default:fn},Symbol.toStringTag,{value:"Module"}));function*hn(){yield*[{name:"リビングデッドの呼び声",pos:"Attack",filter:()=>!0},{name:"エンジェル・リフト",pos:"Attack",filter:t=>(t.lvl??12)<3},{name:"正統なる血統",pos:"Attack",filter:t=>{var e;return(e=t.status.monsterCategories)==null?void 0:e.includes("Normal")}},{name:"蘇りし魂",pos:"Defense",filter:t=>{var e;return(e=t.status.monsterCategories)==null?void 0:e.includes("Normal")}},{name:"リミット・リバース",pos:"Attack",filter:t=>(t.atk??9999)<=1e3,onMonsterAfterMove:async(t,e)=>{if(!e.isOnFieldAsMonsterStrictly||e.face==="FaceDown")return"RemoveMe";if(t.action.entity.isEffective&&e.battlePosition==="Defense")return t.action.entity.controller.writeInfoLog(`${e.toString()}が守備表示になったため、${t.action.entity.toString()}とともに破壊される。`),await m.tryMarkForDestory([e,t.action.entity],t),"RemoveMe"}}].map(t=>({name:t.name,actions:[{title:"発動",isMandatory:!1,playType:"CardActivation",spellSpeed:"Quick",executableCells:["SpellAndTrapZone"],executablePeriods:D,executableDuelistTypes:["Controller"],canExecute:e=>{const i=e.activator.getMonsterZones();return e.activator.getEnableSummonList(e.activator,"SpecialSummon",["Effect"],e.action,e.activator.getGraveyard().cardEntities.filter(n=>n.kind==="Monster").filter(t.filter).filter(n=>n.canBeTargetOfEffect(e)).map(n=>({monster:n,posList:["Attack"],cells:i})),[],!1).length>0},prepare:e=>le(e,e.activator.getGraveyard().cardEntities.filter(i=>i.kind==="Monster").filter(t.filter).filter(i=>i.canBeTargetOfEffect(e)),["Attack"]),execute:async e=>{if(!await ce(e,["Attack"])||!e.selectedEntities.length)return!1;e.action.entity.info.effectTargets[e.action.seq]=e.selectedEntities,e.action.entity.onBeforeMove.append(async n=>{if(n.entity.face!=="FaceUp"||!n.entity.isOnFieldAsSpellTrapStrictly)return"RemoveMe";const r=Object.values(n.entity.info.effectTargets).flatMap(u=>u),[s]=n.args;if(!r.length)return"RemoveMe";const l=r[0];return l.isOnFieldStrictly&&l.face==="FaceUp"&&n.entity.isEffective&&!s.isSpellTrapZoneLikeCell&&(n.entity.controller.writeInfoLog(`${e.action.entity.toString()}がフィールドを離れたため、対象モンスター${l.toString()}を破壊。`),await m.tryMarkForDestory([l],e)),"RemoveMe"});const a=e.selectedEntities[0];return a.onBeforeMove.append(async n=>{if(n.entity.face!=="FaceUp"||!n.entity.isOnFieldAsMonsterStrictly)return"RemoveMe";const[,,,,,r]=n.args;return e.action.entity.isOnFieldStrictly&&e.action.entity.face==="FaceUp"&&n.entity.isEffective&&r.union(["EffectDestroy","RuleDestroy"]).length&&(e.activator.writeInfoLog(`${n.entity.toString()}が破壊されたため、${e.action.entity.toString()}を破壊。`),await m.tryMarkForDestory([a],e)),"RemoveMe"}),a.onAfterMove.append(async n=>t.onMonsterAfterMove?await t.onMonsterAfterMove(e,n):"RemoveMe"),!0},settle:async()=>!0},C]}))}const zt=Object.freeze(Object.defineProperty({__proto__:null,default:hn},Symbol.toStringTag,{value:"Module"}));function*gn(){yield{name:"昇天の黒角笛",actions:[{title:"発動",isMandatory:!1,playType:"CardActivation",spellSpeed:"Counter",executableCells:["SpellAndTrapZone"],executablePeriods:U,executableDuelistTypes:["Controller"],negateSummon:!0,canExecute:t=>(t.targetChainBlock&&t.targetChainBlock.action.playType==="SpecialSummon"&&t.targetChainBlock.activator!==t.activator&&t.activator.duel.field.getPendingMonstersOnField().length===1)??!1,prepare:async()=>({selectedEntities:[],chainBlockTags:["NegateSpecialSummon"],prepared:void 0}),execute:async t=>{const e=m.negateSummonMany(t.action.entity,t.activator);return await m.tryDestroy(e,t),!0},settle:async()=>!0},C]}}const Wt=Object.freeze(Object.defineProperty({__proto__:null,default:gn},Symbol.toStringTag,{value:"Module"}));function*yn(){yield*[{name:"団結の力",kind:["Monster"],rate:800},{name:"魔導師の力",kind:["Spell","Trap"],rate:500}].map(t=>({name:t.name,actions:[he(),C],continuousEffects:[Te(t.name,"Spell",e=>e.info.equipedBy?[e.info.equipedBy]:[],e=>["attack","defense"].map(i=>H.createContinuous("発動",a=>a.isSpawnedBy.isOnFieldStrictly&&a.isSpawnedBy.face==="FaceUp",e,(a,n)=>n.isOnFieldStrictly&&n.face==="FaceUp",i,"wip","Addition",(a,n,r)=>{if(!a.isEffective)return r;const s=a.controller.getEntiteisOnField().filter(l=>t.kind.includes(l.kind)).length;return r+s*t.rate})))]})),yield{name:"早すぎた埋葬",actions:[{title:"発動",isMandatory:!1,playType:"CardActivation",spellSpeed:"Normal",executableCells:["Hand","SpellAndTrapZone"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],hasToTargetCards:!0,canPayCosts:t=>t.activator.lp>=800,canExecute:t=>{const e=t.activator.getMonsterZones();return t.activator.getEnableSummonList(t.activator,"SpecialSummon",["Effect"],t.action,t.activator.getGraveyard().cardEntities.filter(a=>a.kind==="Monster").filter(a=>a.canBeTargetOfEffect(t)).map(a=>({monster:a,posList:["Attack"],cells:e})),[],!1).length>0},payCosts:(t,e)=>_e(t,e,800),prepare:async t=>{const e=await le(t,t.activator.getGraveyard().cardEntities,["Attack"]);return e.chainBlockTags.push("PayLifePoint"),e},execute:async(t,e)=>t.action.entity.info.equipedBy?(await t.action.entity.ruleDestory(),!1):await ce(t,["Attack"])?(t.action.entity.onBeforeMove.append(async a=>{if(a.entity.face!=="FaceUp"||!a.entity.isOnFieldAsSpellTrapStrictly)return"RemoveMe";const n=a.entity.info.equipedBy;if(!n)return"RemoveMe";const[,,,,,r]=a.args;return n.isOnFieldStrictly&&n.face==="FaceUp"&&a.entity.isEffective&&r.union(["EffectDestroy","RuleDestroy"]).length&&(a.entity.controller.writeInfoLog(`${t.action.entity.toString()}が破壊されたため、装備対象モンスター${n.toString()}を破壊。`),m.tryMarkForDestory([n],t)),"RemoveMe"}),Ut(t,e,(a,n)=>{var r;return(r=n.info.effectTargets[t.action.seq])==null?void 0:r.includes(a)})):(await t.action.entity.ruleDestory(),!1),settle:async()=>!0},C]},yield{name:"幻惑の巻物",actions:[he(),C],continuousEffects:[]}}const Qt=Object.freeze(Object.defineProperty({__proto__:null,default:yn},Symbol.toStringTag,{value:"Module"}));function*mn(){yield*[{name:"伝説の剣",attr:void 0,monType:"Warrior",atk:200,def:200},{name:"秘術の書",attr:void 0,monType:"Spellcaster",atk:200,def:200},{name:"ポセイドンの力",attr:void 0,monType:"Aqua",atk:200,def:200},{name:"紫水晶",attr:void 0,monType:"Zombie",atk:200,def:200},{name:"猛獣の歯",attr:void 0,monType:"Beast",atk:200,def:200},{name:"機械改造工場",attr:void 0,monType:"Machine",atk:200,def:200},{name:"体温の上昇",attr:void 0,monType:"Reptile",atk:200,def:200},{name:"魔菌",attr:void 0,monType:"Plant",atk:200,def:200},{name:"闇・エネルギー",attr:void 0,monType:"Fiend",atk:200,def:200},{name:"レーザー砲機甲鎧",attr:void 0,monType:"Insect",atk:200,def:200},{name:"銀の弓矢",attr:void 0,monType:"Fairy",atk:200,def:200},{name:"電撃鞭",attr:void 0,monType:"Thunder",atk:200,def:200},{name:"ドラゴンの秘宝",attr:void 0,monType:"Dragon",atk:200,def:200},{name:"フォロー・ウィンド",attr:void 0,monType:"WingedBeast",atk:200,def:200},{name:"魔性の月",attr:void 0,monType:"BeastWarrior",atk:200,def:200},{name:"エルフの光",attr:"Light",monType:void 0,atk:400,def:-200},{name:"覚醒",attr:"Earth",monType:void 0,atk:400,def:-200},{name:"灼熱の槍",attr:"Fire",monType:void 0,atk:400,def:-200},{name:"突風の扇",attr:"Wind",monType:void 0,atk:400,def:-200},{name:"はがねの甲羅",attr:"Water",monType:void 0,atk:400,def:-200},{name:"闇の破神剣",attr:"Dark",monType:void 0,atk:400,def:-200},{name:"火器付機甲鎧",attr:void 0,monType:"Insect",atk:700,def:0},{name:"サラマンドラ",attr:"Fire",monType:void 0,atk:700,def:0},{name:"シャイン・キャッスル",attr:"Light",monType:void 0,atk:700,def:0}].map(t=>({name:t.name,actions:[he(e=>(!t.attr||e.attr.includes(t.attr))&&(!t.monType||e.types.includes(t.monType))),C],continuousEffects:[Te(t.name,"Spell",e=>e.info.equipedBy?[e.info.equipedBy]:[],e=>{const i=[];return t.atk!==0&&i.push(["attack",t.atk]),t.def!==0&&i.push(["defense",t.def]),i.map(([a,n])=>H.createContinuous("発動",r=>r.isSpawnedBy.isOnFieldStrictly&&r.isSpawnedBy.face==="FaceUp",e,(r,s)=>s.isOnFieldStrictly&&s.face==="FaceUp"&&(!t.monType||s.types.includes(t.monType))&&(!t.attr||s.attr.includes(t.attr)),a,"wip","Addition",(r,s,l)=>r.isEffective?l+n:l))})]}))}const Xt=Object.freeze(Object.defineProperty({__proto__:null,default:mn},Symbol.toStringTag,{value:"Module"}));function*vn(){yield{name:"チキンレース",actions:[ee,C,{title:"②効果発動",isMandatory:!1,playType:"IgnitionEffect",spellSpeed:"Normal",executableCells:["FieldSpellZone"],executablePeriods:["main1","main2"],executableDuelistTypes:Ee,isOnlyNTimesPerTurnIfFaceup:1,canPayCosts:t=>t.activator.lp>=1e3,getDests:()=>[],payCosts:(t,e)=>_e(t,e,1e3),prepare:async(t,e,i)=>{let a=[{seq:0,text:"●デッキから１枚ドローする。",tags:["Draw"]},{seq:1,text:"●このカードを破壊する。",tags:t.action.calcChainBlockTagsForDestroy(t.activator,[t.action.entity])},{seq:2,text:"●相手は1000LP回復する。",tags:[]}];t.activator.getDeckCell().cardEntities.length||(a=a.filter(r=>r.seq));const n=await t.activator.waitSelectText(a,"使用する効果を選択",i);if(n!==void 0)return{selectedEntities:[],chainBlockTags:n.tags,prepared:n.seq,nextChainBlockFilter:()=>!1}},execute:async t=>(t.prepared===0?await t.activator.draw(1,t.action.entity,t.activator):t.prepared===1?await m.tryDestroy([t.action.entity],t):t.prepared===2&&t.activator.getOpponentPlayer().heal(1e3,t.action.entity),!0),settle:async()=>!0}],continuousEffects:[fa("①ダメージ無効","Spell",t=>[t.controller,t.controller.getOpponentPlayer()].map(e=>e.entity),t=>[new qt("①ダメージ無効",()=>!0,!0,t,{},()=>!0,"zero_typeA",(e,i,a,n)=>e.isSpawnedBy.fieldCell.cellType!=="FieldSpellZone"?{}:n.lp>=n.getOpponentPlayer().lp?{}:(a.writeInfoLog(`${n.profile.name}はチキンレースの効果でダメージを受けない。`),{zero_typeA:!0}))])]}}const Kt=Object.freeze(Object.defineProperty({__proto__:null,default:vn},Symbol.toStringTag,{value:"Module"}));function*Sn(){yield*[{name:"草原",up:["Warrior","BeastWarrior"],down:[]},{name:"森",up:["Insect","Plant","Beast","BeastWarrior"],down:[]},{name:"山",up:["Dragon","WingedBeast","Thunder"],down:[]},{name:"荒野",up:["Dinosaur","Zombie","Rock"],down:[]},{name:"海",up:["Aqua","SeaSerpent","Fish"],down:["Machine","Pyro"]},{name:"闇",up:["Fiend","Spellcaster"],down:["Fairy"]}].map(t=>({name:t.name,actions:[ee,C],continuousEffects:[De("発動","Spell",e=>["attack","defense"].flatMap(i=>["up","down"].map(a=>H.createContinuous("発動",n=>n.isSpawnedBy.isOnFieldStrictly&&n.isSpawnedBy.face==="FaceUp",e,(n,r)=>r.isOnFieldStrictly&&r.face==="FaceUp"&&(r.status.monsterCategories??!1)&&t[a].union(r.types).length>0,i,"wip","Addition",(n,r,s)=>!n.isEffective||r.face==="FaceDown"?s:s+(a==="up"?200:-200)))))]})),yield*[{name:"バーニングブラッド",attr:"Fire"},{name:"ウォーターワールド",attr:"Water"},{name:"ガイアパワー",attr:"Earth"},{name:"シャインスパーク",attr:"Light"},{name:"ダークゾーン",attr:"Dark"},{name:"デザートストーム",attr:"Wind"}].map(t=>({name:t.name,actions:[ee,C],continuousEffects:[De("発動","Spell",e=>["attack","defense"].flatMap(i=>H.createContinuous("発動",a=>a.isSpawnedBy.isOnFieldStrictly&&a.isSpawnedBy.face==="FaceUp",e,(a,n)=>n.isOnFieldStrictly&&n.face==="FaceUp"&&n.attr.includes(t.attr),i,"wip","Addition",(a,n,r)=>!a.isEffective||n.face==="FaceDown"?r:r+(i==="attack"?500:-400))))]}))}const Jt=Object.freeze(Object.defineProperty({__proto__:null,default:Sn},Symbol.toStringTag,{value:"Module"})),Cn=async(t,e,i=!1)=>{if(!t.action.entity.lvl)return;if(t.action.entity.lvl<5)return{};const a=t.activator.getAvailableMonsterZones();let n=t.activator.getMonstersOnField().filter(c=>c.canBeReleased(t.activator,t.action.entity,["AdvanceSummonRelease"],t.action));const r=t.activator.getExtraMonsterZones(),s=t.action.entity.lvl<7?1:2;r.length>=s&&(n=n.filter(c=>c.fieldCell.cellType!=="ExtraMonsterZone"));const l=await t.activator.waitSelectEntities(n,s,c=>(i||c.length>0)&&(s<0||c.length===s)&&(a.length>0||c.some(d=>d.fieldCell.cellType==="ExtraMonsterZone")),"リリースするモンスターを選択",i)??[];return l.length?(await m.releaseManyForTheSameReason(l,["Cost","AdvanceSummonRelease","Rule"],t.action.entity,t.activator),{summonMaterialInfos:l.map(c=>({material:c,cell:c.fieldCell}))}):void 0},Tn=async t=>{var n;const e=["Rule","NormalSummon"];let i="NormalSummon";(n=t.costInfo.summonMaterialInfos)!=null&&n.length&&(i="AdvanceSummon",e.push("AdvanceSummon"));const a=t.dest?[t.dest]:t.activator.getAvailableMonsterZones();return te(t,i,e,["Attack","Set"],a)},te=async(t,e,i,a,n)=>{let r=t.dest?[t.dest]:n;return r||(r=t.activator.getMonsterZones(),t.action.entity.fieldCell.cellType==="ExtraDeck"&&r.push(...t.activator.duel.field.getCells("ExtraMonsterZone"))),await t.activator.summon(e,i,t.action,t.action.entity,a,r,t.costInfo.summonMaterialInfos??[],!1),{selectedEntities:[],chainBlockTags:[],prepared:void 0}},ie=async t=>{var e,i;return t.action.entity.info.isRebornable=!((e=t.action.entity.origin.monsterCategories)!=null&&e.includes("RegularSpecialSummonOnly")),t.action.entity.determine(),(i=t.costInfo.summonMaterialInfos)==null||i.map(a=>a.material).forEach(a=>a.onUsedAsMaterial(t,t.action.entity)),!0},P={title:"通常召喚",isMandatory:!1,playType:"NormalSummon",spellSpeed:"Normal",executableCells:["Hand"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],canPayCosts:t=>{if(!t.action.entity.lvl)return!1;if(t.action.entity.lvl<5)return t.activator.getEnableSummonList(t.activator,"NormalSummon",["Rule"],t.action,[{monster:t.action.entity,posList:["Attack","Set"],cells:t.activator.getMonsterZones()}],[],!1).length>0;const e=t.activator.getMonstersOnField().filter(n=>n.canBeReleased(t.activator,t.action.entity,["AdvanceSummonRelease"],t.action)),i=t.action.entity.lvl<7?1:2;return e.length<i?!1:e.getAllOnOffPattern().filter(n=>n.length===i).some(n=>t.activator.getEnableSummonList(t.activator,"AdvanceSummon",["Rule","NormalSummon"],t.action,[{monster:t.action.entity,posList:["Attack","Set"],cells:t.activator.getMonsterZones()}],n.map(r=>({material:r,cell:r.fieldCell})),!1).length)},meetsConditions:t=>t.activator.info.ruleNormalSummonCount<t.activator.info.maxRuleNormalSummonCount&&!!t.action.entity.lvl,getDests:t=>t.action.entity.lvl?t.action.entity.lvl>4?[]:t.activator.getEnableSummonList(t.activator,"NormalSummon",["Rule"],t.action,[{monster:t.action.entity,posList:["Attack","Set"],cells:t.activator.getMonsterZones()}],[],!1).flatMap(i=>i.cells).getDistinct():[],payCosts:Cn,prepare:Tn,execute:ie,settle:async()=>!0},J=(t,e,i,a)=>{const n=t.activator.getMonsterZones();return t.action.entity.fieldCell.cellType==="ExtraDeck"&&n.push(...t.activator.getAvailableExtraMonsterZones()),t.activator.getEnableSummonList(t.activator,"SpecialSummon",a,t.action,[{monster:t.action.entity,posList:e,cells:n}],i,!1).flatMap(s=>s.cells)},j=(...t)=>J(...t).length>0,T={title:"攻撃宣言",isMandatory:!1,playType:"Battle",spellSpeed:"Normal",executableCells:["MonsterZone","ExtraMonsterZone"],executablePeriods:["b1Battle","b2Battle"],executableDuelistTypes:["Controller"],hasToTargetCards:!0,getTargetableEntities:t=>t.action.entity.getAttackTargets(),canExecute:(t,e)=>!t.activator.isTurnPlayer||!t.action.entity.status.canAttack||t.action.entity.info.attackDeclareCount>0||t.action.entity.battlePosition!=="Attack"?!1:t.action.getTargetableEntities(t,e).length>0,getDests:(t,e)=>t.action.getTargetableEntities(t,e).filter(i=>i.isOnField).map(i=>i.fieldCell),prepare:async(t,e)=>{var n;if(t.action.entity.info.attackDeclareCount>0||t.action.entity.battlePosition!=="Attack")return;if((n=t.dest)!=null&&n.targetForAttack){const r=t.dest.entities.find(s=>s.entityType==="Duelist");return{selectedEntities:r?[r]:t.dest.cardEntities,chainBlockTags:[],prepared:void 0}}const i=t.action.getTargetableEntities(t,e);if(i.length===0)throw new v("攻撃対象の選択肢がない状態で実行された。",t);if(i.length===1)return{selectedEntities:i,chainBlockTags:[],prepared:void 0};if(t.activator.duelistType==="NPC"){let r=t.activator.selectAttackTargetForNPC(t.action.entity,t.action);return r||(t.activator.duel.log.warn("NPCの攻撃対象選択に失敗したため、ランダムに攻撃対象を選択。"),r=i.randomPick()),{selectedEntities:[r],chainBlockTags:[],prepared:void 0}}const a=await t.activator.waitSelectEntity(i,"攻撃対象を選択。",!0);if(a)return{selectedEntities:[a],chainBlockTags:[],prepared:void 0}},execute:async t=>(t.action.entity.field.duel.declareAnAttack(t.action.entity,t.selectedEntities[0]),!0),settle:async()=>!0},Yt=async t=>{if(!(t.action.entity.info.battlePotisionChangeCount>0||!t.activator.isTurnPlayer))return await t.action.entity.setBattlePosition(t.action.entity.battlePosition==="Attack"?"Defense":"Attack",["Rule"],t.action.entity,t.activator),t.action.entity.info.battlePotisionChangeCount++,{selectedEntities:[],chainBlockTags:[],prepared:void 0}},_={title:"反転召喚",isMandatory:!1,playType:"FlipSummon",spellSpeed:"Normal",executableCells:["MonsterZone","ExtraMonsterZone"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],canExecute:t=>t.action.entity.info.battlePotisionChangeCount===0&&t.action.entity.info.attackDeclareCount===0&&t.activator.isTurnPlayer&&t.action.entity.face==="FaceDown",prepare:Yt,execute:async t=>(t.action.entity.determine(),!0),settle:async()=>!0},E={title:"表示形式変更",isMandatory:!1,playType:"ChangeBattlePosition",spellSpeed:"Normal",executableCells:["MonsterZone","ExtraMonsterZone"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],canExecute:t=>t.action.entity.info.battlePotisionChangeCount===0&&t.action.entity.info.attackDeclareCount===0&&t.activator.isTurnPlayer&&t.action.entity.face==="FaceUp",prepare:Yt,execute:async t=>(t.action.entity.determine(),!0),settle:async()=>!0},se=async(t,e=["Attack","Defense"])=>{const i=t.activator.getMonsterZones();return t.action.entity.wasMovedAfter(t.isActivatedAt)?!1:(await t.activator.summon("SpecialSummon",["Effect"],t.action,t.action.entity,e,i,[],!1),!0)},ot=[T,E,_],En=[...ot,P],_n=(t,e,i,a,n,r,s,l,u,c,d)=>{const p={posList:u,cells:c},f={posList:[],cells:[]};return e!==s||s.kind!=="Monster"||!s.origin.monsterCategories?p:s.origin.monsterCategories.includes("NormalSummonOnly")?n.includes("NormalSummon")||n.includes("AdvanceSummon")?p:f:s.origin.monsterCategories.includes("SpecialSummon")?s.isInTrashCell&&!s.origin.monsterCategories.includes("RegularSpecialSummonOnly")?s.info.isRebornable||s.origin.monsterCategories.includes("FreeReborn")?p:f:n.includes("PendulumSummon")&&s.origin.monsterCategories.includes("FreeReborn")?f:n.union(Zt).length?p:s.origin.monsterCategories.includes("RegularSpecialSummonOnly")?d?p:f:p:p},je={},kn=t=>(je[t]||(je[t]={title:`戦闘破壊耐性(${t})`,isMandatory:!0,executableCells:["MonsterZone"],executablePeriods:["b1DDmgCalc","b2DDmgCalc"],executableDuelistTypes:["Controller"],isOnlyNTimesPerTurnIfFaceup:t,isApplicableTo:(e,i,a)=>a.includes(e.entity)?i!=="BattleDestroy"?[]:[e.entity]:[],substitute:async(e,i,a)=>a.includes(e.entity)?i!=="BattleDestroy"?[]:e.entity.isEffective?(e.entity.controller.writeInfoLog(`${e.entity.toString()}は１ターンに１度だけ戦闘では破壊されない。`),[e.entity]):[]:[]}),je[t]),lt=t=>t.activator.canRelease([t.action.entity])&&t.action.entity.canBeReleased(t.activator,t.action.entity,["ReleaseAsCost"],t.action),ct=async t=>(await t.action.entity.release(["Cost"],t.action.entity,t.activator),{release:[t.action.entity]}),It=t=>({title:"シンクロ召喚",isMandatory:!1,playType:"QuickEffect",spellSpeed:"Quick",executableCells:R,executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],isOnlyNTimesPerChain:1,meetsConditions:e=>!e.activator.isTurnPlayer,canExecute:e=>e.activator.getExtraDeck().cardEntities.filter(i=>{var a;return(a=i.status.monsterCategories)==null?void 0:a.includes("Syncro")}).flatMap(i=>i.actions).filter(i=>i.playType==="SpecialSummon").map(i=>({index:-1,chainNumber:void 0,action:i,activator:e.activator,targetChainBlock:void 0,isActivatedIn:i.entity.fieldCell,isActivatedAt:e.isActivatedAt,costInfo:{},state:"unloaded",dest:void 0,ignoreCost:!1})).some(i=>i.action.getEnableMaterialPatterns(i).some(a=>{const n=a.map(r=>r.material);return n.every(r=>r.controller===e.activator)&&n.every(r=>r.isOnFieldAsMonsterStrictly)&&n.includes(e.action.entity)})),prepare:q,execute:async e=>{if(e.activator!==e.action.entity.controller||e.activator.getMonstersOnField().filter(s=>s.lvl!==void 0).length<2)return!1;const i=e.activator.getExtraDeck().cardEntities.filter(s=>{var l;return(l=s.status.monsterCategories)==null?void 0:l.includes("Syncro")}).flatMap(s=>s.actions).filter(s=>s.playType==="SpecialSummon").map(s=>({index:-1,chainNumber:void 0,action:s,activator:e.activator,targetChainBlock:void 0,isActivatedIn:s.entity.fieldCell,isActivatedAt:e.isActivatedAt,costInfo:{},state:"unloaded",dest:void 0,ignoreCost:!1})).filter(s=>s.action.getEnableMaterialPatterns(s).some(l=>{const u=l.map(c=>c.material);return u.every(c=>c.controller===e.activator)&&u.every(c=>c.isOnFieldAsMonsterStrictly)&&u.includes(e.action.entity)})).map(s=>s.action.entity).getDistinct();if(!i.length)return!1;const a=await e.activator.waitSelectEntities(i,1,s=>s.length===1,"シンクロ召喚するモンスターを選択。",!1)??[];if(!a.length)throw new v("想定されない状態",e);const n=a[0].actions.find(s=>s.playType==="SpecialSummon");if(!n)throw new v("想定されない状態",e);const r=n.getClone(s=>{const l=s.map(u=>u.material);return l.every(u=>u.controller===e.activator)&&l.every(u=>u.isOnFieldAsMonsterStrictly)&&l.includes(e.action.entity)});return e.nextActionInfo={action:r,originSeq:r.seq},!0},settle:async()=>!0,...t}),wn=it("直接攻撃","Monster",t=>[t],t=>[new V("直接攻撃",()=>!0,!0,t,{},(e,i)=>e.isSpawnedBy===i,(e,i)=>({...i,canDirectAttack:!0}))]),Ue={title:"融合素材代用",appliableCellTypes:["MonsterZone","ExtraMonsterZone","Hand","Graveyard "],appliableDuelPeriodKeys:U,faceList:["FaceUp","FaceDown"],canStart:()=>!0,start:async t=>{const e=new V("融合素材代用",()=>!0,!0,t,{},()=>!0,(i,a)=>(i.isSpawnedBy.isEffective&&(a.fusionSubstitute=!0),a));return t.statusOperatorBundle.push(e),{targets:[t],seq:e.seq}},finish:async(t,e)=>{e.targets.forEach(i=>i.statusOperatorBundle.removeItem(e.seq))}};function*bn(){const t=[{name:"カルボナーラ戦士",materialInfos:[{type:"Name",cardName:"マグネッツ１号"},{type:"Name",cardName:"マグネッツ２号"}]},{name:"クリッチー",materialInfos:[{type:"Name",cardName:"クリッター"},{type:"Name",cardName:"黒き森のウィッチ"}]},{name:"スケルゴン",materialInfos:[{type:"Name",cardName:"メデューサの亡霊"},{type:"Name",cardName:"暗黒の竜王"}]},{name:"スチームジャイロイド",materialInfos:[{type:"Name",cardName:"ジャイロイド"},{type:"Name",cardName:"スチームロイド"}]},{name:"バラに棲む悪霊",materialInfos:[{type:"Name",cardName:"グレムリン"},{type:"Name",cardName:"スネーク・パーム"}]},{name:"バロックス",materialInfos:[{type:"Name",cardName:"キラーパンダ"},{type:"Name",cardName:"ガーゴイル"}]},{name:"フュージョニスト",materialInfos:[{type:"Name",cardName:"プチテンシ"},{type:"Name",cardName:"スリーピィ"}]},{name:"ブラキオレイドス",materialInfos:[{type:"Name",cardName:"二頭を持つキング・レックス"},{type:"Name",cardName:"屍を貪る竜"}]},{name:"プラグティカル",materialInfos:[{type:"Name",cardName:"トラコドン"},{type:"Name",cardName:"フレイム・ヴァイパー"}]},{name:"マブラス",materialInfos:[{type:"Name",cardName:"タイホーン"},{type:"Name",cardName:"邪炎の翼"}]},{name:"ミノケンタウロス",materialInfos:[{type:"Name",cardName:"ミノタウルス"},{type:"Name",cardName:"ケンタウロス"}]},{name:"暗黒火炎龍",materialInfos:[{type:"Name",cardName:"火炎草"},{type:"Name",cardName:"プチリュウ"}]},{name:"炎の騎士 キラー",materialInfos:[{type:"Name",cardName:"モンスター・エッグ"},{type:"Name",cardName:"スティング"}]},{name:"炎の剣士",materialInfos:[{type:"Name",cardName:"炎を操る者"},{type:"Name",cardName:"伝説の剣豪 ＭＡＳＡＫＩ"}]},{name:"音楽家の帝王",materialInfos:[{type:"Name",cardName:"黒き森のウィッチ"},{type:"Name",cardName:"ハイ・プリーステス"}]},{name:"金色の魔象",materialInfos:[{type:"Name",cardName:"メデューサの亡霊"},{type:"Name",cardName:"ドラゴン・ゾンビ"}]},{name:"紅陽鳥",materialInfos:[{type:"Name",cardName:"セイント・バード"},{type:"Name",cardName:"スカイ・ハンター"}]},{name:"轟きの大海蛇",materialInfos:[{type:"Name",cardName:"魔法のランプ"},{type:"Name",cardName:"ひょうすべ"}]},{name:"黒き人食い鮫",materialInfos:[{type:"Name",cardName:"シーカーメン"},{type:"Name",cardName:"キラー・ブロッブ"},{type:"Name",cardName:"海原の女戦士"}]},{name:"砂の魔女",materialInfos:[{type:"Name",cardName:"岩石の巨兵"},{type:"Name",cardName:"エンシェント・エルフ"}]},{name:"裁きの鷹",materialInfos:[{type:"Name",cardName:"冠を戴く蒼き翼"},{type:"Name",cardName:"コケ"}]},{name:"裁きを下す女帝",materialInfos:[{type:"Name",cardName:"女王の影武者"},{type:"Name",cardName:"響女"}]},{name:"朱雀",materialInfos:[{type:"Name",cardName:"赤き剣のライムンドス"},{type:"Name",cardName:"炎の魔神"}]},{name:"深海に潜むサメ",materialInfos:[{type:"Name",cardName:"神魚"},{type:"Name",cardName:"舌魚"}]},{name:"水陸両用バグロス",materialInfos:[{type:"Name",cardName:"陸戦型 バグロス"},{type:"Name",cardName:"海を守る戦士"}]},{name:"戦場の死装束",materialInfos:[{type:"Name",cardName:"音女"},{type:"Name",cardName:"斬首の美女"}]},{name:"魔装騎士ドラゴネス",materialInfos:[{type:"Name",cardName:"アーメイル"},{type:"Name",cardName:"一眼の盾竜"}]},{name:"魔導騎士ギルティア",materialInfos:[{type:"Name",cardName:"冥界の番人"},{type:"Name",cardName:"王座の守護者"}]},{name:"雷神の怒り",materialInfos:[{type:"Name",cardName:"エンゼル・イヤーズ"},{type:"Name",cardName:"メガ・サンダーボール"}]},{name:"カイザー・ドラゴン",materialInfos:[{type:"Name",cardName:"砦を守る翼竜"},{type:"Name",cardName:"フェアリー・ドラゴン"}]},{name:"スカルビショップ",materialInfos:[{type:"Name",cardName:"悪魔の知恵"},{type:"Name",cardName:"魔天老"}]},{name:"デビル・ボックス",materialInfos:[{type:"Name",cardName:"マーダーサーカス"},{type:"Name",cardName:"ドリーム・ピエロ"}]},{name:"ヒューマノイド・ドレイク",materialInfos:[{type:"Name",cardName:"ワームドレイク"},{type:"Name",cardName:"ヒューマノイド・スライム"}]},{name:"ブラック・デーモンズ・ドラゴン",materialInfos:[{type:"Name",cardName:"デーモンの召喚"},{type:"Name",cardName:"真紅眼の黒竜"}]},{name:"マスター・オブ・ＯＺ",materialInfos:[{type:"Name",cardName:"ビッグ・コアラ"},{type:"Name",cardName:"デス・カンガルー"}]},{name:"メテオ・ブラック・ドラゴン",materialInfos:[{type:"Name",cardName:"真紅眼の黒竜"},{type:"Name",cardName:"メテオ・ドラゴン"}]},{name:"召喚獣メガラニカ",materialInfos:[{type:"Name",cardName:"召喚師アレイスター"},{type:"Name",cardName:"地属性モンスター"}]},{name:"聖女ジャンヌ",materialInfos:[{type:"Name",cardName:"慈悲深き修道女"},{type:"Name",cardName:"堕天使マリー"}]},{name:"青眼の究極竜",materialInfos:[{type:"Name",cardName:"青眼の白龍"},{type:"Name",cardName:"青眼の白龍"},{type:"Name",cardName:"青眼の白龍"}]},{name:"千年竜",materialInfos:[{type:"Name",cardName:"時の魔術師"},{type:"Name",cardName:"ベビードラゴン"}]},{name:"双頭の雷龍",materialInfos:[{type:"Name",cardName:"サンダー・ドラゴン"},{type:"Name",cardName:"サンダー・ドラゴン"}]},{name:"迷宮の魔戦車",materialInfos:[{type:"Name",cardName:"ギガテック・ウルフ"},{type:"Name",cardName:"キャノン・ソルジャー"}]},{name:"竜騎士ガイア",materialInfos:[{type:"Name",cardName:"暗黒騎士ガイア"},{type:"Name",cardName:"カース・オブ・ドラゴン"}]},{name:"アクア・ドラゴン",materialInfos:[{type:"Name",cardName:"フェアリー・ドラゴン"},{type:"Name",cardName:"海原の女戦士"}]},{name:"アンデット・ウォーリアー",materialInfos:[{type:"Name",cardName:"ワイト"},{type:"Name",cardName:"格闘戦士アルティメーター"}]},{name:"カオス・ウィザード",materialInfos:[{type:"Name",cardName:"ホーリー・エルフ"},{type:"Name",cardName:"黒魔族のカーテン"}]},{name:"クワガー・ヘラクレス",materialInfos:[{type:"Name",cardName:"クワガタ・アルファ"},{type:"Name",cardName:"ヘラクレス・ビートル"}]},{name:"ソウル・ハンター",materialInfos:[{type:"Name",cardName:"ランプの魔人"},{type:"Name",cardName:"異次元からの侵略者"}]},{name:"デス・バード",materialInfos:[{type:"Name",cardName:"タクヒ"},{type:"Name",cardName:"髑髏の寺院"}]},{name:"フラワー・ウルフ",materialInfos:[{type:"Name",cardName:"シルバー・フォング"},{type:"Name",cardName:"魔界のイバラ"}]},{name:"フレイム・ゴースト",materialInfos:[{type:"Name",cardName:"ワイト"},{type:"Name",cardName:"マグマン"}]},{name:"マリン・ビースト",materialInfos:[{type:"Name",cardName:"水の魔導師"},{type:"Name",cardName:"ベヒゴン"}]},{name:"メカ・ザウルス",materialInfos:[{type:"Name",cardName:"ミスター・ボンバー"},{type:"Name",cardName:"二頭を持つキング・レックス"}]},{name:"メタル・ドラゴン",materialInfos:[{type:"Name",cardName:"鋼鉄の巨神像"},{type:"Name",cardName:"レッサー・ドラゴン"}]},{name:"レア・フィッシュ",materialInfos:[{type:"Name",cardName:"フュージョニスト"},{type:"Name",cardName:"恍惚の人魚"}]},{name:"無の畢竟 オールヴェイン",materialInfos:[{type:"Filter",filter:e=>{var i;return((i=e.status.monsterCategories)==null?void 0:i.includes("Normal"))??!1}},{type:"Filter",filter:e=>{var i;return((i=e.status.monsterCategories)==null?void 0:i.includes("Normal"))??!1}}]},{name:"テセウスの魔棲物",materialInfos:[{type:"Filter",filter:e=>{var i;return((i=e.status.monsterCategories)==null?void 0:i.includes("Tuner"))??!1}},{type:"Filter",filter:e=>{var i;return((i=e.status.monsterCategories)==null?void 0:i.includes("Tuner"))??!1}}]},{name:"ジェムナイト・ジルコニア",materialInfos:[{type:"Filter",filter:e=>{var i;return((i=e.status.nameTags)==null?void 0:i.includes("ジェムナイト"))??!1}},{type:"Filter",filter:e=>e.types.includes("Rock")??!1}]},{name:"メタルフォーゼ・アダマンテ",materialInfos:[{type:"Filter",filter:e=>{var i;return((i=e.status.nameTags)==null?void 0:i.includes("メタルフォーゼ"))??!1}},{type:"Filter",filter:e=>(e.atk??9999)<=2500}]},{name:"メタルフォーゼ・カーディナル",materialInfos:[{type:"Filter",filter:e=>{var i;return((i=e.status.nameTags)==null?void 0:i.includes("メタルフォーゼ"))??!1}},{type:"Filter",filter:e=>(e.atk??9999)<=3e3},{type:"Filter",filter:e=>(e.atk??9999)<=3e3}]}];for(const e of t)yield{name:e.name,actions:[T,E,_],fusionMaterialInfos:e.materialInfos}}const ei=Object.freeze(Object.defineProperty({__proto__:null,default:bn},Symbol.toStringTag,{value:"Module"})),Dn=(t,e,i,a)=>{if(!t.action.entity.origin.link||t.action.entity.origin.link<i.length)return;let n=i.map(s=>({material:s,cell:s.fieldCell,link:1}));if(t.action.entity.origin.link>i.length){if(i.every(u=>(u.origin.link??1)<2))return;const s=[n];i.filter(u=>(u.origin.link??1)>1).forEach(u=>{[...s].forEach(c=>{s.push([...c.filter(d=>d.material!==u),{material:u,cell:u.fieldCell,link:u.origin.link??1}])})});const l=s.find(u=>u.reduce((c,d)=>c+d.link,0)===t.action.entity.origin.link);if(!l)return;n=l}if(!a(i)||!t.activator.getEnableSummonList(t.activator,"LinkSummon",["Rule","SpecialSummon"],t.action,[{monster:t.action.entity,posList:["Attack"],cells:e}],n,!1).length)return;if(t.activator.getAvailableExtraMonsterZones().length)return n;const r=t.activator.duel.field.getCells("ExtraMonsterZone").map(s=>s.cardEntities[0]).filter(s=>s);if(r.filter(s=>s.controller===t.activator).length&&r.filter(s=>s.controller===t.activator).length===i.filter(s=>s.fieldCell.cellType==="ExtraMonsterZone").length||t.activator.getMonsterZones().flatMap(s=>s.linkArrowSources).some(s=>!i.includes(s))||t.activator.duel.field.canExtraLink(t.action.entity,n))return n};function*Pn(t,e=()=>!0){let i=[...t.activator.getMonstersOnField().filter(n=>n.battlePosition!=="Set"),...t.activator.getHandCell().entities.filter(n=>n.origin.kind==="Monster")];if(i.every(n=>!n.status.allowHandLink)&&(i=i.filter(n=>n.fieldCell.isPlayFieldCell)),i.length<1)return;const a=[...t.activator.getMonsterZones(),...t.activator.duel.field.getAvailableExtraMonsterZones()];yield*i.getAllOnOffPattern().filter(n=>n.some(r=>r.status.allowHandLink)||n.every(r=>r.isOnFieldAsMonsterStrictly)).map(n=>Dn(t,a,n,e)??[]).filter(n=>n.length)}const Mn=async(t,e,i)=>{var u;const a=t.action.getEnableMaterialPatterns(t).toArray(),n=a.map(c=>({infos:c,materialSeqList:c.map(d=>d.material.seq).sort()}));let r=a[0].map(c=>c.material);if(a.length>1){const c=a.flatMap(p=>p.map(f=>f.material)).getDistinct(),d=await t.activator.waitSelectEntities(c,void 0,p=>{const f=p.map(g=>g.seq).sort();return n.some(g=>f.length===g.materialSeqList.length&&f.every((y,b)=>y===g.materialSeqList[b]))},"リンク素材とするモンスターを選択",i);if(console.log(d),!d)return;r=d}const s=r.map(c=>c.seq).sort(),l=(u=n.find(c=>s.length===c.materialSeqList.length&&s.every((d,p)=>d===c.materialSeqList[p])))==null?void 0:u.infos;if(!l)throw new v("想定されない状態",t,r);return await m.sendManyToGraveyardForTheSameReason(r,["LinkMaterial","Cost","Rule","SpecialSummonMaterial"],t.action.entity,t.activator),{summonMaterialInfos:l}},ut=(t=()=>!0)=>({title:"リンク召喚",isMandatory:!1,playType:"SpecialSummon",spellSpeed:"Normal",executableCells:["ExtraDeck"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],getEnableMaterialPatterns:e=>Pn(e,t),canPayCosts:e=>e.action.getEnableMaterialPatterns(e).some(i=>i.length),canExecute:e=>!e.ignoreCost||e.activator.getAvailableExtraMonsterZones().length+e.activator.getAvailableMonsterZones().length>0,payCosts:Mn,prepare:e=>te(e,"LinkSummon",["Rule","SpecialSummon","LinkSummon"],["Attack"]),execute:ie,settle:async()=>!0});function*An(){yield*[{name:"ＬＡＮフォリンクス",validator:t=>t.length===2},{name:"トラフィックゴースト",validator:t=>t.length===3},{name:"天威の鬼神",validator:t=>t.length>1&&t.some(e=>{var i;return(i=e.status.monsterCategories)==null?void 0:i.includes("Link")})},{name:"天威の拳僧",validator:t=>t.every(e=>{var i,a;return((i=e.status.nameTags)==null?void 0:i.includes("天威"))&&!((a=e.status.monsterCategories)!=null&&a.includes("Link"))})},{name:"電影の騎士ガイアセイバー",validator:t=>t.length>1}].map(t=>({name:t.name,actions:[T,ut(t.validator)]}))}const ti=Object.freeze(Object.defineProperty({__proto__:null,default:An},Symbol.toStringTag,{value:"Module"}));function*xn(){yield*["サイバー・ドラゴン","六武衆のご隠居","アンノウン・シンクロン"].map(t=>({name:t,actions:[P,T,E,_,{title:"特殊召喚",isMandatory:!1,playType:"SpecialSummon",spellSpeed:"Normal",executableCells:["Hand"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],isOnlyNTimesPerDuel:t==="アンノウン・シンクロン"?1:void 0,canExecute:e=>{const i=e.action.entity.field.getMonstersOnFieldStrictly();return i.length>0&&i.every(a=>a.controller!==e.activator)&&j(e,S,[],["Rule"])},getDests:e=>J(e,S,[],["Rule"]),prepare:e=>te(e,"SpecialSummon",["SpecialSummon","Rule"],S),execute:ie,settle:async()=>!0}]})),yield{name:"ジャンク・フォアード",actions:[P,T,E,_,{title:"特殊召喚",isMandatory:!1,playType:"SpecialSummon",spellSpeed:"Normal",executableCells:["Hand"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],canExecute:t=>t.activator.getMonstersOnField().length===0&&j(t,S,[],["Rule"]),getDests:t=>J(t,S,[],["Rule"]),prepare:t=>te(t,"SpecialSummon",["SpecialSummon","Rule"],S),execute:ie,settle:async()=>!0}]},yield{name:"Ｄ－ＨＥＲＯ ディアボリックガイ",actions:[P,T,E,_,{title:"①リクルート",isMandatory:!1,playType:"IgnitionEffect",spellSpeed:"Normal",executableCells:["Graveyard"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],priorityForNPC:10,canPayCosts:ke,canExecute:t=>{const e=t.activator.getDeckCell().cardEntities.find(n=>n.nm==="Ｄ－ＨＥＲＯ ディアボリックガイ");if(!e)return!1;const i=t.activator.getMonsterZones();return t.activator.getEnableSummonList(t.activator,"SpecialSummon",["Effect"],t.action,[{monster:e,posList:S,cells:i}],[],!1).length>0},payCosts:Re,prepare:async()=>({selectedEntities:[],chainBlockTags:["SpecialSummonFromDeck"],prepared:void 0}),execute:async t=>{const e=t.activator.getDeckCell().cardEntities.find(i=>i.nm==="Ｄ－ＨＥＲＯ ディアボリックガイ");return e?un(t,[e]):!1},settle:async()=>!0}]},yield{name:"ゾンビキャリア",actions:[P,T,E,_,{title:"①自己再生",isMandatory:!1,playType:"IgnitionEffect",spellSpeed:"Normal",executableCells:["Graveyard"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],canPayCosts:t=>t.activator.getHandCell().cardEntities.length>0,getDests:t=>J(t,S,[],["Effect"]),canExecute:t=>j(t,S,[],["Effect"]),payCosts:async(t,e,i)=>{const a=t.activator.getHandCell().cardEntities,n=await t.activator.waitSelectEntity(a,"デッキトップに戻すカードを一枚選択。",i);if(!n)throw new F(t);return await n.returnToDeck("Top",["Cost"],t.action.entity,t.activator),{returnToDeck:[n]}},prepare:async()=>({selectedEntities:[],chainBlockTags:["SpecialSummonFromGraveyard"],prepared:void 0}),execute:async t=>await se(t)?(t.action.entity.statusOperatorBundle.push(new V("除外予定",()=>!0,!1,t.action.entity,t.action,(e,i)=>i.isOnFieldAsMonsterStrictly&&i.face==="FaceUp",(e,i)=>({...i,willBeBanished:!0}))),!0):!1,settle:async()=>!0}]},yield{name:"グローアップ・バルブ",actions:[P,T,E,_,{title:"①自己再生",isMandatory:!1,playType:"IgnitionEffect",spellSpeed:"Normal",executableCells:["Graveyard"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],isOnlyNTimesPerDuel:1,canPayCosts:t=>t.activator.getDeckCell().cardEntities.length>0,getDests:t=>J(t,S,[],["Effect"]),canExecute:t=>j(t,S,[],["Effect"]),payCosts:async t=>{const e=t.activator.getDeckCell().cardEntities[0];return await t.activator.getDeckCell().cardEntities[0].sendToGraveyard(["Cost"],t.action.entity,t.activator),{sendToGraveyard:[e]}},prepare:async()=>({selectedEntities:[],chainBlockTags:["SpecialSummonFromGraveyard"],prepared:void 0}),execute:t=>se(t),settle:async()=>!0}]},yield{name:"終末の騎士",actions:[P,T,E,_,{title:"①墓地送り",isMandatory:!1,playType:"TriggerEffect",spellSpeed:"Normal",executableCells:["MonsterZone"],executablePeriods:[...D,...N],executableDuelistTypes:["Controller"],meetsConditions:t=>t.action.entity.hasBeenSummonedNow(["NormalSummon","SpecialSummon","FlipSummon"]),canExecute:t=>t.activator.getDeckCell().cardEntities.some(e=>e.attr.includes("Dark")),prepare:async t=>{const e=["SendToGraveyardFromDeck"];return t.action.entity.moveLog.latestRecord.movedAs.includes("NormalSummon")?e.push("IfNormarlSummonSucceed"):t.action.entity.moveLog.latestRecord.movedAs.includes("SpecialSummon")&&e.push("IfSpecialSummonSucceed"),{selectedEntities:[],chainBlockTags:e,prepared:void 0}},execute:async t=>{const e=t.activator.getDeckCell().cardEntities.filter(a=>a.attr.includes("Dark"));if(e.length===0)return!1;const i=await t.activator.waitSelectEntity(e,"墓地に送るモンスターを選択",!1);if(!i)throw new F(t);return await i.sendToGraveyard(["Effect"],t.action.entity,t.activator),t.activator.getDeckCell().shuffle(),!0},settle:async()=>!0}]},yield{name:"マスマティシャン",actions:[P,T,E,_,{title:"①墓地送り",isMandatory:!1,playType:"TriggerEffect",spellSpeed:"Normal",executableCells:["MonsterZone"],executablePeriods:[...D,...N],executableDuelistTypes:["Controller"],meetsConditions:t=>t.action.entity.hasBeenSummonedNow(["NormalSummon"]),canExecute:t=>t.activator.getDeckCell().cardEntities.some(e=>e.lvl&&e.lvl<5),prepare:async()=>({selectedEntities:[],chainBlockTags:["IfNormarlSummonSucceed","SendToGraveyardFromDeck"],prepared:void 0}),execute:async t=>{const e=t.activator.getDeckCell().cardEntities.filter(a=>a.lvl&&a.lvl<5);if(e.length===0)return!1;const i=await t.activator.waitSelectEntity(e,"墓地に送るモンスターを選択",!1);if(!i)throw new F(t);return await i.sendToGraveyard(["Effect"],t.action.entity,t.activator),t.activator.getDeckCell().shuffle(),!0},settle:async()=>!0},{title:"②ドロー",isMandatory:!1,playType:"TriggerEffect",spellSpeed:"Normal",executableCells:["Graveyard"],executablePeriods:[...D,...N],executableDuelistTypes:["Controller"],meetsConditions:t=>t.action.entity.moveLog.latestRecord.movedAs.includes("BattleDestroy")&&t.action.entity.wasMovedAtPreviousChain,canExecute:t=>t.activator.getDeckCell().cardEntities.length>0&&t.activator.canDraw,prepare:async()=>({selectedEntities:[],chainBlockTags:["Draw"],prepared:void 0}),execute:async t=>(await t.activator.draw(1,t.action.entity,t.activator),!0),settle:async()=>!0}]},yield{name:"ライトロード・ビースト ウォルフ",actions:[T,E,_,{title:"①自己再生",isMandatory:!0,playType:"TriggerEffect",spellSpeed:"Normal",executableCells:["Graveyard"],executablePeriods:[...D,...N],executableDuelistTypes:["Controller"],meetsConditions:t=>t.action.entity.wasMovedFrom.cellType==="Deck"&&t.action.entity.wasMovedAtPreviousChain,getDests:t=>J(t,S,[],["Effect"]),canExecute:t=>j(t,S,[],["Effect"]),prepare:async()=>({selectedEntities:[],chainBlockTags:["SpecialSummonFromGraveyard"],prepared:void 0}),execute:t=>se(t),settle:async()=>!0}]},yield{name:"伝説の白石",actions:[T,E,_,P,{title:"①サーチ",isMandatory:!0,playType:"TriggerEffect",spellSpeed:"Normal",executableCells:["Graveyard"],executablePeriods:U,executableDuelistTypes:["Controller"],meetsConditions:t=>t.action.entity.wasMovedAtPreviousChain&&t.action.entity.wasMovedFrom.cellType!=="Banished",canExecute:t=>t.activator.getDeckCell().cardEntities.some(e=>e.nm==="青眼の白龍")&&t.activator.canAddToHandFromDeck,prepare:async()=>({selectedEntities:[],chainBlockTags:["SearchFromDeck"],prepared:void 0}),execute:async t=>{const e=t.activator.getDeckCell().cardEntities.find(i=>i.nm==="青眼の白龍");return e?(await e.addToHand(["Effect"],t.action.entity,t.activator),t.activator.getDeckCell().shuffle(),!0):!1},settle:async()=>!0}]};for(const t of[{name:"灰流うらら",chainBlockTags:["Draw","SearchFromDeck","SendToGraveyardFromDeck","SpecialSummonFromDeck"]},{name:"屋敷わらし",chainBlockTags:["BanishFromGraveyard","SpecialSummonFromGraveyard","AddToHandFromGraveyard"]}])yield{name:t.name,actions:[T,E,_,P,{title:"①無効化",isMandatory:!1,playType:"QuickEffect",spellSpeed:"Quick",executableCells:["Hand"],executablePeriods:D,executableDuelistTypes:["Controller"],isOnlyNTimesPerTurn:1,negatePreviousBlock:!0,canPayCosts:e=>e.activator.canDiscard([e.action.entity]),canExecute:e=>(e.targetChainBlock&&e.targetChainBlock.chainBlockTags.union(t.chainBlockTags).length>0)??!1,payCosts:async e=>(await e.action.entity.discard(["Cost"],e.action.entity,e.activator),{sendToGraveyard:[e.action.entity]}),prepare:async()=>({selectedEntities:[],chainBlockTags:["NegateCardEffect"],prepared:void 0}),execute:async(e,i)=>{const a=i[e.index-1];return a.isNegatedEffectBy=e.action,!0},settle:async()=>!0}]};for(const t of["翻弄するエルフの剣士","ロードランナー","氷結界の修験者"])yield{name:t,actions:[T,E,_,P],continuousEffects:[Lt("①戦闘破壊耐性","Monster",e=>[e],e=>[new me("①戦闘破壊耐性",()=>!0,!0,e,{},()=>!0,["BattleDestroy"],(i,a)=>!e.isEffective||(a.atk??0)<1900?!0:(e.duel.log.info(`${e.toString()}は攻撃力1900以上のモンスターとの先頭では破壊されない。`,e.controller),!1))])]}}const ii=Object.freeze(Object.defineProperty({__proto__:null,default:xn},Symbol.toStringTag,{value:"Module"}));function*Fn(){yield*["ラージマウス","レインボー・フラワー","レッグル","女王の影武者","人造人間７号"].map(t=>({name:t,actions:[T,E,_,P],continuousEffects:[wn]}))}const ai=Object.freeze(Object.defineProperty({__proto__:null,default:Fn},Symbol.toStringTag,{value:"Module"}));function*Nn(){yield*[{name:"キラー・ポテト",filter:t=>t.attr.includes("Dark")&&(t.atk??9999)<=1500,qtyList:[1],posList:["Attack"],destoryTypes:["EffectDestroy"],executableCells:["Graveyard"]},{name:"キラー・トマト",filter:t=>t.attr.includes("Dark")&&(t.atk??9999)<=1500,qtyList:[1],posList:["Attack"],destoryTypes:["BattleDestroy"],executableCells:["Graveyard"]},{name:"巨大ネズミ",filter:t=>t.attr.includes("Earth")&&(t.atk??9999)<=1500,qtyList:[1],posList:["Attack"],destoryTypes:["BattleDestroy"],executableCells:["Graveyard"]},{name:"グリズリーマザー",filter:t=>t.attr.includes("Water")&&(t.atk??9999)<=1500,qtyList:[1],posList:["Attack"],destoryTypes:["BattleDestroy"],executableCells:["Graveyard"]},{name:"シャインエンジェル",filter:t=>t.attr.includes("Light")&&(t.atk??9999)<=1500,qtyList:[1],posList:["Attack"],destoryTypes:["BattleDestroy"],executableCells:["Graveyard"]},{name:"ドラゴンフライ",filter:t=>t.attr.includes("Wind")&&(t.atk??9999)<=1500,qtyList:[1],posList:["Attack"],destoryTypes:["BattleDestroy"],executableCells:["Graveyard"]},{name:"ＵＦＯタートル",filter:t=>t.attr.includes("Fire")&&(t.atk??9999)<=1500,qtyList:[1],posList:["Attack"],destoryTypes:["BattleDestroy"],executableCells:["Graveyard"]},{name:"荒野の女戦士",filter:t=>t.attr.includes("Earth")&&t.types.includes("Warrior")&&(t.atk??9999)<=1500,qtyList:[1],posList:["Attack"],destoryTypes:["BattleDestroy"],executableCells:["Graveyard"]},{name:"リトル・トルーパー",filter:t=>t.types.includes("Warrior")&&(t.lvl??9999)<3,qtyList:[1],posList:["Set"],destoryTypes:["BattleDestroy"],executableCells:["Graveyard","Banished"]},{name:"破面竜",filter:t=>t.types.includes("Warrior")&&(t.def??9999)<=1500,qtyList:[1],posList:["Attack","Defense"],destoryTypes:["BattleDestroy"],executableCells:["Graveyard"]},{name:"共鳴虫",filter:t=>t.types.includes("Insect")&&(t.atk??9999)<=1500,qtyList:[1],posList:["Attack","Defense"],destoryTypes:["BattleDestroy"],executableCells:["Graveyard"]},{name:"ピラミッド・タートル",filter:t=>t.types.includes("Zombie")&&(t.def??9999)<=2e3,qtyList:[1],posList:["Attack","Defense"],destoryTypes:["BattleDestroy"],executableCells:["Graveyard"]},{name:"ユーフォロイド",filter:t=>t.types.includes("Machine")&&(t.atk??9999)<=1500,qtyList:[1],posList:["Attack"],destoryTypes:["BattleDestroy"],executableCells:["Graveyard"]},{name:"ヘル・セキュリティ",filter:t=>t.types.includes("Fiend")&&(t.lvl??9999)===1,qtyList:[1],posList:["Attack","Defense"],destoryTypes:["BattleDestroy"],executableCells:["Graveyard"]},{name:"ガスタ・イグル",filter:t=>(t.status.nameTags??[]).includes("ガスタ")&&(t.status.monsterCategories??[]).includes("Tuner"),qtyList:[1],posList:["Attack","Defense"],destoryTypes:["BattleDestroy"],executableCells:["Graveyard"]},{name:"幻影の魔術士",filter:t=>(t.status.nameTags??[]).includes("ＨＥＲＯ")&&(t.atk??9999)<=1e3,qtyList:[1],posList:["Defense"],destoryTypes:["BattleDestroy"],executableCells:["Graveyard"]},{name:"ジェネクス・サーチャー",filter:t=>(t.status.nameTags??[]).includes("ジェネクス")&&(t.atk??9999)<=1500,qtyList:[1],posList:["Attack"],destoryTypes:["BattleDestroy"],executableCells:["Graveyard"]},{name:"紫炎の足軽",filter:t=>(t.status.nameTags??[]).includes("六武衆")&&(t.lvl??12)<=3,qtyList:[1],posList:["Attack","Defense"],destoryTypes:["BattleDestroy"],executableCells:["Graveyard"]},{name:"スレイブ・エイプ",filter:t=>(t.status.nameTags??[]).includes("剣闘獣")&&(t.lvl??12)<=4,qtyList:[1],posList:["Attack","Defense"],destoryTypes:["BattleDestroy"],executableCells:["Graveyard"]},{name:"ゼンマイハニー",filter:t=>(t.status.nameTags??[]).includes("ゼンマイ")&&(t.lvl??12)<=4,qtyList:[1],posList:["Attack","Defense"],destoryTypes:["BattleDestroy"],executableCells:["Graveyard"]},{name:"ＸＸ－セイバー エマーズブレイド",filter:t=>(t.status.nameTags??[]).includes("Ｘ－セイバー")&&(t.lvl??12)<=4,qtyList:[1],posList:["Attack","Defense"],destoryTypes:["BattleDestroy"],executableCells:["Graveyard"]},{name:"軍隊竜",filter:t=>t.nm==="軍隊竜",qtyList:[1],posList:["Attack","Defense"],destoryTypes:["BattleDestroy"],executableCells:["Graveyard"]},{name:"アサルト・ガンドッグ",filter:t=>t.nm==="アサルト・ガンドッグ",qtyList:[1,2,3,4,5],posList:["Attack","Defense"],destoryTypes:["BattleDestroy"],executableCells:["Graveyard"]},{name:"ハイエナ",filter:t=>t.nm==="ハイエナ",qtyList:[1,2,3,4,5],posList:["Attack","Defense"],destoryTypes:["BattleDestroy"],executableCells:["Graveyard"]}].map(t=>({name:t.name,actions:[{title:"①リクルート",isMandatory:!1,playType:"TriggerEffect",spellSpeed:"Normal",executableCells:t.executableCells,executablePeriods:t.destoryTypes.includes("EffectDestroy")?[...D,...N]:["b1DEnd","b2DEnd"],executableDuelistTypes:["Controller"],meetsConditions:e=>e.action.entity.wasMovedAtPreviousChain&&e.action.entity.moveLog.latestRecord.movedAs.union(t.destoryTypes).length>0,canExecute:e=>{const i=e.activator.getMonsterZones();return e.activator.getEnableSummonList(e.activator,"SpecialSummon",["Effect"],e.action,e.activator.getDeckCell().cardEntities.filter(t.filter).filter(n=>n.kind==="Monster").filter(n=>n.canBeTargetOfEffect(e)).map(n=>({monster:n,posList:t.posList,cells:i})),[],!1).length>0},prepare:async()=>({selectedEntities:[],chainBlockTags:["SpecialSummonFromDeck"],prepared:void 0}),execute:async e=>{const i=e.activator.getDeckCell().cardEntities.filter(t.filter),a=e.activator.getMonsterZones();return!!e.activator.summonMany(e.activator,"SpecialSummon",["Effect"],e.action,i.map(r=>({monster:r,posList:t.posList,cells:a})),[],!1,t.qtyList.length>1?void 0:t.qtyList[0],r=>t.qtyList.includes(r.length),!1)},settle:async()=>!0},T,E,_,P]}))}const ni=Object.freeze(Object.defineProperty({__proto__:null,default:Nn},Symbol.toStringTag,{value:"Module"}));function*Bn(){yield{name:"おろかな埋葬",actions:[{title:"発動",isMandatory:!1,playType:"CardActivation",spellSpeed:"Normal",executableCells:["Hand","SpellAndTrapZone"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],priorityForNPC:40,canExecute:e=>e.activator.getDeckCell().cardEntities.some(i=>i.kind==="Monster"),prepare:async()=>({selectedEntities:[],chainBlockTags:["SendToGraveyardFromDeck"],prepared:void 0}),execute:async e=>{const i=e.activator.getDeckCell().cardEntities.filter(n=>n.kind==="Monster");if(i.length===0)return!1;const a=await e.activator.waitSelectEntity(i,"墓地に送るモンスターを選択",!1);if(!a)throw new F(e);return await a.sendToGraveyard(["Effect"],e.action.entity,e.activator),e.activator.getDeckCell().shuffle(),!0},settle:async()=>!0},C]},yield{name:"おろかな副葬",actions:[{title:"発動",isMandatory:!1,playType:"CardActivation",spellSpeed:"Normal",executableCells:["Hand","SpellAndTrapZone"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],isOnlyNTimesPerTurn:1,priorityForNPC:40,canExecute:e=>e.activator.getDeckCell().cardEntities.some(i=>i.kind!=="Monster"),prepare:async()=>({selectedEntities:[],chainBlockTags:["SendToGraveyardFromDeck"],prepared:void 0}),execute:async e=>{const i=e.activator.getDeckCell().cardEntities.filter(n=>n.kind!=="Monster");if(i.length===0)return!1;const a=await e.activator.waitSelectEntity(i,"墓地に送る魔法罠を選択",!1);if(!a)throw new F(e);return await a.sendToGraveyard(["Effect"],e.action.entity,e.activator),e.activator.getDeckCell().shuffle(),!0},settle:async()=>!0},C]},yield{name:"死者蘇生",actions:[{title:"発動",isMandatory:!1,playType:"CardActivation",spellSpeed:"Normal",executableCells:["Hand","SpellAndTrapZone"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],hasToTargetCards:!0,canExecute:e=>{const i=e.activator.getMonsterZones();return e.activator.getEnableSummonList(e.activator,"SpecialSummon",["Effect"],e.action,e.activator.duel.field.getCells("Graveyard").flatMap(n=>n.cardEntities).filter(n=>n.kind==="Monster").filter(n=>n.canBeTargetOfEffect(e)).map(n=>({monster:n,posList:S,cells:i})),[],!1).length>0},prepare:e=>le(e,e.activator.duel.field.getCells("Graveyard").flatMap(i=>i.cardEntities).filter(i=>i.kind==="Monster").filter(i=>i.canBeTargetOfEffect(e))),execute:async e=>ce(e),settle:async()=>!0},C]};for(const e of[{name:"大嵐",cellTypes:ye,isOnlyEnemies:!1},{name:"ハーピィの羽根帚",cellTypes:ye,isOnlyEnemies:!0},{name:"ブラック・ホール",cellTypes:R,isOnlyEnemies:!1},{name:"サンダー・ボルト",cellTypes:R,isOnlyEnemies:!0}])yield{name:e.name,actions:[{title:"発動",isMandatory:!1,playType:"CardActivation",spellSpeed:"Normal",executableCells:["Hand","SpellAndTrapZone"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],canExecute:i=>{let a=i.action.entity.field.getCells(...e.cellTypes).flatMap(n=>n.cardEntities).filter(n=>n!==i.action.entity);return e.isOnlyEnemies&&(a=a.filter(n=>n.controller!==i.activator)),a.length>0},prepare:async i=>{let a=i.action.entity.field.getCells(...e.cellTypes).flatMap(n=>n.cardEntities).filter(n=>n!==i.action.entity);return e.isOnlyEnemies&&(a=a.filter(n=>n.controller!==i.activator)),{selectedEntities:[],chainBlockTags:i.action.calcChainBlockTagsForDestroy(i.activator,a),prepared:void 0}},execute:async i=>{let a=i.action.entity.field.getCells(...e.cellTypes).flatMap(n=>n.cardEntities).filter(n=>n!==i.action.entity);return e.isOnlyEnemies&&(a=a.filter(n=>n.controller!==i.activator)),await m.tryDestroy(a,i),!0},settle:async()=>!0},C]};yield{name:"ハリケーン",actions:[{title:"発動",isMandatory:!1,playType:"CardActivation",spellSpeed:"Normal",executableCells:["Hand","SpellAndTrapZone"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],canExecute:e=>e.action.entity.field.getCells("SpellAndTrapZone","FieldSpellZone").flatMap(i=>i.cardEntities).some(i=>i!==e.action.entity),prepare:async()=>({selectedEntities:[],chainBlockTags:["BounceToHand"],prepared:void 0}),execute:async(e,i)=>{const a=i.map(r=>r.action).filter(r=>r.playType==="CardActivation").map(r=>r.entity).filter(r=>r.isOnFieldStrictly).filter(r=>r.face==="FaceUp").filter(r=>!r.isLikeContinuousSpell),n=e.action.entity.field.getCells("SpellAndTrapZone","FieldSpellZone").flatMap(r=>r.cardEntities).filter(r=>!a.includes(r));return await m.returnManyToHandForTheSameReason(n,["Effect"],e.action.entity,e.activator),!0},settle:async()=>!0},C]};const t=e=>e.activator.duel.field.getWaitingRoomCell().cardEntities.find(i=>i.parent===e.action.entity)??M.createTokenEntity(e.activator,e.action.entity,{name:"セキュリティトークン",actions:ot,staticInfo:{name:"セキュリティトークン",kind:"Monster",monsterCategories:["Normal","Token"],level:4,attack:2e3,defense:2e3,attributes:["Light"],types:["Cyberse"],wikiEncodedName:"%A5%BB%A5%AD%A5%E5%A5%EA%A5%C6%A5%A3%A5%C8%A1%BC%A5%AF%A5%F3"}});yield{name:"ワンタイム・パスコード",actions:[{title:"発動",isMandatory:!1,playType:"CardActivation",spellSpeed:"Normal",executableCells:["Hand","SpellAndTrapZone"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],isOnlyNTimesPerTurn:1,canExecute:e=>{const i=t(e),a=e.activator.getMonsterZones();return e.activator.getEnableSummonList(e.activator,"SpecialSummon",["Effect"],e.action,[{monster:i,posList:["Defense"],cells:a}],[],!1).length>0},prepare:async()=>({selectedEntities:[],chainBlockTags:["SpecialSummon"],prepared:void 0}),execute:async e=>{const i=t(e),a=e.activator.getMonsterZones();return!!await e.activator.summon("SpecialSummon",["Effect"],e.action,i,["Defense"],a,[],!1)},settle:async()=>!0},C]},yield{name:"光の援軍",actions:[{title:"発動",isMandatory:!1,playType:"CardActivation",spellSpeed:"Normal",executableCells:["Hand","SpellAndTrapZone"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],priorityForNPC:40,canPayCosts:e=>e.activator.getDeckCell().cardEntities.length>3,canExecute:e=>e.activator.getDeckCell().cardEntities.filter(i=>i.kind==="Monster").filter(i=>(i.lvl??13)<5).some(i=>i.status.nameTags&&i.status.nameTags.includes("ライトロード")),payCosts:async e=>{const i=e.activator.getDeckCell().cardEntities.slice(0,3);return await m.sendManyToGraveyardForTheSameReason(i,["Cost"],e.action.entity,e.activator),{sendToGraveyard:i}},prepare:async()=>({selectedEntities:[],chainBlockTags:["SearchFromDeck"],prepared:void 0}),execute:async e=>{const i=e.activator.getDeckCell().cardEntities.filter(n=>n.kind==="Monster").filter(n=>(n.lvl??13)<5).filter(n=>n.status.nameTags&&n.status.nameTags.includes("ライトロード"));if(i.length===0)return!1;const a=await e.activator.waitSelectEntity(i,"手札に加えるモンスターを選択",!1);if(!a)throw new F(e);return await a.addToHand(["Effect"],e.action.entity,e.activator),!0},settle:async()=>!0},C]},yield{name:"ワン・フォー・ワン",actions:[{title:"発動",isMandatory:!1,playType:"CardActivation",spellSpeed:"Normal",executableCells:["Hand","SpellAndTrapZone"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],priorityForNPC:40,canPayCosts:e=>{if(e.activator.getDeckCell().cardEntities.every(i=>(i.lvl??12)>1)){if(e.activator.getHandCell().cardEntities.every(i=>(i.lvl??12)>1)||e.activator.getHandCell().cardEntities.filter(i=>i.kind==="Monster").length<2)return!1}else if(e.activator.getHandCell().cardEntities.filter(i=>i.kind==="Monster").length===0)return!1;return!0},canExecute:e=>{let i=[...e.activator.getDeckCell().cardEntities.filter(s=>(s.lvl??12)===1),...e.activator.getHandCell().cardEntities.filter(s=>(s.lvl??12)===1)];const a=e.activator.getHandCell().cardEntities;(a.length<2||!e.ignoreCost)&&(i=i.filter(s=>!a.includes(s)));const n=e.activator.getMonsterZones();return e.activator.getEnableSummonList(e.activator,"SpecialSummon",["Effect"],e.action,i.map(s=>({monster:s,posList:S,cells:n})),[],!1).length>0},payCosts:async(e,i,a)=>{const n=[...e.activator.getDeckCell().cardEntities.filter(c=>(c.lvl??12)===1),...e.activator.getHandCell().cardEntities.filter(c=>(c.lvl??12)===1)],r=e.activator.getMonsterZones(),s=e.activator.getEnableSummonList(e.activator,"SpecialSummon",["Effect"],e.action,n.map(c=>({monster:c,posList:S,cells:r})),[],!1);let l=e.activator.getHandCell().cardEntities.filter(c=>c.kind==="Monster");s.length===1&&(l=l.filter(c=>!s.map(d=>d.monster).includes(c)));const u=await e.activator.waitSelectEntity(l,"墓地へ送るモンスターを選択",a);if(!u)throw new F(e);return await u.sendToGraveyard(["Cost"],e.action.entity,e.activator),{sendToGraveyard:[u]}},prepare:async()=>({selectedEntities:[],chainBlockTags:["SpecialSummonFromDeck"],prepared:void 0}),execute:async e=>{const i=[...e.activator.getDeckCell().cardEntities.filter(r=>r.lvl===1),...e.activator.getHandCell().cardEntities.filter(r=>r.lvl===1)],a=e.activator.getMonsterZones();return!!await e.activator.summonOne(e.activator,"SpecialSummon",["Effect"],e.action,i.map(r=>({monster:r,posList:S,cells:a})),[],!1,!1)},settle:async()=>!0},C]},yield{name:"封印の黄金櫃",actions:[{title:"発動",isMandatory:!1,playType:"CardActivation",spellSpeed:"Normal",executableCells:["Hand","SpellAndTrapZone"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],canExecute:e=>e.activator.getDeckCell().cardEntities.some(i=>e.activator.canTryBanish(i,"BanishAsEffect",e.action)),prepare:async()=>({selectedEntities:[],chainBlockTags:["BanishFromDeck"],prepared:void 0}),execute:async e=>{const i=e.activator.getDeckCell().cardEntities.filter(r=>e.activator.canTryBanish(r,"BanishAsEffect",e.action)),a=await e.activator.waitSelectEntity(i,"除外するカードを選択。",!1);if(!a)throw new F(e);return(await m.tryBanish("BanishAsEffect",[a],e)).forEach(r=>r.counterHolder.removeAll("GoldSarcophagus")),!0},settle:async()=>!0},dn("回収カウント進行",["stanby"],e=>{e.activator.isTurnPlayer&&e.action.entity.field.getCells("Banished").flatMap(i=>i.cardEntities).filter(i=>i.moveLog.latestRecord.movedBy===e.action.entity).filter(i=>i.moveLog.latestRecord.actionOwner===e.activator).forEach(i=>{i.counterHolder.add("GoldSarcophagus",1,e.action.entity);const a=i.counterHolder.getQty("GoldSarcophagus",e.action.entity);a<3&&e.activator.duel.log.info(`${i.toString()}のターンカウント：${a-1}⇒${a}`)})}),{title:"回収",isMandatory:!0,playType:"LingeringEffect",spellSpeed:"Normal",executableCells:I,executablePeriods:["stanby"],executableDuelistTypes:Ee,canExecute:e=>e.activator.isTurnPlayer&&e.action.entity.field.getCells("Banished").flatMap(i=>i.cardEntities).filter(i=>i.moveLog.latestRecord.movedBy===e.action.entity).filter(i=>i.moveLog.latestRecord.actionOwner===e.activator).some(i=>i.counterHolder.getQty("GoldSarcophagus")===2),prepare:q,execute:async e=>{const i=e.action.entity.field.getCells("Banished").flatMap(n=>n.cardEntities).filter(n=>n.moveLog.latestRecord.movedBy===e.action.entity).filter(n=>n.moveLog.latestRecord.actionOwner===e.activator).filter(n=>n.counterHolder.getQty("GoldSarcophagus")===2);if(!i.length)throw new v("想定されない状態",e);let a=i[0];if(i.length>1){const n=await e.activator.waitSelectEntity(i,"回収するカードを選択。",!1);if(!n)throw new F(e);a=n}return await a.addToHand(["Effect"],e.action.entity,e.activator),!0},settle:async()=>!0},C]},yield{name:"魔の試着部屋",actions:[{title:"発動",isMandatory:!1,playType:"CardActivation",spellSpeed:"Normal",executableCells:["Hand","SpellAndTrapZone"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],canPayCosts:e=>e.activator.lp>=800,canExecute:e=>e.activator.getDeckCell().cardEntities.length>0&&e.activator.getEnableSummonList(e.activator,"SpecialSummon",["Effect"],e.action,e.activator.getDeckCell().cardEntities.filter(i=>i.kind==="Monster").filter(i=>{var a;return(a=i.status.monsterCategories)==null?void 0:a.includes("Normal")}).filter(i=>(i.lvl??12)<4).map(i=>({monster:i,posList:S,cells:e.activator.getMonsterZones()})),[],!1).length>0,payCosts:(e,i)=>_e(e,i,800),prepare:async()=>({selectedEntities:[],chainBlockTags:["SpecialSummonFromDeck"],prepared:void 0}),execute:async e=>{if(e.activator.getDeckCell().cardEntities.length<4)return!1;const i=await m.excavateManyFromDeck(e.activator,4,["Effect"],e.action.entity,e.activator),a=i.filter(n=>n.kind==="Monster").filter(n=>{var r;return(r=n.status.monsterCategories)==null?void 0:r.includes("Normal")}).filter(n=>(n.lvl??12)<4);if(a.length){const n=e.activator.getMonsterZones(),r=a.length>n.length?n.length:a.length;await e.activator.summonMany(e.activator,"SpecialSummon",["Effect"],e.action,a.map(s=>({monster:s,cells:n,posList:S})),[],!1,r,s=>s.length===r,!1)}return await m.sendManyToGraveyardForTheSameReason(a.filter(n=>!n.isOnFieldAsMonsterStrictly),["Effect"],e.action.entity,e.activator),console.log(i.filter(n=>n.fieldCell.cellType==="Deck")),await m.returnManyToDeckForTheSameReason("Random",i.filter(n=>n.fieldCell.cellType==="Deck"),["Effect"],e.action.entity,e.activator),!0},settle:async()=>!0},C]}}const ri=Object.freeze(Object.defineProperty({__proto__:null,default:Bn},Symbol.toStringTag,{value:"Module"}));function*On(){yield{name:"強欲な壺",actions:[{title:"発動",isMandatory:!1,playType:"CardActivation",spellSpeed:"Normal",executableCells:["Hand","SpellAndTrapZone"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],priorityForNPC:20,canExecute:t=>t.activator.getDeckCell().cardEntities.length>1&&t.activator.canDraw&&t.activator.canAddToHandFromDeck,prepare:async()=>({selectedEntities:[],chainBlockTags:["Draw"],prepared:void 0}),execute:async t=>(await t.activator.draw(2,t.action.entity,t.activator),!0),settle:async()=>!0},C]},yield{name:"貪欲な壺",actions:[{title:"発動",isMandatory:!1,playType:"CardActivation",spellSpeed:"Normal",executableCells:["Hand","SpellAndTrapZone"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],priorityForNPC:30,canExecute:t=>t.activator.getGraveyard().cardEntities.filter(e=>e.kind==="Monster").filter(e=>e.canBeTargetOfEffect(t)).length>4&&t.activator.canDraw&&t.activator.canAddToHandFromDeck,prepare:async t=>{const e=await t.activator.waitSelectEntities(t.activator.getGraveyard().cardEntities.filter(i=>i.kind==="Monster").filter(i=>i.canBeTargetOfEffect(t)),5,i=>i.length===5,"デッキに戻すモンスターを選択。",!1);if(e)return{selectedEntities:e,chainBlockTags:["Draw","ReturnToDeckFromGraveyard"],prepared:void 0}},execute:async t=>t.selectedEntities.some(e=>e.wasMovedAtCurrentChain)?!1:(await m.returnManyToDeckForTheSameReason("Random",t.selectedEntities,["Effect"],t.action.entity,t.activator),await t.activator.draw(2,t.action.entity,t.activator),!0),settle:async()=>!0},C]},yield{name:"天使の施し",actions:[{title:"発動",isMandatory:!1,playType:"CardActivation",spellSpeed:"Normal",executableCells:["Hand","SpellAndTrapZone"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],priorityForNPC:30,canExecute:t=>t.activator.getDeckCell().cardEntities.length>2&&t.activator.canDraw&&t.activator.canAddToHandFromDeck&&t.activator.status.canDiscardAsEffect,prepare:async()=>({selectedEntities:[],chainBlockTags:["Draw","DiscordAsEffect"],prepared:void 0}),execute:async t=>(await t.activator.draw(3,t.action.entity,t.activator),await t.activator.discard(2,"Effect",()=>!0,t.action.entity,t.activator),!0),settle:async()=>!0},C]},yield{name:"成金ゴブリン",actions:[{title:"発動",isMandatory:!1,playType:"CardActivation",spellSpeed:"Normal",executableCells:["Hand","SpellAndTrapZone"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],priorityForNPC:20,canExecute:t=>t.activator.getDeckCell().cardEntities.length>0&&t.activator.canDraw&&t.activator.canAddToHandFromDeck,prepare:async()=>({selectedEntities:[],chainBlockTags:["Draw"],prepared:void 0}),execute:async t=>(await t.activator.draw(1,t.action.entity,t.activator),t.action.entity.field.duel.clock.incrementProcSeq(),t.activator.getOpponentPlayer().heal(1e3,t.action.entity),!0),settle:async()=>!0},C]},yield{name:"手札抹殺",actions:[{title:"発動",isMandatory:!1,playType:"CardActivation",spellSpeed:"Normal",executableCells:["Hand","SpellAndTrapZone"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],canExecute:t=>t.activator.getDeckCell().cardEntities.length>=t.activator.getHandCell().cardEntities.filter(e=>e.seq!==t.action.entity.seq).length&&t.activator.canDraw&&t.activator.canAddToHandFromDeck&&t.activator.getOpponentPlayer().canDraw&&t.activator.getOpponentPlayer().canAddToHandFromDeck&&t.action.entity.field.getAllCells().filter(e=>e.cellType==="Hand").flatMap(e=>e.cardEntities).some(e=>e.seq!==t.action.entity.seq),prepare:async()=>({selectedEntities:[],chainBlockTags:["Draw","DiscordAsEffect"],prepared:void 0}),execute:async t=>{const e=t.activator.getHandCell().cardEntities.length,i=t.activator.getOpponentPlayer().getHandCell().cardEntities.length;return await m.sendManyToGraveyardForTheSameReason(t.action.entity.field.getCells("Hand").flatMap(a=>a.cardEntities),["Effect","Discard"],t.action.entity,t.activator),t.activator.duel.clock.incrementProcSeq(),await m.drawAtSameTime(t.activator,t.action.entity,e,i),!0},settle:async()=>!0},C]},yield{name:"一時休戦",actions:[{title:"発動",isMandatory:!1,playType:"CardActivation",spellSpeed:"Normal",executableCells:["Hand","SpellAndTrapZone"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],canExecute:t=>t.activator.getDeckCell().cardEntities.length>0&&t.activator.canDraw&&t.activator.getOpponentPlayer().getDeckCell().cardEntities.length>0&&t.activator.getOpponentPlayer().canDraw,prepare:async()=>({selectedEntities:[],chainBlockTags:["Draw"],prepared:void 0}),execute:async t=>(await m.drawAtSameTime(t.activator,t.action.entity,1,1),[t.activator,t.activator.getOpponentPlayer()].forEach(e=>e.entity.damageFilterBundle.push(new qt("ダメージ無効",i=>i.effectOwner.duel.clock.turn-i.isSpawnedAt.turn<2,!1,t.action.entity,t.action,()=>!0,"zero_typeA",(i,a,n,r)=>(n.writeInfoLog(`${r.profile.name}は${i.isSpawnedBy}の効果でダメージを受けない。`),{zero_typeA:!0})))),!0),settle:async()=>!0},C]},yield{name:"打ち出の小槌",actions:[{title:"発動",isMandatory:!1,playType:"CardActivation",spellSpeed:"Normal",executableCells:["Hand","SpellAndTrapZone"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],canExecute:t=>t.activator.canDraw,prepare:async()=>({selectedEntities:[],chainBlockTags:["Draw"],prepared:void 0}),execute:async t=>{const e=t.activator.getHandCell().cardEntities;if(!e.length)return!1;const i=await t.activator.waitSelectEntities(e,void 0,a=>a.length>0,"デッキに戻すカードを選択。",!1);if(!i)throw new F(t);return await m.returnManyToDeckForTheSameReason("Random",i,["Effect"],t.action.entity,t.activator),t.activator.duel.clock.incrementTotalProcSeq(),await t.activator.draw(i.length,t.action.entity,t.activator),!0},settle:async()=>!0},C]}}const si=Object.freeze(Object.defineProperty({__proto__:null,default:On},Symbol.toStringTag,{value:"Module"}));function*Ln(){yield*[{name:"増援",filter:t=>t.origin.kind==="Monster"&&t.types.includes("Warrior")&&(t.origin.level??5)<5},{name:"化石調査",filter:t=>t.origin.kind==="Monster"&&t.types.includes("Dinosaur")&&(t.origin.level??6)<6},{name:"Ｅ－エマージェンシーコール",filter:t=>t.origin.kind==="Monster"&&(t.origin.nameTags??[]).includes("Ｅ・ＨＥＲＯ")},{name:"召集の聖刻印",filter:t=>t.origin.kind==="Monster"&&(t.origin.nameTags??[]).includes("聖刻")},{name:"召喚師のスキル",filter:t=>t.origin.kind==="Monster"&&(t.origin.monsterCategories??[]).includes("Normal")&&(t.origin.level??4)>4},{name:"トゥーンのもくじ",filter:t=>(t.origin.nameTags??[]).includes("トゥーン")},{name:"融合賢者",filter:t=>t.origin.name==="融合"},{name:"虹の架け橋",filter:t=>t.origin.kind!=="Monster"&&(t.origin.nameTags??[]).includes("宝玉")},{name:"紫炎の狼煙",filter:t=>t.origin.kind==="Monster"&&(t.origin.nameTags??[]).includes("六武衆")&&(t.origin.level??4)<4},{name:"テラ・フォーミング",filter:t=>t.origin.kind==="Spell"&&t.origin.spellCategory==="Field"},{name:"コール・リゾネーター",filter:t=>t.origin.kind==="Monster"&&(t.origin.nameTags??[]).includes("リゾネーター")}].map(t=>({name:t.name,actions:[{title:"発動",isMandatory:!1,playType:"CardActivation",spellSpeed:"Normal",executableCells:["Hand","SpellAndTrapZone"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],priorityForNPC:40,canExecute:e=>e.activator.getDeckCell().cardEntities.some(t.filter)&&e.activator.canAddToHandFromDeck,prepare:async()=>({selectedEntities:[],chainBlockTags:["SearchFromDeck"],prepared:void 0}),execute:async e=>{const i=e.activator.getDeckCell().cardEntities.filter(t.filter);if(!i.length)return!1;const a=await e.activator.waitSelectEntity(i,"手札に加えるカードを選択",!1);return a?(await a.addToHand(["Effect"],e.action.entity,e.activator),!0):!1},settle:async()=>!0},C]})),yield*[{name:"戦士の生還",filter:t=>t.kind==="Monster"&&t.types.includes("Warrior"),qty:1},{name:"ダーク・バースト",filter:t=>t.kind==="Monster"&&t.attr.includes("Dark")&&(t.atk??9999)<=1500,qty:1},{name:"悪夢再び",filter:t=>t.kind==="Monster"&&t.attr.includes("Dark")&&(t.def??9999)===0,qty:2},{name:"サルベージ",filter:t=>t.kind==="Monster"&&t.attr.includes("Water")&&(t.atk??9999)<=1500,qty:2},{name:"バッテリーリサイクル",filter:t=>t.kind==="Monster"&&t.types.includes("Thunder")&&(t.atk??9999)<=1500,qty:2},{name:"闇の量産工場",filter:t=>t.kind==="Monster"&&(t.status.monsterCategories??[]).includes("Normal"),qty:2}].map(t=>({name:t.name,actions:[{title:"発動",isMandatory:!1,playType:"CardActivation",spellSpeed:"Normal",executableCells:["Hand","SpellAndTrapZone"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],hasToTargetCards:!0,priorityForNPC:40,canExecute:e=>e.activator.getGraveyard().cardEntities.filter(t.filter).length>=t.qty,prepare:async()=>({selectedEntities:[],chainBlockTags:["AddToHandFromGraveyard"],prepared:void 0}),execute:async e=>{const i=e.activator.getGraveyard().cardEntities.filter(t.filter);if(i.length===0)return!1;const a=await e.activator.waitSelectEntities(i,t.qty,n=>n.length===t.qty,"手札に加えるカードを選択",!1);for(const n of a??[])await n.addToHand(["Effect"],e.action.entity,e.activator);return!0},settle:async()=>!0},C]})),yield*[{name:"トレード・イン",filter:t=>t.kind==="Monster"&&(t.lvl??0)===8},{name:"調和の宝札",filter:t=>t.kind==="Monster"&&(t.origin.monsterCategories??[]).includes("Tuner")&&t.types.includes("Dragon")&&(t.atk??9999)<=1e3},{name:"デステニー・ドロー",filter:t=>t.kind==="Monster"&&(t.origin.nameTags??[]).includes("Ｄ－ＨＥＲＯ")}].map(t=>({name:t.name,actions:[{title:"発動",isMandatory:!1,playType:"CardActivation",spellSpeed:"Normal",executableCells:["Hand","SpellAndTrapZone"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],priorityForNPC:40,canPayCosts:(...e)=>rt(...e,t.filter),canExecute:e=>e.activator.getDeckCell().cardEntities.length>1,payCosts:async(...e)=>st(...e,t.filter),prepare:async()=>({selectedEntities:[],chainBlockTags:["Draw"],prepared:void 0}),execute:async e=>(await e.activator.draw(2,e.action.entity,e.activator),!0),settle:async()=>!0},C]})),yield*[{name:"火の粉",calcHeal:()=>[0,-200]},{name:"雷鳴",calcHeal:()=>[0,-300]},{name:"ファイヤー・ボール",calcHeal:()=>[0,-500]},{name:"火あぶりの刑",calcHeal:()=>[0,-600]},{name:"昼夜の大火事",calcHeal:()=>[0,-800]},{name:"火炎地獄",calcHeal:()=>[-500,-1e3]},{name:"盗人ゴブリン",calcHeal:()=>[500,-500]},{name:"ブルー・ポーション",calcHeal:()=>[400,0]},{name:"レッド・ポーション",calcHeal:()=>[500,0]},{name:"ゴブリンの秘薬",calcHeal:()=>[600,0]},{name:"天使の生き血",calcHeal:()=>[800,0]},{name:"治療の神 ディアン・ケト",calcHeal:()=>[1e3,0]},{name:"恵みの雨",calcHeal:()=>[1e3,1e3]}].map(t=>({name:t.name,actions:[{title:"発動",isMandatory:!1,playType:"CardActivation",spellSpeed:"Normal",executableCells:["Hand","SpellAndTrapZone"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],prepare:async()=>{const[e,i]=t.calcHeal(),a=[];return e<0&&a.push("DamageToSelf"),i<0&&a.push("DamageToOpponent"),{selectedEntities:[],chainBlockTags:a,prepared:void 0}},execute:async e=>{const[i,a]=t.calcHeal();return a>0?e.activator.getOpponentPlayer().heal(a,e.action.entity):a<0&&e.activator.getOpponentPlayer().effectDamage(Math.abs(a),e),i>0?e.activator.heal(i,e.action.entity):i<0&&e.activator.effectDamage(Math.abs(i),e),!0},settle:async()=>!0},C]}))}const oi=Object.freeze(Object.defineProperty({__proto__:null,default:Ln},Symbol.toStringTag,{value:"Module"}));function*qn(){yield{name:"強欲な瓶",actions:[C,{title:"発動",isMandatory:!1,playType:"CardActivation",spellSpeed:"Quick",executableCells:["SpellAndTrapZone"],executablePeriods:D,executableDuelistTypes:["Controller"],canExecute:t=>t.activator.getDeckCell().cardEntities.length>1&&t.activator.canDraw&&t.activator.canAddToHandFromDeck,prepare:async()=>({selectedEntities:[],chainBlockTags:["Draw"],prepared:void 0}),execute:async t=>(await t.activator.draw(1,t.action.entity,t.activator),!0),settle:async()=>!0}]},yield{name:"戦線復帰",actions:[{title:"発動",isMandatory:!1,playType:"CardActivation",spellSpeed:"Quick",executableCells:["SpellAndTrapZone"],executablePeriods:D,executableDuelistTypes:["Controller"],hasToTargetCards:!0,canExecute:t=>{const e=t.activator.getMonsterZones();return t.activator.getEnableSummonList(t.activator,"SpecialSummon",["Effect"],t.action,t.activator.getGraveyard().cardEntities.filter(a=>a.kind==="Monster").filter(a=>a.canBeTargetOfEffect(t)).map(a=>({monster:a,posList:["Defense"],cells:e})),[],!1).length>0},prepare:t=>le(t,t.activator.getGraveyard().cardEntities.filter(e=>e.kind==="Monster").filter(e=>e.canBeTargetOfEffect(t)),["Defense"]),execute:async t=>ce(t,["Defense"]),settle:async()=>!0},C]},yield{name:"サンダー・ブレイク",actions:[{title:"発動",isMandatory:!1,playType:"CardActivation",spellSpeed:"Quick",executableCells:["SpellAndTrapZone"],executablePeriods:D,executableDuelistTypes:["Controller"],canPayCosts:rt,payCosts:st,...X(t=>t.action.entity.field.getCardsOnFieldStrictly().filter(e=>e.canBeTargetOfEffect(t)),{message:"対象とするカードを選択。",destoryTargets:!0}),execute:async t=>t.selectedEntities.every(e=>!e.isOnField)?!1:(await m.tryDestroy(t.selectedEntities,t),!0),settle:async()=>!0},C]}}const li=Object.freeze(Object.defineProperty({__proto__:null,default:qn},Symbol.toStringTag,{value:"Module"}));function*Rn(){for(const t of["炸裂装甲","次元幽閉"])yield{name:t,actions:[C,{title:"発動",playType:"CardActivation",spellSpeed:"Quick",isMandatory:!1,executableCells:["SpellAndTrapZone"],executablePeriods:["b1Battle","b2Battle"],executableDuelistTypes:["Controller"],hasToTargetCards:!0,isNoticedForcibly:!0,canExecute:e=>{if(!e.activator.duel.clock.isUponAttackDeclaration()||e.activator.isTurnPlayer)return!1;const i=e.activator.duel.attackingMonster;if(!i)throw new v("想定されない状態",e,i);return!(!i.canBeTargetOfEffect(e)||t==="次元幽閉"&&!e.activator.canTryBanish(i,"BanishAsEffect",e.action))},prepare:async e=>{const i=e.activator.duel.attackingMonster;if(!i)throw new v("想定されない状態",e,i);const a=t==="炸裂装甲"?e.action.calcChainBlockTagsForDestroy(e.activator,[i]):["BanishFromField"];return{selectedEntities:[i],chainBlockTags:a,prepared:void 0}},execute:async e=>(t==="炸裂装甲"?await m.tryDestroy(e.selectedEntities,e):await m.tryBanish("BanishAsEffect",e.selectedEntities,e),!0),settle:async()=>!0}]}}const ci=Object.freeze(Object.defineProperty({__proto__:null,default:Rn},Symbol.toStringTag,{value:"Module"}));function*Hn(){yield{name:"ご隠居の猛毒薬",actions:[C,{title:"発動",isMandatory:!1,playType:"CardActivation",spellSpeed:"Quick",executableCells:["Hand","SpellAndTrapZone"],executablePeriods:D,executableDuelistTypes:["Controller"],prepare:async(t,e,i)=>{const a=[{seq:0,text:"●自分は１２００ＬＰ回復する。",tags:[]},{seq:1,text:"●相手に８００ダメージを与える。",tags:["DamageToOpponent"]}],n=await t.activator.waitSelectText(a,"使用する効果を選択",i);if(n!==void 0)return{selectedEntities:[],chainBlockTags:n.tags,prepared:n.seq}},execute:async t=>t.prepared===1?(t.activator.getOpponentPlayer().effectDamage(800,t),!0):(t.activator.heal(1200,t.action.entity),!0),settle:async()=>!0}]},yield{name:"月の書",actions:[{title:"発動",isMandatory:!1,playType:"CardActivation",spellSpeed:"Quick",executableCells:["Hand","SpellAndTrapZone"],executablePeriods:D,executableDuelistTypes:["Controller"],...X(t=>t.action.entity.field.getMonstersOnFieldStrictly().filter(e=>e.canBeTargetOfEffect(t)).filter(e=>e.canBeSet).filter(e=>e.face==="FaceUp"),{message:"対象とするモンスターを選択。"}),execute:async t=>{const e=t.selectedEntities[0];return!e.isOnFieldAsMonsterStrictly||e.battlePosition==="Set"?!1:e.canBeEffected(t.activator,t.action.entity,t.action)?(await e.setBattlePosition("Set",["Effect"],t.action.entity,t.activator),!0):(t.activator.duel.log.info(`${e.toString()}は${t.action.entity.toString()}の効果を受けない。`),!1)},settle:async()=>!0},C]},yield{name:"突進",actions:[{title:"発動",isMandatory:!1,playType:"CardActivation",spellSpeed:"Quick",executableCells:["Hand","SpellAndTrapZone"],executablePeriods:[...D,...N],executableDuelistTypes:["Controller"],...X(t=>t.action.entity.field.getMonstersOnFieldStrictly().filter(e=>e.face==="FaceUp").filter(e=>e.canBeTargetOfEffect(t)),{message:"対象とするモンスターを選択。"}),execute:async t=>{const e=t.selectedEntities[0];return!e.isOnFieldAsMonsterStrictly||e.battlePosition==="Set"?!1:e.canBeEffected(t.activator,t.action.entity,t.action)?(e.numericOprsBundle.push(H.createLingeringAddition("攻撃力上昇",i=>i.effectOwner.duel.clock.isSameTurn(i.isSpawnedAt),t.action.entity,t.action,"attack",(i,a,n)=>n+700)),!0):(t.activator.duel.log.info(`${e.toString()}は${t.action.entity.toString()}の効果を受けない。`),!1)},settle:async()=>!0},C]},yield{name:"手札断殺",actions:[{title:"発動",isMandatory:!1,playType:"CardActivation",spellSpeed:"Quick",executableCells:["Hand","SpellAndTrapZone"],executablePeriods:[...D,...N],executableDuelistTypes:["Controller"],canExecute:t=>{for(const e of[t.activator,t.activator.getOpponentPlayer()])if(!e.canDraw||e.getHandCell().cardEntities.filter(i=>i.canBeSentToGraveyard(t.activator,t.action.entity,"SendToGraveyardAsEffect",t.action)).filter(i=>i!==t.action.entity).length<2||e.getDeckCell().cardEntities.length<2)return!1;return!0},prepare:async()=>(console.log("手札断殺"),{selectedEntities:[],chainBlockTags:["Draw"],prepared:void 0}),execute:async t=>{if(t.activator.getHandCell().cardEntities.length<2||t.activator.getOpponentPlayer().getHandCell().cardEntities.length<2)return!1;let e=0;for(const i of[t.activator,t.activator.getOpponentPlayer()]){const a=await i.waitSelectEntities(i.getHandCell().cardEntities,2,r=>r.length===2,"墓地に送るカードを２枚選択。",!1);if(!a)throw new F(t,i);const n=await m.sendManyToGraveyardForTheSameReason(a,["Effect"],t.action.entity,t.activator);e+=n.length}return e?(t.activator.duel.clock.incrementTotalProcSeq(),await m.drawAtSameTime(t.activator,t.action.entity,2,2),!0):!1},settle:async()=>!0},C]},yield{name:"リロード",actions:[{title:"発動",isMandatory:!1,playType:"CardActivation",spellSpeed:"Quick",executableCells:["Hand","SpellAndTrapZone"],executablePeriods:[...D,...N],executableDuelistTypes:["Controller"],hasToTargetCards:!0,canExecute:t=>t.activator.canDraw,prepare:async()=>({selectedEntities:[],chainBlockTags:["Draw"],prepared:void 0}),execute:async t=>{const e=t.activator.getHandCell().cardEntities;return e.length?(await m.returnManyToDeckForTheSameReason("Random",e,["Effect"],t.action.entity,t.activator),t.activator.duel.clock.incrementTotalProcSeq(),await t.activator.draw(e.length,t.action.entity,t.activator),!0):!1},settle:async()=>!0},C]}}const ui=Object.freeze(Object.defineProperty({__proto__:null,default:Hn},Symbol.toStringTag,{value:"Module"})),Zn=(t,e,i,a,n,r,s)=>{if(!t.lvl||n.some(d=>!d.lvl))return;const l=n.map(d=>d.lvl??0).reduce((d,p)=>d+p,0),u=Me(...n.map(d=>d.lvl??0));if(l<t.lvl||s==="Equal"&&l!==t.lvl||s==="OrMore"&&l-u>=t.lvl||!r(n))return;const c=[...n.map(d=>({material:d,cell:d.fieldCell}))];if(e.activator.getEnableSummonList(e.activator,"RitualSummon",["Effect","SpecialSummon"],e.action,[{monster:e.action.entity,posList:i,cells:a}],c,!1).length)return c};function*di(t,...e){const[i,a,n,r,s]=e,l=t.activator.getCells(...i).flatMap(p=>p.cardEntities).filter(p=>{var f;return(f=p.status.monsterCategories)==null?void 0:f.includes("Ritual")}).filter(a);if(!l.length)return;const u=t.activator.getCells(...n).flatMap(p=>p.cardEntities).filter(p=>p.lvl).filter(p=>p.canBeReleased(t.activator,t.action.entity,["RitualMaterial","ReleaseAsEffect"],t.action));if(!u.length)return;const c=t.activator.getMonsterZones(),d=["Attack","Defense"];for(const p of l)for(const f of u.filter(g=>g!==p).getAllOnOffPattern()){const g=Zn(p,t,d,c,f,r,s);g&&(yield{monster:p,materialInfos:g})}}const $n=async(t,...e)=>{var d,p;const i=di(t,...e).toArray(),a=i.map(f=>f.monster).getDistinct(),n=await t.activator.waitSelectEntity(a,"儀式召喚するモンスターを選択。");if(!n)return!1;const r=i.filter(f=>f.monster===n).map(f=>f.materialInfos),s=r.map(f=>({infos:f,materialSeqList:f.map(g=>g.material.seq).sort()}));let l=r[0].map(f=>f.material);if(r.length>1){const f=r.flatMap(g=>g.map(y=>y.material)).getDistinct();l=await t.activator.waitSelectEntities(f,void 0,g=>{const y=g.map(b=>b.seq).sort();return s.some(b=>y.length===b.materialSeqList.length&&y.every((h,k)=>h===b.materialSeqList[k]))},"リリースするモンスターを選択",!1)??l}const u=l.map(f=>f.seq).sort(),c=(d=s.find(f=>u.length===f.materialSeqList.length&&u.every((g,y)=>g===f.materialSeqList[y])))==null?void 0:d.infos;if(!c)throw new v("想定されない状態",t,l);return await m.releaseManyForTheSameReason(l,["RitualMaterial","Effect","SpecialSummonMaterial"],t.action.entity,t.activator),await t.activator.summon("RitualSummon",["Effect","SpecialSummon"],t.action,n,S,t.activator.getMonsterZones(),c,!1),n.info.isRebornable=!((p=n.origin.monsterCategories)!=null&&p.includes("RegularSpecialSummonOnly")),c.map(f=>f.material).forEach(f=>f.onUsedAsMaterial(t,t.action.entity)),!0},Gn=(t,e,i,a,n)=>({canExecute:r=>di(r,t,e,i,a,n).some(s=>s.materialInfos.length),prepare:async()=>{const r=[];return t.includes("Hand")&&r.push("SpecialSummonFromHand"),t.includes("Graveyard")&&r.push("SpecialSummonFromGraveyard"),t.includes("ExtraDeck")&&r.push("SpecialSummonFromExtraDeck"),t.includes("Banished")&&r.push("SpecialSummonFromBanished"),t.includes("Deck")&&r.push("SpecialSummonFromDeck"),{selectedEntities:[],chainBlockTags:r,prepared:void 0}},execute:r=>$n(r,t,e,i,a,n),settle:async()=>!0});function*jn(){for(const t of[{spellName:"カオスの儀式",monsterName:"カオス・ソルジャー"},{spellName:"仮面魔獣の儀式",monsterName:"仮面魔獣マスクド・ヘルレイザー"},{spellName:"亀の誓い",monsterName:"クラブ・タートル"},{spellName:"ジャベリンビートルの契約",monsterName:"ジャベリンビートル"},{spellName:"ゼラの儀式",monsterName:"ゼラ"},{spellName:"カオス－黒魔術の儀式",monsterName:"マジシャン・オブ・ブラックカオス"},{spellName:"ガルマソードの誓い",monsterName:"ガルマソード"},{spellName:"ライオンの儀式",monsterName:"スーパー・ウォー・ライオン"},{spellName:"チャクラの復活",monsterName:"チャクラ"},{spellName:"要塞クジラの誓い",monsterName:"要塞クジラ"},{spellName:"ローの祈り",monsterName:"ローガーディアン"},{spellName:"スカルライダーの復活",monsterName:"スカルライダー"},{spellName:"踊りによる誘発",monsterName:"ダンシング・ソルジャー"},{spellName:"悪魔鏡の儀式",monsterName:"デビルズ・ミラー"},{spellName:"ハンバーガーのレシピ",monsterName:"ハングリーバーガー"}])yield{name:t.spellName,actions:[{title:"発動",isMandatory:!1,playType:"CardActivation",spellSpeed:"Normal",executableCells:["Hand","SpellAndTrapZone"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],...Gn(["Hand"],e=>e.nm===t.monsterName,["Hand","MonsterZone","ExtraMonsterZone"],()=>!0,"OrMore")},C]}}const pi=Object.freeze(Object.defineProperty({__proto__:null,default:jn},Symbol.toStringTag,{value:"Module"})),Un=(t,e,i,a,n,r)=>{if(!t.action.entity.origin.level||a.some(c=>!c.lvl)||a.map(c=>c.lvl??0).reduce((c,d)=>c+d,0)!==t.action.entity.origin.level)return;const s=a.filter(c=>{var d;return(d=c.status.monsterCategories)==null?void 0:d.some(p=>p==="Tuner")}),l=a.filter(c=>{var d;return(d=c.status.monsterCategories)==null?void 0:d.every(p=>p!=="Tuner")});if(!n(s)||!r(l))return;const u=[...s.map(c=>({material:c,cell:c.fieldCell,isAsTuner:!0})),...l.map(c=>({material:c,cell:c.fieldCell,isAsTuner:!1}))];if(t.activator.getEnableSummonList(t.activator,"SyncroSummon",["Rule","SpecialSummon"],t.action,[{monster:t.action.entity,posList:e,cells:i}],u,!1).length)return u};function*Vn(t,e=a=>a.length===1,i=a=>a.length>0){let a=[...t.activator.getMonstersOnField().filter(s=>s.battlePosition!=="Set"),...t.activator.getHandCell().cardEntities.filter(s=>s.origin.kind==="Monster")];if(a.every(s=>!s.status.allowHandSyncro)&&(a=a.filter(s=>s.fieldCell.isPlayFieldCell)),a.length<2)return;const n=[...t.activator.getMonsterZones(),...t.activator.duel.field.getCells("ExtraMonsterZone")],r=["Attack","Defense"];yield*a.getAllOnOffPattern().filter(s=>s.some(l=>l.status.allowHandSyncro)||s.every(l=>l.isOnFieldAsMonsterStrictly)).map(s=>Un(t,r,n,s,e,i)??[]).filter(s=>s.length)}const zn=async(t,e,i)=>{var u;const a=t.action.getEnableMaterialPatterns(t).toArray(),n=a.map(c=>({infos:c,materialSeqList:c.map(d=>d.material.seq).sort()}));let r=a[0].map(c=>c.material);if(a.length>1){const c=a.flatMap(p=>p.map(f=>f.material)).getDistinct(),d=await t.activator.waitSelectEntities(c,void 0,p=>{const f=p.map(g=>g.seq).sort();return n.some(g=>f.length===g.materialSeqList.length&&f.every((y,b)=>y===g.materialSeqList[b]))},"シンクロ素材とするモンスターを選択",i);if(!d)return;r=d}const s=r.map(c=>c.seq).sort(),l=(u=n.find(c=>s.length===c.materialSeqList.length&&s.every((d,p)=>d===c.materialSeqList[p])))==null?void 0:u.infos;if(!l)throw new v("想定されない状態",t,r);return await m.sendManyToGraveyardForTheSameReason(r,["SyncroMaterial","Cost","Rule","SpecialSummonMaterial"],t.action.entity,t.activator),{summonMaterialInfos:l}},Q=(t=i=>i.length===1,e=i=>i.length>0)=>({title:"シンクロ召喚",isMandatory:!1,playType:"SpecialSummon",spellSpeed:"Normal",executableCells:["ExtraDeck"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],getEnableMaterialPatterns:i=>Vn(i,t,e),canPayCosts:i=>i.action.getEnableMaterialPatterns(i).some(a=>a.length),canExecute:i=>!i.ignoreCost||i.activator.getAvailableExtraMonsterZones().length+i.activator.getAvailableMonsterZones().length>0,payCosts:zn,prepare:i=>te(i,"SyncroSummon",["Rule","SpecialSummon","SyncroSummon"],["Attack","Defense"]),execute:ie,settle:async()=>!0});function*Wn(){for(const t of["大地の騎士ガイアナイト","スクラップ・デスデーモン"])yield{name:t,actions:[T,E,_,Q()]};yield{name:"ナチュル・ガオドレイク",actions:[T,E,_,Q(t=>t.length===1&&t.every(e=>e.attr.some(i=>i==="Earth")),t=>t.length>0&&t.every(e=>e.attr.some(i=>i==="Earth")))]},yield{name:"マジカル・アンドロイド",actions:[T,E,_,Q(),{title:"回復",isMandatory:!0,playType:"IgnitionEffect",spellSpeed:"Normal",executableCells:["MonsterZone","ExtraMonsterZone"],executablePeriods:["end"],executableDuelistTypes:["Controller"],isOnlyNTimesPerTurnIfFaceup:1,meetsConditions:t=>t.activator.isTurnPlayer&&t.action.entity.face==="FaceUp",prepare:q,execute:async t=>(t.activator.heal(t.activator.getMonstersOnField().filter(e=>e.face==="FaceUp").filter(e=>e.types.includes("Psychic")).length*600,t.action.entity),!0),settle:async()=>!0}]}}const fi=Object.freeze(Object.defineProperty({__proto__:null,default:Wn},Symbol.toStringTag,{value:"Module"}));function*Qn(){yield{name:"にせアバター",actions:[P,T,E,_],continuousEffects:[Te("THE_DEVILS_AVATAR","Monster",t=>[t],t=>["attack","defense"].map(e=>H.createContinuous("THE_DEVILS_AVATAR",i=>i.isSpawnedBy.isOnFieldStrictly&&i.isSpawnedBy.face==="FaceUp",t,(i,a)=>a.isOnFieldStrictly&&a.face==="FaceUp",e,"calculated","THE_DEVILS_AVATAR",()=>Number.MIN_VALUE)))]},yield{name:"にせドレッド・ルート",actions:[P,T,E,_],continuousEffects:[De("THE_DEVILS_DREAD-ROOT","Monster",t=>["attack","defense"].map(e=>H.createContinuous("THE_DEVILS_DREAD-ROOT",i=>i.isSpawnedBy.isOnFieldStrictly&&i.isSpawnedBy.face==="FaceUp",t,(i,a)=>a.kind==="Monster"&&a.isOnFieldStrictly&&a.face==="FaceUp"&&a!==i.isSpawnedBy,e,"calculated","THE_DEVILS_DREAD-ROOT",(i,a,n)=>Math.round(n/2))))]}}const hi=Object.freeze(Object.defineProperty({__proto__:null,default:Qn},Symbol.toStringTag,{value:"Module"})),Xn=(t,e,i,a,n=2,r=2,s)=>{if(!t.action.entity.origin.rank||a.length<n||a.length>r||a.some(u=>!u.lvl)||a.some(u=>u.lvl!==t.action.entity.rank)||!s(a))return;const l=a.map(u=>({material:u,cell:u.fieldCell,level:u.status.level}));if(t.activator.getEnableSummonList(t.activator,"XyzSummon",["Rule","XyzSummon","SpecialSummon"],t.action,[{monster:t.action.entity,posList:e,cells:i}],l,!1).length)return l};function*Kn(t,e=2,i=2,a=n=>n.length>1){const n=t.activator.getMonstersOnField().filter(s=>s.battlePosition!=="Set");if(n.length<e)return;const r=[...t.activator.getMonsterZones(),...t.activator.getAvailableExtraMonsterZones()];yield*n.getAllOnOffPattern().filter(s=>s.length>=e).filter(s=>s.length<=i).map(s=>Xn(t,S,r,s,e,i,a)??[]).filter(s=>s.length)}const Jn=async(t,e,i)=>{var u;const a=t.action.getEnableMaterialPatterns(t).toArray(),n=a.map(c=>({infos:c,materialSeqList:c.map(d=>d.material.seq).sort()}));let r=a[0].map(c=>c.material);if(a.length>1){const c=a.flatMap(p=>p.map(f=>f.material)).getDistinct(),d=await t.activator.waitSelectEntities(c,void 0,p=>{const f=p.map(g=>g.seq).sort();return n.some(g=>f.length===g.materialSeqList.length&&f.every((y,b)=>y===g.materialSeqList[b]))},"エクシーズ素材とするモンスターを選択",i);if(!d)return;r=d}const s=r.map(c=>c.seq).sort(),l=(u=n.find(c=>s.length===c.materialSeqList.length&&s.every((d,p)=>d===c.materialSeqList[p])))==null?void 0:u.infos;if(!l)throw new v("想定されない状態",t,r);return console.log(l),await m.convertManyToXyzMaterials(l.map(c=>c.material),["XyzMaterial","Rule","Cost"],t.action.entity,t.activator),console.log(l.map(c=>c.material.kind)),{summonMaterialInfos:l}},Yn=(t=2,e=2,i=a=>a.length>1)=>({title:"エクシーズ召喚",isMandatory:!1,playType:"SpecialSummon",spellSpeed:"Normal",executableCells:["ExtraDeck"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],getEnableMaterialPatterns:a=>Kn(a,t,e,i),canPayCosts:a=>a.action.getEnableMaterialPatterns(a).some(n=>n.length),canExecute:a=>!a.ignoreCost||a.activator.getAvailableExtraMonsterZones().length+a.activator.getAvailableMonsterZones().length>0,payCosts:Jn,prepare:a=>te(a,"XyzSummon",["Rule","SpecialSummon","XyzSummon"],["Attack","Defense"]),execute:ie,settle:async()=>!0});function*In(){yield*[{name:"ジェムナイト・パール",qty:2},{name:"覚醒の勇士 ガガギゴ",qty:3}].map(t=>({name:t.name,actions:[T,E,_,Yn(t.qty,t.qty)]}))}const gi=Object.freeze(Object.defineProperty({__proto__:null,default:In},Symbol.toStringTag,{value:"Module"}));function*er(){yield{name:"シューティング・ライザー・ドラゴン",actions:[T,E,_,Q(),{title:"①墓地送り",isMandatory:!1,playType:"TriggerEffect",spellSpeed:"Normal",executableCells:R,executablePeriods:[...D,...N],executableDuelistTypes:["Controller"],isOnlyNTimesPerTurn:1,canExecute:t=>t.action.entity.hasBeenSummonedNow(["SyncroSummon"])&&t.activator.getDeckCell().cardEntities.some(e=>(e.lvl??12)<(t.action.entity.lvl??0)),prepare:async()=>({selectedEntities:[],chainBlockTags:["SendToGraveyardFromDeck","IfSpecialSummonSucceed"],prepared:void 0}),execute:async t=>{const e=t.activator.getDeckCell().cardEntities.filter(n=>(n.lvl??12)<(t.action.entity.lvl??0));if(e.length===0)return!1;const i=await t.activator.waitSelectEntity(e,"墓地に送るモンスターを選択",!1);if(!i)throw new v("想定されない状況",t);await i.sendToGraveyard(["Effect"],t.action.entity,t.activator);const a=i.lvl??0;return t.action.entity.numericOprsBundle.push(H.createLingeringAddition("レベル減少",()=>!0,t.action.entity,t.action,"level",(n,r,s)=>s-a)),!0},settle:async()=>!0},It({title:"②シンクロ召喚",isOnlyNTimesPerChain:1})]}}const yi=Object.freeze(Object.defineProperty({__proto__:null,default:er},Symbol.toStringTag,{value:"Module"})),tr=(t,e,i,a,n,r)=>{const s=t.fusionMaterialInfos.filter(c=>c.type!=="Overmuch");if(!s.length||!n.length||s.length!==n.length||!r(n)||!t.validateFusionMaterials(n))return;const l=s.map(c=>{const d=[];return Fe(c)?d.push(...n.filter(p=>c.cardName===p.nm||p.status.fusionSubstitute)):d.push(...n.filter(c.filter)),{require:c,materials:d}});if(l.some(c=>!c.materials.length)||l.flatMap(c=>c.materials).getDistinct().length<n.length)return;let u=[[]];for(const c of l)u=[...u.flatMap(d=>c.materials.map(p=>{if(d.some(g=>g.material===p))return[...d];const f={material:p,cell:p.fieldCell};return Fe(c.require)&&(f.name=c.require.cardName),[...d,f]}))];return u.forEach(c=>{console.log(c.map(d=>d.material.toString()).join(","))}),u=u.filter(c=>c.length===n.length).filter(c=>c.filter(d=>d.name&&d.material.nm!==d.name).length<2),u.forEach(c=>{console.log(c.map(d=>d.material.toString()).join(","))}),u.find(c=>e.activator.getEnableSummonList(e.activator,"FusionSummon",["Effect","SpecialSummon"],e.action,[{monster:e.action.entity,posList:i,cells:a}],c,!1).length)};function*mi(t,...e){const[i,a,n,r]=e,s=t.activator.getCells(...i).flatMap(d=>d.cardEntities).filter(d=>{var p;return(p=d.status.monsterCategories)==null?void 0:p.includes("Fusion")}).filter(a);if(!s.length)return;const l=t.activator.getCells(...n).flatMap(d=>d.cardEntities).filter(d=>d.kind==="Monster").filter(d=>d.canBeEffected(t.activator,t.action.entity,t.action));if(!l.length)return;const u=[...t.activator.getMonsterZones(),...t.activator.duel.field.getCells("ExtraMonsterZone")],c=["Attack","Defense"];for(const d of s){const p=d.fusionMaterialInfos.filter(f=>f.type!=="Overmuch");if(p.length&&!(l.every(f=>!f.status.fusionSubstitute)&&p.filter(Fe).some(f=>l.every(g=>g.nm!==f.cardName)))&&!p.filter(Nr).some(f=>l.every(g=>!f.filter(g))))for(const f of l.filter(g=>g!==d).getAllOnOffPattern().filter(g=>g.length===p.length)){const g=tr(d,t,c,u,f,r);g&&(yield{monster:d,materialInfos:g},console.log(d,g))}}}const ir=async(t,...e)=>{var p;const i=mi(t,...e).toArray(),a=i.map(f=>f.monster).getDistinct(),n=await t.activator.waitSelectEntity(a,"融合召喚するモンスターを選択。");if(!n)return!1;const r=n.fusionMaterialInfos.filter(Br),s=i.filter(f=>f.monster===n).map(f=>f.materialInfos),l=s.map(f=>({infos:f,requiredSeqList:f.map(g=>g.material.seq)}));let u=s[0].map(f=>f.material);if(s.length>1||r.length){const f=s.flatMap(g=>g.map(y=>y.material)).getDistinct();u=await t.activator.waitSelectEntities(f,void 0,g=>l.some(y=>y.requiredSeqList.every(b=>g.map(h=>h.seq).includes(b))&&g.filter(b=>!y.requiredSeqList.includes(b.seq)).every(b=>r.some(h=>h.filter(b)))),"融合素材とするモンスターを選択",!1)??u}const c=l.find(f=>f.requiredSeqList.every(g=>u.map(y=>y.seq).includes(g))&&u.filter(g=>!f.requiredSeqList.includes(g.seq)).every(g=>r.some(y=>y.filter(g))));if(!c)throw new v("想定されない状態",t,u);const d=c.infos;return d.push(...u.filter(f=>!c.requiredSeqList.includes(f.seq)).map(f=>({material:f,cell:f.fieldCell}))),await m.sendManyToGraveyardForTheSameReason(u,["FusionMaterial","Effect","SpecialSummonMaterial"],t.action.entity,t.activator),await t.activator.summon("FusionSummon",["Effect","SpecialSummon"],t.action,n,S,[...t.activator.getMonsterZones(),...t.activator.duel.field.getCells("ExtraMonsterZone")],d,!1),n.info.isRebornable=!((p=n.origin.monsterCategories)!=null&&p.includes("RegularSpecialSummonOnly")),d.map(f=>f.material).forEach(f=>f.onUsedAsMaterial(t,t.action.entity)),!0},dt=(t,e,i,a,n)=>({canExecute:r=>mi(r,t,e,i,a,n).some(s=>s.materialInfos.length),prepare:async()=>({selectedEntities:[],chainBlockTags:["SpecialSummonFromExtraDeck"],prepared:void 0}),execute:r=>ir(r,t,e,i,a,n),settle:async()=>!0});function*ar(){for(const t of["心眼の女神","沼地の魔獣王","イリュージョン・シープ","破壊神 ヴァサーゴ"])yield{name:t,actions:[T,E,_,P],continuousEffects:[Ue]};yield{name:"沼地の魔神王",actions:[T,E,_,P,{title:"融合サーチ",isMandatory:!1,playType:"IgnitionEffect",spellSpeed:"Normal",executableCells:["Hand"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],canPayCosts:on,canExecute:t=>t.activator.getDeckCell().cardEntities.some(e=>e.nm==="融合")&&t.activator.canAddToHandFromDeck,getDests:t=>[t.activator.getGraveyard()],payCosts:ln,prepare:async()=>({selectedEntities:[],chainBlockTags:["SearchFromDeck"],prepared:void 0}),execute:async t=>{const e=t.activator.getDeckCell().cardEntities.filter(a=>a.nm==="融合");if(!e.length)return!1;const i=await t.activator.waitSelectEntity(e,"手札に加えるカードを選択",!1);return i?(await i.addToHand(["Effect"],t.action.entity,t.activator),!0):!1},settle:async()=>!0}],continuousEffects:[Ue]},yield{name:"パラサイト・フュージョナー",actions:[T,E,_,P,{title:"融合",isMandatory:!1,playType:"TriggerEffect",spellSpeed:"Normal",executableCells:["MonsterZone"],executablePeriods:D,executableDuelistTypes:["Controller"],...dt(["ExtraDeck"],()=>!0,["MonsterZone","ExtraMonsterZone"],()=>!0,"Graveyard"),settle:async()=>!0}],summonFilter:(t,e,i,a,n,r,s,l,u,c)=>{const d={posList:u,cells:c},p={posList:[],cells:[]};if(!n.includes("FusionSummon"))return d;const f=l.find(g=>g.material===t.isSpawnedBy);return f?f.name&&f.name!==t.isSpawnedBy.nm?d:p:d},continuousEffects:[Ue]}}const vi=Object.freeze(Object.defineProperty({__proto__:null,default:ar},Symbol.toStringTag,{value:"Module"}));function*nr(){yield{name:"折れ竹光",actions:[he(),C]},yield{name:"妖刀竹光",actions:[he(),C,{title:"②直接攻撃付与",isMandatory:!1,playType:"IgnitionEffect",spellSpeed:"Normal",executableCells:["SpellAndTrapZone"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],isOnlyNTimesPerTurn:1,...X(t=>t.activator.getSpellTrapsOnField().filter(e=>{var i;return(i=e.status.nameTags)==null?void 0:i.includes("竹光")}).filter(e=>e!==t.action.entity).filter(e=>e.status.spellCategory==="Equip"),{message:"手札に戻すカードを選択。",tags:["BounceToHand"]}),execute:async t=>{const e=t.action.entity.info.equipedBy;return e?(await m.returnManyToHandForTheSameReason(t.selectedEntities,["Effect"],t.action.entity,t.activator),e.statusOperatorBundle.push(new V("直接攻撃",i=>(console.log(i.effectOwner.duel.clock.turn,i.isSpawnedAt.turn),i.effectOwner.duel.clock.isSameTurn(i.isSpawnedAt)),!1,t.action.entity,t.action,()=>!0,(i,a)=>({...a,canDirectAttack:!0}))),!0):!1},settle:async()=>!0},{title:"③サーチ",isMandatory:!1,playType:"TriggerEffect",spellSpeed:"Normal",executableCells:["Graveyard"],executablePeriods:[...D,...N],executableDuelistTypes:["Controller"],meetsConditions:t=>t.action.entity.wasMovedAtPreviousChain&&t.action.entity.wasMovedFrom.cellType!=="Banished",canExecute:t=>t.activator.canAddToHandFromDeck&&t.activator.getDeckCell().cardEntities.filter(e=>{var i;return(i=e.status.nameTags)==null?void 0:i.includes("竹光")}).some(e=>e.status.name!=="妖刀竹光"),prepare:async()=>({selectedEntities:[],chainBlockTags:["SearchFromDeck"],prepared:void 0}),execute:async t=>{const e=t.activator.getDeckCell().cardEntities.filter(a=>{var n;return(n=a.status.nameTags)==null?void 0:n.includes("竹光")}).filter(a=>a.status.name!=="妖刀竹光");if(!e.length)return!1;const i=await t.activator.waitSelectEntity(e,"手札に加えるカードを選択。",!1);if(!i)throw new F(t);return(await i.addToHand(["Effect"],t.action.entity,t.activator)).cellType==="Hand"},settle:async()=>!0}]},yield{name:"真刀竹光",actions:[he(),C,{title:"②相手モンスター破壊",isMandatory:!1,playType:"TriggerEffect",spellSpeed:"Normal",executableCells:["SpellAndTrapZone"],executablePeriods:["b1DAfterDmgCalc","b2DAfterDmgCalc"],executableDuelistTypes:["Controller"],canExecute:t=>{const e=t.action.entity.info.equipedBy;return!(!e||!e.info.battleLog.filter(i=>t.activator.duel.clock.isPreviousStage(i.timestamp)).some(i=>i.enemy.entityType==="Duelist")||!t.activator.getOpponentPlayer().getMonstersOnField().length||!t.activator.getOpponentPlayer().lifeLog.filter(i=>t.activator.duel.clock.isPreviousStage(i.clock)).some(i=>i.entity===e))},prepare:async t=>({selectedEntities:[],chainBlockTags:t.action.calcChainBlockTagsForDestroy(t.activator,t.activator.getOpponentPlayer().getMonstersOnField()),prepared:void 0}),execute:async t=>(await m.tryDestroy(t.activator.getOpponentPlayer().getMonstersOnField(),t)).length>0,settle:async()=>!0},{title:"③竹光入替",isMandatory:!1,playType:"IgnitionEffect",spellSpeed:"Normal",executableCells:["SpellAndTrapZone"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],canPayCosts:t=>t.action.entity.info.equipedBy?an(t):!1,canExecute:t=>!!(t.action.entity.info.equipedBy&&t.activator.getDeckCell().cardEntities.filter(e=>{var i;return(i=e.status.nameTags)==null?void 0:i.includes("竹光")}).filter(e=>e.status.name!=="真刀竹光").some(e=>e.status.spellCategory==="Equip"))&&t.activator.duel.field.getMonstersOnFieldStrictly().some(e=>e.canBeTargetOfEffect(t)),payCosts:nn,prepare:q,execute:async t=>{const e=t.activator.getDeckCell().cardEntities.filter(l=>{var u;return(u=l.status.nameTags)==null?void 0:u.includes("竹光")}).filter(l=>l.status.name!=="真刀竹光").filter(l=>l.status.spellCategory==="Equip");if(!e.length)return!1;const i=t.activator.getAvailableSpellTrapZones();if(!i.length)return!1;const a=t.activator.duel.field.getMonstersOnFieldStrictly().filter(l=>l.canBeTargetOfEffect(t));if(!a.length)return!1;const n=await t.activator.waitSelectEntity(e,"装備するカードを選択。",!1);if(!n)throw new F("竹光選択",t);const r=await t.activator.duel.view.waitSelectDestination(t.activator,n,i,"装備カードを置く場所を選択。","装備",!1);if(!r)throw new F("配置場所選択",t);await n.putDirectly(r,"Spell",["Effect"],t.action.entity,t.activator);const s=await t.activator.waitSelectEntity(a,"装備する対象を選択。",!1);if(!s)throw new F("装備対象選択",t);return n.info.equipedBy=s,n.info.effectTargets[t.action.seq]=[s],s.info.equipEntities.push(n),!0},settle:async()=>!0}]}}const Si=Object.freeze(Object.defineProperty({__proto__:null,default:nr},Symbol.toStringTag,{value:"Module"}));function*rr(){yield{name:"黄金色の竹光",actions:[{title:"発動",isMandatory:!1,playType:"CardActivation",spellSpeed:"Normal",executableCells:["Hand","SpellAndTrapZone"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],priorityForNPC:20,meetsConditions:t=>t.activator.getSpellTrapsOnField().filter(e=>{var i;return(i=e.status.nameTags)==null?void 0:i.includes("竹光")}).filter(e=>e.face==="FaceUp").some(e=>e.status.spellCategory==="Equip"),canExecute:t=>t.activator.getDeckCell().cardEntities.length>0&&t.activator.canDraw,prepare:async()=>({selectedEntities:[],chainBlockTags:["Draw"],prepared:void 0}),execute:async t=>(await t.activator.draw(2,t.action.entity,t.activator),!0),settle:async()=>!0},C]}}const Ci=Object.freeze(Object.defineProperty({__proto__:null,default:rr},Symbol.toStringTag,{value:"Module"}));function*sr(){yield{name:"ＢＦ－疾風のゲイル",actions:[P,T,E,_,{title:"①特殊召喚",isMandatory:!1,playType:"SpecialSummon",spellSpeed:"Normal",executableCells:["Hand"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],canExecute:t=>t.activator.getMonstersOnField().filter(e=>(e.status.nameTags??[]).includes("ＢＦ")).some(e=>e.nm!==t.action.entity.origin.name)&&j(t,S,[],["Rule"]),getDests:t=>J(t,S,[],["Rule"]),prepare:t=>te(t,"SpecialSummon",["SpecialSummon","Rule"],S),execute:ie,settle:async()=>!0},{title:"②攻守半減",isMandatory:!1,playType:"IgnitionEffect",spellSpeed:"Normal",executableCells:["MonsterZone"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],isOnlyNTimesPerTurnIfFaceup:1,...X(t=>t.activator.getOpponentPlayer().getMonstersOnField().filter(e=>e.face==="FaceUp").filter(e=>e.canBeTargetOfEffect(t)),{message:"対象モンスターを選択。"}),execute:async t=>{const e=t.selectedEntities.filter(i=>i.isOnFieldAsMonsterStrictly).filter(i=>i.face==="FaceUp").find(i=>i.canBeEffected(t.activator,t.action.entity,t.action));return e?(["attack","defense"].map(i=>H.createLingeringFixation("②攻守半減",()=>!0,t.action.entity,t.action,i,(a,n,r)=>Math.round(r/2))).forEach(i=>e.numericOprsBundle.push(i)),!0):!1},settle:async()=>!0}]}}const Ti=Object.freeze(Object.defineProperty({__proto__:null,default:sr},Symbol.toStringTag,{value:"Module"}));function*or(){yield{name:"水晶機巧－ハリファイバー",actions:[T,ut(t=>t.length===2&&t.some(e=>{var i;return(i=e.status.monsterCategories)==null?void 0:i.includes("Tuner")})),{title:"①リクルート",isMandatory:!1,playType:"TriggerEffect",spellSpeed:"Normal",executableCells:R,executablePeriods:[...D,...N],executableDuelistTypes:["Controller"],meetsConditions:t=>t.action.entity.hasBeenSummonedNow(["LinkSummon"]),canExecute:t=>{const e=[t.activator.getHandCell(),t.activator.getDeckCell()].flatMap(n=>n.cardEntities).filter(n=>(n.lvl??12)<4).filter(n=>{var r;return(r=n.status.monsterCategories)==null?void 0:r.includes("Tuner")}),i=t.activator.getMonsterZones();return t.activator.getEnableSummonList(t.activator,"SpecialSummon",["Effect"],t.action,e.map(n=>({monster:n,cells:i,posList:["Defense"]})),[],!1).length>0},prepare:async()=>({selectedEntities:[],chainBlockTags:["SpecialSummonFromDeck"],prepared:void 0}),execute:async t=>{const e=[t.activator.getHandCell(),t.activator.getDeckCell()].flatMap(n=>n.cardEntities).filter(n=>(n.lvl??12)<4).filter(n=>{var r;return(r=n.status.monsterCategories)==null?void 0:r.includes("Tuner")}),i=t.activator.getMonsterZones(),a=await t.activator.summonOne(t.activator,"SpecialSummon",["Effect"],t.action,e.map(n=>({monster:n,cells:i,posList:["Defense"]})),[],!1,!1);if(!a)throw new F(t);return a.statusOperatorBundle.push(new V("効果発動不可",n=>n.effectOwner.duel.clock.isSameTurn(n.isSpawnedAt),!1,t.action.entity,t.action,(n,r)=>n.effectOwner.duel.clock.isSameTurn(n.isSpawnedAt)&&r.isOnFieldAsMonsterStrictly,()=>({canActivateEffect:!1}))),!0},settle:async()=>!0},{title:"②シンクロ召喚",isMandatory:!1,playType:"QuickEffect",spellSpeed:"Quick",executableCells:R,executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],isOnlyNTimesPerChain:1,canPayCosts:ke,meetsConditions:t=>!t.activator.isTurnPlayer,canExecute:t=>{const e=[...t.activator.getMonsterZones(),...t.activator.duel.field.getCells("ExtraMonsterZone")],i=t.activator.getExtraDeck().cardEntities.filter(n=>{var r;return(r=n.status.monsterCategories)==null?void 0:r.includes("Syncro")}).filter(n=>{var r;return(r=n.status.monsterCategories)==null?void 0:r.includes("Tuner")});return t.activator.getEnableSummonList(t.activator,"SyncroSummon",["SpecialSummon","Effect"],t.action,i.map(n=>({monster:n,cells:e,posList:S})),[{material:t.action.entity,cell:t.action.entity.fieldCell}],!1).length>0},payCosts:Re,prepare:q,execute:async t=>{const e=[...t.activator.getMonsterZones(),...t.activator.duel.field.getCells("ExtraMonsterZone")],i=t.activator.getExtraDeck().cardEntities.filter(n=>{var r;return(r=n.status.monsterCategories)==null?void 0:r.includes("Syncro")}).filter(n=>{var r;return(r=n.status.monsterCategories)==null?void 0:r.includes("Tuner")});return!!await t.activator.summonOne(t.activator,"SyncroSummon",["SpecialSummon","Effect"],t.action,i.map(n=>({monster:n,cells:e,posList:S})),[],!1,!1)},settle:async()=>!0}]}}const Ei=Object.freeze(Object.defineProperty({__proto__:null,default:or},Symbol.toStringTag,{value:"Module"}));function*lr(){yield{name:"封印されしエクゾディア",actions:[T,E,P,_,{title:"封印開放",isMandatory:!0,playType:"Exodia",spellSpeed:"Normal",executableCells:["Hand"],executablePeriods:U,executableDuelistTypes:["Controller"],canExecute:t=>t.activator.getHandCell().cardEntities.filter(i=>{var a;return(a=i.origin.nameTags)==null?void 0:a.includes("封印されし")}).map(i=>i.origin.name).getDistinct().length===5,prepare:async t=>(await m.sendManyToGraveyardForTheSameReason(t.activator.duel.field.getCardsOnFieldStrictly(),["Rule"],t.action.entity,t.activator),{selectedEntities:[],chainBlockTags:[],prepared:void 0,nextChainBlockFilter:()=>!1}),execute:async t=>{const e=t.activator.getOpponentPlayer().getHandCell().cardEntities.filter(a=>{var n;return(n=a.origin.nameTags)==null?void 0:n.includes("封印されし")}).map(a=>a.origin.name).getDistinct().length===5,i=[{name:"封印されし者の左足",column:4},{name:"封印されし者の右足",column:2},{name:"封印されし者の左腕",column:5},{name:"封印されし者の右腕",column:1},{name:"封印されしエクゾディア",column:3}];for(const a of i){const n=[t.activator.getHandCell().cardEntities.find(r=>r.origin.name===a.name),t.activator.getOpponentPlayer().getHandCell().cardEntities.find(r=>r.origin.name===a.name)].filter(r=>r!==void 0);if(!n.length)throw new v("想定されない状態",t.activator.getHandCell().cardEntities,a.name);await M.moveMany(n.map(r=>[r,r.controller.getMonsterZones().find(s=>s.column===(r.controller.seat==="Above"?6-a.column:a.column))??r.controller.getFieldZone(),"Monster","FaceUp","Vertical","Top",["Rule"],void 0,void 0,void 0]))}throw e?new $(void 0,`お互いが、${t.action.entity.toString()}の特殊勝利条件を同時に満たした。`):new $(t.activator,`${t.action.entity.toString()}の特殊勝利条件を満たした。`)},settle:async()=>!0}]}}const _i=Object.freeze(Object.defineProperty({__proto__:null,default:lr},Symbol.toStringTag,{value:"Module"}));function*cr(){yield{name:"ファイアウォール・ドラゴン・シンギュラリティ",actions:[T,ut(t=>t.length>2),{title:"①バウンス＆自己強化",isMandatory:!1,playType:"QuickEffect",spellSpeed:"Quick",executableCells:R,executablePeriods:[...D,...N],executableDuelistTypes:["Controller"],isOnlyNTimesPerTurn:1,canExecute:t=>[...t.activator.getGraveyard().cardEntities,...t.activator.getMonstersOnField()].flatMap(n=>n.status.monsterCategories??[]).getDistinct().union(["Ritual","Fusion","Syncro","Xyz"]).length<1?!1:[...t.activator.getOpponentPlayer().getGraveyard().cardEntities,...t.activator.getOpponentPlayer().getEntiteisOnField()].filter(n=>n.canBeTargetOfEffect(t)).length>0,prepare:async(t,e,i)=>{const n=[...t.activator.getGraveyard().cardEntities,...t.activator.getMonstersOnField()].flatMap(l=>l.status.monsterCategories??[]).getDistinct().union(["Ritual","Fusion","Syncro","Xyz"]).length;if(n<1)return;const r=[...t.activator.getOpponentPlayer().getGraveyard().cardEntities,...t.activator.getOpponentPlayer().getEntiteisOnField()].filter(l=>l.canBeTargetOfEffect(t));if(r.length<1)return;const s=await t.activator.waitSelectEntities(r,void 0,l=>l.length>0&&l.length<=n,"手札に戻すカードを選択。",i);if(s)return{selectedEntities:s,chainBlockTags:[],prepared:void 0}},execute:async t=>{const e=t.selectedEntities.filter(a=>a.isOnFieldStrictly||a.fieldCell.cellType==="Graveyard").filter(a=>a.canBeEffected(t.activator,t.action.entity,t.action));await m.returnManyToHandForTheSameReason(e,["Effect"],t.action.entity,t.activator);const i=e.filter(a=>a.fieldCell.cellType==="Hand"||a.fieldCell.cellType==="ExtraDeck").length;return t.action.entity.numericOprsBundle.push(H.createLingeringAddition(t.action.title,a=>a.isSpawnedBy.isEffective,t.action.entity,t.action,"attack",(a,n,r)=>r+500*i)),!0},settle:async()=>!0},{title:"②蘇生",isMandatory:!1,playType:"TriggerEffect",spellSpeed:"Normal",executableCells:R,executablePeriods:U,executableDuelistTypes:["Controller"],isOnlyNTimesPerTurn:1,meetsConditions:t=>{const e=t.action.entity.moveLog.latestRecord.movedAt,i=t.action.duel.field.moveLog.getPriviousChainLog().filter(a=>(console.log(a,a.entity.fieldCell.cellType==="Graveyard",a.movedAs.includes("BattleDestroy")),a.entity.fieldCell.cellType==="Graveyard"||a.movedAs.includes("BattleDestroy"))).filter(a=>a.movedAt.totalProcSeq>e.totalProcSeq).map(a=>a.entity.wasMovedFrom).toArray();return t.action.entity.linkArrowDests.union(i).length>0},canExecute:t=>{const e=t.activator.getMonsterZones();return t.activator.getEnableSummonList(t.activator,"SpecialSummon",["Effect"],t.action,t.activator.getGraveyard().cardEntities.filter(a=>a.kind==="Monster").filter(a=>a.types.includes("Cyberse")).filter(a=>a.canBeTargetOfEffect(t)).map(a=>({monster:a,posList:S,cells:e})),[],!1).length>0},prepare:t=>le(t,t.activator.getGraveyard().cardEntities.filter(e=>e.kind==="Monster").filter(e=>e.types.includes("Cyberse")).filter(e=>e.canBeTargetOfEffect(t)),S),execute:t=>ce(t,S),settle:async()=>!0}]}}const ki=Object.freeze(Object.defineProperty({__proto__:null,default:cr},Symbol.toStringTag,{value:"Module"}));function*ur(){yield{name:"融合",actions:[{title:"発動",isMandatory:!1,playType:"CardActivation",spellSpeed:"Normal",executableCells:["Hand","SpellAndTrapZone"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],...dt(["ExtraDeck"],()=>!0,["Hand","MonsterZone","ExtraMonsterZone"],()=>!0,"Graveyard")},C]};for(const t of[{name:"簡易融合",lvlUpperBound:5,filter:()=>!0},{name:"簡素融合",lvlUpperBound:6,filter:e=>{var i;return!((i=e.status.monsterCategories)!=null&&i.includes("Effect"))}}])yield{name:t.name,actions:[{title:"発動",isMandatory:!1,playType:"CardActivation",spellSpeed:"Normal",executableCells:["Hand","SpellAndTrapZone"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],isOnlyNTimesPerTurn:1,canPayCosts:e=>e.activator.lp>=1e3,canExecute:e=>{const i=e.activator.getMonsterZones();return e.activator.getEnableSummonList(e.activator,"SpecialSummon",["Effect"],e.action,e.activator.getExtraDeck().cardEntities.filter(n=>{var r;return(r=n.status.monsterCategories)==null?void 0:r.includes("Fusion")}).filter(n=>n.lvl&&n.lvl<=t.lvlUpperBound).filter(t.filter).map(n=>({monster:n,posList:S,cells:i})),[],!1).length>0},payCosts:(e,i)=>_e(e,i,1e3),prepare:async()=>({selectedEntities:[],chainBlockTags:["SpecialSummonFromExtraDeck"],prepared:void 0}),execute:async e=>{var r;const i=e.activator.getMonsterZones();if(!e.activator.getEnableSummonList(e.activator,"FusionSummon",["Effect"],e.action,e.activator.getExtraDeck().cardEntities.filter(s=>{var l;return(l=s.status.monsterCategories)==null?void 0:l.includes("Fusion")}).filter(s=>s.lvl&&s.lvl<=t.lvlUpperBound).filter(t.filter).map(s=>({monster:s,posList:S,cells:i})),[],!1).length)return!1;const n=await e.activator.summonOne(e.activator,"FusionSummon",["Effect"],e.action,e.activator.getExtraDeck().cardEntities.filter(s=>{var l;return(l=s.status.monsterCategories)==null?void 0:l.includes("Fusion")}).filter(s=>s.lvl&&s.lvl<=t.lvlUpperBound).filter(t.filter).map(s=>({monster:s,posList:S,cells:i})),[],!1,!1);return n?(n.statusOperatorBundle.push(new V("攻撃不可",()=>!0,!1,e.action.entity,e.action,(s,l)=>l.face==="FaceUp"&&l.isOnFieldAsMonsterStrictly,(s,l)=>({...l,canAttack:!1}))),n.counterHolder.setSelfDestructionFlg(e.action.entity),n.info.isRebornable=!((r=n.origin.monsterCategories)!=null&&r.includes("RegularSpecialSummonOnly")),!0):!1},settle:async()=>!0},C,{title:"自壊",isMandatory:!0,playType:"LingeringEffect",spellSpeed:"Normal",executableCells:I,executablePeriods:["end"],executableDuelistTypes:Ee,canExecute:e=>e.action.entity.field.getMonstersOnFieldStrictly().some(i=>i.counterHolder.getSelfDestructionFlg(e.action.entity)),prepare:q,execute:async e=>{const i=e.action.entity.field.getMonstersOnFieldStrictly().filter(n=>n.counterHolder.getSelfDestructionFlg(e.action.entity));if(!i.length)throw new v("想定されない状態",e);let a=i[0];if(i.length>1){const n=await e.activator.waitSelectEntity(i,"自壊させるカードを選択。",!1);if(!n)throw new F(e);a=n}return await m.tryDestroy([a],e),!0},settle:async()=>!0}]}}const wi=Object.freeze(Object.defineProperty({__proto__:null,default:ur},Symbol.toStringTag,{value:"Module"}));function*dr(){yield*["イグナイト・イーグル","イグナイト・マグナム","イグナイト・ドラグノフ","イグナイト・マスケット","イグナイト・デリンジャー","イグナイト・ライオット","イグナイト・ウージー","イグナイト・キャリバー"].map(t=>({name:t,actions:[T,E,_,P,ee,{title:"①サーチ",isMandatory:!1,playType:"IgnitionEffect",spellSpeed:"Normal",executableCells:["SpellAndTrapZone"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],meetsConditions:e=>{var a;const i=e.activator.getPendulumScaleMonsters().find(n=>n!==e.action.entity);return!(!i||!((a=i.status.nameTags)!=null&&a.includes("イグナイト")))},canExecute:e=>e.activator.getDeckCell().cardEntities.some(i=>{var a;return(a=i.status.nameTags)==null?void 0:a.includes("イグナイト")}),prepare:async e=>({selectedEntities:[],chainBlockTags:["SearchFromDeck",...e.action.calcChainBlockTagsForDestroy(e.activator,e.activator.getPendulumScaleMonsters())],prepared:void 0}),execute:async e=>{if(!(await m.tryDestroy(e.activator.getPendulumScaleMonsters(),e)).length)return!1;const a=e.activator.getDeckCell().cardEntities.filter(r=>{var s;return(s=r.status.nameTags)==null?void 0:s.includes("イグナイト")});if(!a.length)return!1;const n=await e.activator.waitSelectEntity(a,"手札に加えるカードを選択。",!1);return n?(await n.addToHand(["Effect"],e.action.entity,e.activator),!0):!1},settle:async()=>!0}]}))}const bi=Object.freeze(Object.defineProperty({__proto__:null,default:dr},Symbol.toStringTag,{value:"Module"}));function*pr(){yield{name:"ジャンク・コレクター",actions:[T,E,_,P,{title:"罠コピー",isMandatory:!1,playType:"QuickEffect",spellSpeed:"Quick",executableCells:R,executablePeriods:D,executableDuelistTypes:["Controller"],needsToPayCost:!0,canPayCosts:t=>t.activator.getGraveyard().cardEntities.filter(i=>i.kind==="Trap").filter(i=>i.status.trapCategory==="Normal").filter(i=>t.activator.canTryBanish(i,"BanishAsCost",t.action)).filter(i=>i.canBeBanished("BanishAsCost",t.activator,t.action.entity,t.action)).flatMap(i=>i.actions).filter(i=>i.playType==="CardActivation").filter(i=>!i.needsToPayCost).filter(i=>i.validate(t.activator,[],["IgnoreCosts","CopyEffectOnly"])).length?ke(t):!1,payCosts:async(t,e,i)=>{const a=t.activator.getGraveyard().cardEntities.filter(s=>s.kind==="Trap").filter(s=>s.status.trapCategory==="Normal").filter(s=>t.activator.canTryBanish(s,"BanishAsCost",t.action)).filter(s=>s.canBeBanished("BanishAsCost",t.activator,t.action.entity,t.action)).flatMap(s=>s.actions).filter(s=>s.playType==="CardActivation").filter(s=>!s.needsToPayCost).filter(s=>s.validate(t.activator,[],["IgnoreCosts","CopyEffectOnly"])).map(s=>s.entity),n=await t.activator.waitSelectEntity(a,"コピーする罠を選択。",i);if(!n)throw new v("想定されない状態",t);const r=[t.action.entity,n];return await m.banishManyForTheSameReason(r,["Cost"],t.action.entity,t.activator),{banish:r}},prepare:async(t,e)=>{var n;const i=(n=t.costInfo.banish)==null?void 0:n.find(r=>r!==t.action.entity);if(!i)throw new v("想定されない状況",t,t.costInfo);const a=i.actions.find(r=>r.playType==="CardActivation");if(!a)throw new v("想定されない状況",t,t.costInfo,i);return await a.prepare(t.activator,void 0,void 0,e,!1,!0)},execute:async(t,e)=>{var n;const i=(n=t.costInfo.banish)==null?void 0:n.find(r=>r!==t.action.entity);if(!i)throw new v("想定されない状況",t,t.costInfo);const a=i.actions.find(r=>r.playType==="CardActivation");if(!a)throw new v("想定されない状況",t,t.costInfo,i);return await a.execute(t,e)},settle:async()=>!0}]}}const Di=Object.freeze(Object.defineProperty({__proto__:null,default:pr},Symbol.toStringTag,{value:"Module"}));function*fr(){for(const t of["メタルフォーゼ・ゴルドライバー","メタルフォーゼ・シルバード","メタルフォーゼ・スティエレン","メタルフォーゼ・ヴォルフレイム"])yield{name:t,actions:[T,E,_,P,ee,{title:"①サーチ",isMandatory:!1,playType:"IgnitionEffect",spellSpeed:"Normal",executableCells:["SpellAndTrapZone"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],isOnlyNTimesPerTurnIfFaceup:1,...X(e=>{let i=e.activator.getEntiteisOnField().filter(a=>a.face==="FaceUp").filter(a=>a.canBeTargetOfEffect(e)).filter(a=>a!==e.action.entity);return e.activator.getAvailableSpellTrapZones.length||(i=i.filter(a=>a.fieldCell.cellType==="SpellAndTrapZone")),i},{message:"破壊するカードを選択。",destoryTargets:!0,canExecute:e=>e.activator.canSet&&e.activator.getDeckCell().cardEntities.filter(i=>i.kind==="Spell"||i.kind==="Trap").some(i=>{var a;return(a=i.status.nameTags)==null?void 0:a.includes("メタルフォーゼ")})}),execute:async e=>{if(!(await m.tryDestroy(e.selectedEntities,e)).length||!e.activator.canSet)return!1;const a=e.activator.getAvailableSpellTrapZones();if(!a.length)return!1;const n=e.activator.getDeckCell().cardEntities.filter(l=>l.kind==="Spell"||l.kind==="Trap").filter(l=>{var u;return(u=l.status.nameTags)==null?void 0:u.includes("メタルフォーゼ")});if(!n.length)return!1;const r=await e.activator.waitSelectEntity(n,"セットするカードを選択。",!1);if(!r)return!1;const s=await e.activator.duel.view.waitSelectDestination(e.activator,r,a,"セットする先を選択","セット",!1);if(!s)throw new F("セット先選択",e);return await r.setAsSpellTrap(s,r.kind,["Effect"],e.action.entity,e.activator),!0},settle:async()=>!0}]}}const Pi=Object.freeze(Object.defineProperty({__proto__:null,default:fr},Symbol.toStringTag,{value:"Module"}));function*hr(){yield{name:"錬装融合",actions:[{title:"発動",isMandatory:!1,playType:"CardActivation",spellSpeed:"Normal",executableCells:["Hand","SpellAndTrapZone"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],...dt(["ExtraDeck"],t=>{var e;return!!((e=t.status.nameTags)!=null&&e.includes("メタルフォーゼ"))},["Hand","MonsterZone","ExtraMonsterZone"],()=>!0,"Graveyard")},{title:"②ドロー",isMandatory:!1,playType:"IgnitionEffect",spellSpeed:"Normal",executableCells:["Graveyard"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],isOnlyNTimesPerTurn:1,canExecute:t=>t.activator.getDeckCell().cardEntities.length>0&&t.activator.canDraw,prepare:async t=>(await t.action.entity.returnToDeck("Random",["Effect"],t.action.entity,t.activator),{selectedEntities:[],chainBlockTags:["Draw"],prepared:void 0}),execute:async t=>(await t.activator.draw(1,t.action.entity,t.activator),!0),settle:async()=>!0},C]}}const Mi=Object.freeze(Object.defineProperty({__proto__:null,default:hr},Symbol.toStringTag,{value:"Module"}));function*gr(){yield{name:"ダーク・リゾネーター",actions:[T,E,_,P],substituteEffects:[kn(1)]},yield{name:"レッド・リゾネーター",actions:[T,E,_,P,{title:"①特殊召喚",isMandatory:!1,playType:"TriggerEffect",spellSpeed:"Normal",executableCells:["MonsterZone"],executablePeriods:[...D,...N],executableDuelistTypes:["Controller"],meetsConditions:t=>t.action.entity.hasBeenSummonedNow(["NormalSummon"]),canExecute:t=>{const e=t.activator.getMonsterZones();return t.activator.getEnableSummonList(t.activator,"SpecialSummon",["Effect"],t.action,t.activator.getHandCell().cardEntities.filter(a=>a.kind==="Monster").filter(a=>(a.lvl??12)<5).map(a=>({monster:a,posList:S,cells:e})),[],!1).length>0},prepare:async()=>({selectedEntities:[],chainBlockTags:["SpecialSummonFromHand","IfNormarlSummonSucceed"],prepared:void 0}),execute:async t=>{const e=t.activator.getMonsterZones(),i=t.activator.getHandCell().cardEntities.filter(n=>n.kind==="Monster").filter(n=>(n.lvl??12)<5).map(n=>({monster:n,posList:S,cells:e}));return!!await t.activator.summonOne(t.activator,"SpecialSummon",["Effect"],t.action,i,[],!1,!1)},settle:async()=>!0},{title:"②回復",isMandatory:!1,playType:"TriggerEffect",spellSpeed:"Normal",executableCells:["MonsterZone"],executablePeriods:[...D,...N],executableDuelistTypes:["Controller"],isOnlyNTimesPerTurn:1,meetsConditions:t=>t.action.entity.hasBeenSummonedNow(["SpecialSummon"]),...X(t=>t.activator.getMonstersOnField().filter(e=>e.canBeTargetOfEffect(t)).filter(e=>(e.atk??0)>0).filter(e=>e.info.summonKinds.includes("SpecialSummon")),{message:"対象モンスターを選択。"}),execute:async t=>{const e=t.activator.lp;return t.selectedEntities.filter(i=>i.isOnFieldAsMonsterStrictly).forEach(i=>t.activator.heal(i.atk??0,t.action.entity)),t.activator.lp!==e},settle:async()=>!0}]}}const Ai=Object.freeze(Object.defineProperty({__proto__:null,default:gr},Symbol.toStringTag,{value:"Module"})),_t=(t,e)=>{const i=e?`魔力充填可能(${e})`:"魔力充填可能";return it(i,t,a=>[a],a=>[new V(i,()=>!0,!0,a,{},(n,r)=>n.isSpawnedBy===r,(n,r)=>(r.maxCounterQty.SpellCounter=e??Number.MAX_VALUE,{...r,maxCounterQty:r.maxCounterQty}))])},Ve={},yr=(t,e=1)=>(Ve[e]||(Ve[e]={title:`魔力回収(${e})`,isMandatory:!0,playType:"AfterChainBlock",spellSpeed:"Normal",executableCells:["MonsterZone"],executablePeriods:U,executableDuelistTypes:["Controller"],canExecute:i=>!!(i.targetChainBlock&&i.targetChainBlock.action.playType==="CardActivation"&&i.targetChainBlock.action.entity.kind==="Spell"&&i.action.entity.isEffective&&i.action.entity.face==="FaceUp"&&i.action.entity.counterHolder.getQty("SpellCounter")<(i.action.entity.status.maxCounterQty.SpellCounter??0)&&i.action.entity.hadArrivedToFieldAt().totalProcSeq<=i.targetChainBlock.isActivatedAt.totalProcSeq),prepare:q,execute:async i=>i.action.entity.face==="FaceDown"||!i.action.entity.isOnFieldAsMonsterStrictly||!i.action.entity.isEffective?!1:(i.action.entity.counterHolder.add("SpellCounter",e,i.action.entity),!0),settle:async()=>!0}),{...Ve[e],title:`${t}魔力回収(${e})`}),Je=(t,e,i)=>t.action.entity.counterHolder.getQty("SpellCounter")>=i,Ye=(t,e,i,a)=>{const n=a[0];return t.action.entity.counterHolder.remove("SpellCounter",n),{counter:n}};function*mr(){yield{name:"魔導戦士 ブレイカー",actions:[T,E,_,P,{title:"①魔力充填",isMandatory:!0,playType:"TriggerEffect",spellSpeed:"Normal",executableCells:["MonsterZone"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],meetsConditions:t=>t.action.entity.hasBeenSummonedNow(["NormalSummon"]),prepare:async()=>({selectedEntities:[],chainBlockTags:["IfNormarlSummonSucceed"],prepared:void 0}),execute:async t=>t.action.entity.face==="FaceDown"?!1:(t.action.entity.counterHolder.setQty("SpellCounter",1,t.action.entity),!0),settle:async()=>!0},{title:"③マナブレイク",isMandatory:!1,playType:"IgnitionEffect",spellSpeed:"Normal",executableCells:["MonsterZone"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],canPayCosts:(t,e)=>Je(t,e,1),payCosts:async(t,e,i)=>Ye(t,e,i,[1]),...X(t=>t.action.entity.field.getCells(...ye).flatMap(e=>e.cardEntities).filter(e=>e.canBeTargetOfEffect(t)),{message:"破壊する対象を選択。",destoryTargets:!0}),execute:async t=>t.selectedEntities.every(e=>!e.isOnFieldAsSpellTrapStrictly)?!1:(await m.tryDestroy(t.selectedEntities,t),!0),settle:async()=>!0}],continuousEffects:[_t("Monster",1),Te("②攻撃力上昇","Monster",t=>[t],t=>[H.createContinuous("②攻撃力上昇",()=>!0,t,()=>!0,"attack","wip","Addition",(e,i,a)=>e.isEffective?a+e.counterHolder.getQty("SpellCounter")*300:a)])]},yield{name:"王立魔法図書館",actions:[T,E,_,P,{...yr("①",1)},{title:"②ドロー",isMandatory:!1,playType:"IgnitionEffect",spellSpeed:"Normal",executableCells:["MonsterZone"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],canPayCosts:(t,e)=>Je(t,e,3),canExecute:t=>t.activator.getDeckCell().cardEntities.length>0,payCosts:async(t,e,i)=>Ye(t,e,i,[3]),prepare:q,execute:async t=>(await t.activator.draw(1,t.action.entity,t.activator),!0),settle:async()=>!0}],continuousEffects:[_t("Monster",3)]}}const xi=Object.freeze(Object.defineProperty({__proto__:null,canPaySpellCounters:Je,default:mr,paySpellCounters:Ye},Symbol.toStringTag,{value:"Module"}));function*vr(){yield{name:"スターダスト・ドラゴン",actions:[T,E,_,Q(),{title:"①ヴィクテム・サンクチュアリ",isMandatory:!1,playType:"QuickEffect",spellSpeed:"Quick",executableCells:["MonsterZone","ExtraMonsterZone"],executablePeriods:U,executableDuelistTypes:["Controller"],canPayCosts:lt,canExecute:t=>!!(t.targetChainBlock&&t.targetChainBlock.action.isWithChainBlock&&t.targetChainBlock.chainBlockTags.includes("DestroyOnField")),payCosts:ct,prepare:async t=>{if(!t.targetChainBlock)throw new v("想定されない状態",t);return{selectedEntities:[],chainBlockTags:t.action.calcChainBlockTagsForDestroy(t.activator,[t.targetChainBlock.action.entity]),prepared:void 0}},execute:async(t,e)=>{const i=e[t.index-1];return i.isNegatedActivationBy=t.action,await m.tryDestroy([i.action.entity],t),!0},settle:async()=>!0},{title:"②自己再生",playType:"IgnitionEffect",isMandatory:!1,spellSpeed:"Normal",executableCells:["Graveyard"],executablePeriods:["end"],executableDuelistTypes:["Controller"],canExecute:t=>{const e=t.action.entity.moveLog.latestRecord;if(e.movedBy!==t.action.entity||!t.activator.duel.clock.isSameTurn(e.movedAt)||!e.movedAs.includes("Cost"))return!1;const i=t.activator.duel,a=t.action.entity.actionLogRecords.filter(n=>i.clock.isSameTurn(n.clock)).map(n=>n.chainBlockInfo).findLast(n=>n.action.title==="①ヴィクテム・サンクチュアリ");return!a||a.state!=="done"?!1:j(t,S,[],["Effect"])},prepare:q,execute:t=>se(t),settle:async()=>!0}]},yield{name:"閃珖竜 スターダスト",actions:[T,E,Q(),{title:"波動音壁",isMandatory:!1,playType:"QuickEffect",spellSpeed:"Quick",executableCells:R,executablePeriods:D,executableDuelistTypes:["Controller"],isOnlyNTimesPerTurnIfFaceup:1,...X(t=>t.activator.getEntiteisOnField().filter(e=>e.face==="FaceUp").filter(e=>e.canBeTargetOfEffect(t))),execute:async t=>(t.selectedEntities.filter(e=>e.isOnFieldStrictly).filter(e=>e.face==="FaceUp").filter(e=>e.canBeEffected(t.activator,t.action.entity,t.action)).forEach(e=>{e.counterHolder.add("SonicBarrier",1,t.action.entity)}),!0),settle:async()=>!0}],substituteEffects:[{title:"波動音壁（適用）",isMandatory:!0,executableCells:I,executablePeriods:U,executableDuelistTypes:["Controller"],isApplicableTo:(t,e,i)=>i.filter(a=>a.counterHolder.getQty("SonicBarrier",t.entity)>0),substitute:async(t,e,i)=>{const a=i.filter(n=>n.counterHolder.getQty("SonicBarrier",t.entity)>0);return a.forEach(n=>{n.counterHolder.removeAll("SonicBarrier",t.entity),t.entity.controller.writeInfoLog(`波動音壁により${n.toString()}は１ターンに１度だけ戦闘効果では破壊されない。`)}),a}}]},yield{name:"真閃珖竜 スターダスト・クロニクル",actions:[T,E,Q(t=>t.length===1&&t.every(e=>{var i;return(i=e.status.monsterCategories)==null?void 0:i.includes("Syncro")}),t=>t.length>0&&t.every(e=>{var i;return(i=e.status.monsterCategories)==null?void 0:i.includes("Syncro")})),{title:"波動護魂",isMandatory:!1,playType:"QuickEffect",spellSpeed:"Quick",executableCells:R,executablePeriods:D,executableDuelistTypes:["Controller"],isOnlyNTimesPerTurnIfFaceup:1,canPayCosts:t=>rn(t,t.activator.getGraveyard().cardEntities.filter(e=>{var i;return(i=e.status.monsterCategories)==null?void 0:i.includes("Syncro")})),payCosts:t=>sn(t,t.activator.getGraveyard().cardEntities.filter(e=>{var i;return(i=e.status.monsterCategories)==null?void 0:i.includes("Syncro")}),e=>e.length===1,1),prepare:q,execute:async t=>(t.action.entity.procFilterBundle.push(me.createLingering(t.action.title,e=>e.effectOwner.duel.clock.isSameTurn(e.isSpawnedAt),t.action.entity,t.action,()=>!0,["Effect"],()=>!1)),!0),settle:async()=>!0},{title:"②蘇生",isMandatory:!1,playType:"TriggerEffect",spellSpeed:"Normal",executableCells:["Banished"],executablePeriods:[...D,...N],executableDuelistTypes:["Controller"],meetsConditions:t=>t.action.entity.wasMovedAtPreviousChain&&t.action.entity.moveLog.latestRecord.actionOwner!==t.activator&&(t.action.entity.wasMovedFrom.owner===t.activator||t.action.entity.wasMovedFrom.cellType==="ExtraMonsterZone"),canExecute:t=>{const e=t.activator.getMonsterZones();return t.activator.getEnableSummonList(t.activator,"SpecialSummon",["Effect"],t.action,t.activator.getBanished().cardEntities.filter(a=>a.kind==="Monster").filter(a=>a.face==="FaceUp").filter(a=>a.types.includes("Dragon")).filter(a=>{var n;return(n=a.status.monsterCategories)==null?void 0:n.includes("Syncro")}).filter(a=>a.canBeTargetOfEffect(t)).map(a=>({monster:a,posList:S,cells:e})),[],!1).length>0},prepare:t=>le(t,t.activator.getBanished().cardEntities.filter(e=>e.kind==="Monster").filter(e=>e.face==="FaceUp").filter(e=>e.types.includes("Dragon")).filter(e=>{var i;return(i=e.status.monsterCategories)==null?void 0:i.includes("Syncro")}).filter(e=>e.canBeTargetOfEffect(t))),execute:async t=>ce(t),settle:async()=>!0}]},yield{name:"聖珖神竜 スターダスト・シフル",actions:[T,E,Q(t=>t.length===1&&t.every(e=>{var i;return(i=e.status.monsterCategories)==null?void 0:i.includes("Syncro")}),t=>t.length>1&&t.every(e=>{var i;return(i=e.status.monsterCategories)==null?void 0:i.includes("Syncro")})),{title:"②珖波動反撃",isMandatory:!1,playType:"QuickEffect",spellSpeed:"Quick",executableCells:["Hand"],executablePeriods:D,executableDuelistTypes:["Controller"],isOnlyNTimesPerTurnIfFaceup:1,negatePreviousBlock:!0,canExecute:t=>!!(t.targetChainBlock&&t.targetChainBlock.action.entity.kind==="Monster"&&t.targetChainBlock.action.isWithChainBlock&&t.activator!==t.targetChainBlock.activator),prepare:async()=>({selectedEntities:[],chainBlockTags:["NegateCardEffect","DestroyOnField"],prepared:void 0}),execute:async t=>{if(!t.targetChainBlock)return!1;const e=t.targetChainBlock;e.isNegatedEffectBy=t.action;const i=await t.activator.waitSelectEntity(t.action.duel.field.getCardsOnFieldStrictly(),"破壊するカードを選択。",!1);return(await m.tryDestroy(i?[i]:[],t)).length>0},settle:async()=>!0},{title:"③蘇生",isMandatory:!1,playType:"IgnitionEffect",spellSpeed:"Normal",executableCells:["Graveyard"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],priorityForNPC:10,canPayCosts:ke,canExecute:t=>{const e=t.activator.getMonsterZones();return t.activator.getEnableSummonList(t.activator,"SpecialSummon",["Effect"],t.action,t.activator.getGraveyard().cardEntities.filter(a=>{var n;return(n=a.status.nameTags)==null?void 0:n.includes("スターダスト")}).filter(a=>(a.lvl??12)<9).filter(a=>a.canBeTargetOfEffect(t)).map(a=>({monster:a,posList:S,cells:e})),[],!1).length>0},payCosts:Re,prepare:t=>le(t,t.activator.getGraveyard().cardEntities.filter(e=>{var i;return(i=e.status.nameTags)==null?void 0:i.includes("スターダスト")}).filter(e=>(e.lvl??12)<9),S,e=>e.length===1),execute:t=>ce(t,S),settle:async()=>!0}],substituteEffects:[{title:"波動聖句",isMandatory:!0,executableCells:["MonsterZone"],executablePeriods:U,executableDuelistTypes:["Controller"],isApplicableTo:(t,e,i)=>i.filter(a=>a.controller===t.entity.controller).filter(a=>a.counterHolder.getQty("SonicVerse",t.entity)===0),substitute:async(t,e,i)=>{if(!t.entity.isEffective)return[];const a=i.filter(n=>n.controller===t.entity.controller).filter(n=>n.counterHolder.getQty("SonicVerse",t.entity)===0);return a.forEach(n=>{n.counterHolder.add("SonicVerse",1,t.entity),t.entity.controller.writeInfoLog(`${t.entity.toString()}の効果により${n.toString()}は１ターンに１度だけ破壊されない。`)}),a}}]}}const Fi=Object.freeze(Object.defineProperty({__proto__:null,default:vr},Symbol.toStringTag,{value:"Module"}));function*Sr(){yield{name:"調律",actions:[{title:"発動",isMandatory:!1,playType:"CardActivation",spellSpeed:"Normal",executableCells:["Hand","SpellAndTrapZone"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],priorityForNPC:40,canExecute:t=>{const e=t.activator.getDeckCell().cardEntities;return e.length<2?!1:e.filter(i=>{var a;return(a=i.status.nameTags)==null?void 0:a.includes("シンクロン")}).some(i=>{var a;return(a=i.status.monsterCategories)==null?void 0:a.includes("Tuner")})},prepare:async()=>({selectedEntities:[],chainBlockTags:["SearchFromDeck","SendToGraveyardFromDeck"],prepared:void 0}),execute:async t=>{const e=t.activator.getDeckCell().cardEntities;if(e.length<2)return!1;const i=e.filter(n=>{var r;return(r=n.status.nameTags)==null?void 0:r.includes("シンクロン")}).filter(n=>{var r;return(r=n.status.monsterCategories)==null?void 0:r.includes("Tuner")});if(i.length===0)return!1;const a=await t.activator.waitSelectEntity(i,"手札に加えるモンスターを選択",!1);if(!a)throw new F(t);return await a.addToHand(["Effect"],t.action.entity,t.activator),t.activator.getDeckCell().shuffle(),t.activator.duel.clock.incrementProcSeq(),await t.activator.getDeckCell().cardEntities[0].sendToGraveyard(["Effect"],t.action.entity,t.activator),!0},settle:async()=>!0},C]}}const Ni=Object.freeze(Object.defineProperty({__proto__:null,default:Sr},Symbol.toStringTag,{value:"Module"}));function*Cr(){yield{name:"フォーミュラ・シンクロン",actions:[T,E,_,Q(),{title:"①ドロー",isMandatory:!1,playType:"TriggerEffect",spellSpeed:"Normal",executableCells:R,executablePeriods:[...D,...N],executableDuelistTypes:["Controller"],meetsConditions:t=>t.action.entity.hasBeenSummonedJustNow(["SyncroSummon"]),canExecute:t=>t.activator.canDraw&&t.activator.getDeckCell().cardEntities.length>0,prepare:async()=>({selectedEntities:[],chainBlockTags:["Draw"],prepared:void 0}),execute:async t=>(await t.activator.draw(1,t.action.entity,t.activator),!0),settle:async()=>!0},It({title:"②シンクロ召喚",isOnlyNTimesPerChain:1})]}}const Bi=Object.freeze(Object.defineProperty({__proto__:null,default:Cr},Symbol.toStringTag,{value:"Module"}));function*Tr(){yield{name:"トゥーン・ワールド",actions:[{...ee,canPayCosts:t=>t.activator.lp>=1e3,payCosts:(t,e)=>_e(t,e,1e3)},C]}}const Oi=Object.freeze(Object.defineProperty({__proto__:null,default:Tr},Symbol.toStringTag,{value:"Module"}));function*Er(){yield{name:"無の煉獄",actions:[{title:"発動",isMandatory:!1,playType:"CardActivation",spellSpeed:"Normal",executableCells:["Hand","SpellAndTrapZone"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],meetsConditions:t=>t.activator.getHandCell().cardEntities.length>2,canExecute:t=>t.activator.canDraw&&t.activator.status.canDiscardAsEffect&&t.activator.getDeckCell().cardEntities.length>0,prepare:async()=>({selectedEntities:[],chainBlockTags:["Draw","DiscordAsEffect"],prepared:void 0}),execute:async t=>(await t.activator.draw(1,t.action.entity,t.activator),t.activator.entity.counterHolder.add("IntoTheVoid",1,t.action.entity),!0),settle:async()=>!0},{title:"手札抹殺",isMandatory:!0,playType:"LingeringEffect",spellSpeed:"Normal",executableCells:I,executablePeriods:["end"],executableDuelistTypes:Ee,meetsConditions:t=>t.activator.entity.counterHolder.getQty("IntoTheVoid",t.action.entity)>0,prepare:q,execute:async t=>(await m.discardManyForTheSameReason(t.activator.getHandCell().cardEntities,["Effect"],t.action.entity,t.activator),t.activator.entity.counterHolder.remove("IntoTheVoid",1,t.action.entity),!0),settle:async()=>!0},C]}}const Li=Object.freeze(Object.defineProperty({__proto__:null,default:Er},Symbol.toStringTag,{value:"Module"}));function*_r(){yield{name:"星杯の妖精リース",actions:[T,E,_,P,{title:"①サーチ",isMandatory:!1,playType:"TriggerEffect",spellSpeed:"Normal",executableCells:["MonsterZone"],executablePeriods:[...D,...N],executableDuelistTypes:["Controller"],isOnlyNTimesPerTurn:1,meetsConditions:t=>t.action.entity.hasBeenSummonedNow(["NormalSummon","SpecialSummon"]),canExecute:t=>t.activator.canAddToHandFromDeck&&t.activator.getDeckCell().cardEntities.filter(e=>e.kind==="Monster").some(e=>{var i;return(i=e.status.nameTags)==null?void 0:i.includes("星杯")}),prepare:async()=>({selectedEntities:[],chainBlockTags:["SearchFromDeck"],prepared:void 0}),execute:async t=>{const e=t.activator.getDeckCell().cardEntities.filter(a=>a.kind==="Monster").filter(a=>{var n;return(n=a.status.nameTags)==null?void 0:n.includes("星杯")});if(e.length===0)return!1;const i=await t.activator.waitSelectEntity(e,"手札に加えるモンスターを選択",!1);if(!i)throw new v("想定されない状態",t);return await i.addToHand(["Effect"],t.action.entity,t.activator),!0},settle:async()=>!0},{title:"②自己サルベージ",isMandatory:!1,playType:"IgnitionEffect",spellSpeed:"Normal",executableCells:["Graveyard"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],isOnlyNTimesPerTurn:1,canPayCosts:t=>[...t.activator.getMonstersOnField(),...t.activator.getHandCell().cardEntities.filter(e=>e.kind==="Monster")].some(e=>e.canBeSentToGraveyard(t.activator,t.action.entity,"SendToGraveyardAsCost",t.action)),payCosts:async t=>{const e=[...t.activator.getMonstersOnField(),...t.activator.getHandCell().cardEntities.filter(a=>a.kind==="Monster")].filter(a=>a.canBeSentToGraveyard(t.activator,t.action.entity,"SendToGraveyardAsCost",t.action)),i=await t.activator.waitSelectEntity(e,"墓地に送るモンスターを選択。",!0);if(i)return await i.sendToGraveyard(["Cost"],t.action.entity,t.activator),{sendToGraveyard:[i]}},prepare:async()=>({selectedEntities:[],chainBlockTags:["SearchFromDeck"],prepared:void 0}),execute:async t=>t.action.entity.wasMovedAfter(t.isActivatedAt)?!1:(await t.action.entity.addToHand(["Effect"],t.action.entity,t.activator),!0),settle:async()=>!0}]},yield{name:"星遺物－『星杯』",actions:[T,E,_,P,{title:"①墓地送り",isMandatory:!1,playType:"TriggerEffect",spellSpeed:"Normal",executableCells:["MonsterZone"],executablePeriods:[...D,...N],executableDuelistTypes:["Controller"],canPayCosts:lt,canExecute:t=>t.activator.duel.field.moveLog.getPriviousChainLog().filter(e=>e.movedAs.includes("SpecialSummon")).map(e=>e.entity).some(e=>e.wasMovedFrom.cellType==="ExtraDeck"),payCosts:ct,prepare:q,execute:async t=>{const e=t.activator.duel.field.moveLog.getPriviousChainLog().filter(i=>i.movedAs.includes("SpecialSummon")).map(i=>i.entity).filter(i=>i.wasMovedFrom.cellType==="ExtraDeck").filter(i=>i.isOnFieldAsMonsterStrictly).filter(i=>i.canBeEffected(t.activator,t.action.entity,t.action)).toArray();return await m.sendManyToGraveyardForTheSameReason(e,["Effect"],t.action.entity,t.activator),!0},settle:async()=>!0},{title:"②リクルート",isMandatory:!1,playType:"TriggerEffect",spellSpeed:"Normal",executableCells:["Hand","Graveyard","Banished"],executablePeriods:[...D,...N],executableDuelistTypes:["Controller"],meetsConditions:t=>t.action.entity.wasMovedAtPreviousChain&&t.action.entity.info.summonKinds.includes("NormalSummon")&&t.action.entity.moveLog.previousPlaceRecord.face==="FaceUp",canExecute:t=>{const e=t.activator.getDeckCell().cardEntities.filter(n=>n.kind==="Monster").filter(n=>{var r;return(r=n.status.nameTags)==null?void 0:r.includes("星杯")}).filter(n=>n.nm!=="星遺物－『星杯』"),i=t.activator.getMonsterZones();return t.activator.getEnableSummonList(t.activator,"SpecialSummon",["Effect"],t.action,e.map(n=>({monster:n,cells:i,posList:S})),[],!1).length>1},prepare:q,execute:async t=>{const e=t.activator.getDeckCell().cardEntities.filter(n=>n.kind==="Monster").filter(n=>{var r;return(r=n.status.nameTags)==null?void 0:r.includes("星杯")}).filter(n=>n.nm!=="星遺物－『星杯』"),i=t.activator.getMonsterZones();return(await t.activator.summonMany(t.activator,"SpecialSummon",["Effect"],t.action,e.map(n=>({monster:n,cells:i,posList:S})),[],!1,2,n=>n.length==2,!1)??[]).length==2},settle:async()=>!0},{title:"③サーチ",isMandatory:!1,playType:"IgnitionEffect",spellSpeed:"Normal",executableCells:["Graveyard"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],canPayCosts:ke,meetsConditions:t=>!t.action.entity.wasMovedAtCurrentTurn,canExecute:t=>t.activator.canAddToHandFromDeck&&t.activator.getDeckCell().cardEntities.filter(e=>{var i;return(i=e.status.nameTags)==null?void 0:i.includes("星遺物")}).length>0,payCosts:Re,prepare:async()=>({selectedEntities:[],chainBlockTags:["SearchFromDeck"],prepared:void 0}),execute:async t=>{const e=await t.activator.waitSelectEntity(t.activator.getDeckCell().cardEntities.filter(i=>{var a;return(a=i.status.nameTags)==null?void 0:a.includes("星遺物")}),"手札に加えるカードを選択",!1);return e?(await e.addToHand(["Effect"],t.action.entity,t.activator),!0):!1},settle:async()=>!0}]}}const qi=Object.freeze(Object.defineProperty({__proto__:null,default:_r},Symbol.toStringTag,{value:"Module"}));function*kr(){yield{name:"ドットスケーパー",actions:[T,E,P,_,{title:"①自己再生",isMandatory:!1,playType:"TriggerEffect",spellSpeed:"Normal",executableCells:["Graveyard"],executablePeriods:[...D,...N],executableDuelistTypes:["Controller"],isOnlyNTimesPerDuel:1,actionGroupName:"ドットスケーパー",meetsConditions:t=>t.action.entity.wasMovedAtPreviousChain&&t.action.entity.wasMovedFrom.cellType!=="Banished",canExecute:t=>j(t,S,[],["Effect"]),prepare:async()=>({selectedEntities:[],chainBlockTags:["SpecialSummonFromGraveyard"],prepared:void 0}),execute:t=>se(t),settle:async()=>!0},{title:"②自己帰還",isMandatory:!1,playType:"TriggerEffect",spellSpeed:"Normal",executableCells:["Banished"],executablePeriods:[...D,...N],executableDuelistTypes:["Controller"],isOnlyNTimesPerDuel:1,actionGroupName:"ドットスケーパー",meetsConditions:t=>t.action.entity.wasMovedAtPreviousChain,canExecute:t=>j(t,S,[],["Effect"]),prepare:async()=>({selectedEntities:[],chainBlockTags:["SpecialSummonFromBanished"],prepared:void 0}),execute:t=>se(t),settle:async()=>!0}]}}const Ri=Object.freeze(Object.defineProperty({__proto__:null,default:kr},Symbol.toStringTag,{value:"Module"}));function*wr(){yield{name:"ゼラの天使",actions:[T,E,_,Q(),{title:"②自己帰還",isMandatory:!0,playType:"IgnitionEffect",spellSpeed:"Normal",executableCells:["Banished"],executablePeriods:["stanby"],executableDuelistTypes:["Controller"],meetsConditions:t=>t.action.entity.wasMovedAtPreviousTurn,canExecute:t=>j(t,S,[],["Effect"]),prepare:async()=>({selectedEntities:[],chainBlockTags:["SpecialSummonFromBanished"],prepared:void 0}),execute:t=>se(t),settle:async()=>!0}],continuousEffects:[Te("②攻撃力上昇","Monster",t=>[t],t=>[H.createContinuous("①攻撃力上昇",()=>!0,t,()=>!0,"attack","wip","Addition",(e,i,a)=>e.isEffective?a+e.controller.getOpponentPlayer().getBanished().cardEntities.length*100:a)])]}}const Hi=Object.freeze(Object.defineProperty({__proto__:null,default:wr},Symbol.toStringTag,{value:"Module"}));function*br(){yield{name:"死霊騎士デスカリバー・ナイト",actions:[T,E,P,_,{title:"①モンスター効果無効",isMandatory:!0,playType:"TriggerEffect",spellSpeed:"Quick",executableCells:R,executablePeriods:[...D,...N],executableDuelistTypes:["Controller"],negatePreviousBlock:!0,canPayCosts:lt,canExecute:t=>!!(t.targetChainBlock&&t.targetChainBlock.action.entity.kind==="Monster"&&t.targetChainBlock.action.isWithChainBlock),payCosts:ct,prepare:async(t,e)=>{const i=t.targetChainBlock,a=e[t.index-1];return i!==a?{selectedEntities:[],chainBlockTags:[],prepared:void 0}:{selectedEntities:[],chainBlockTags:["NegateCardEffect",...t.action.calcChainBlockTagsForDestroy(t.activator,[i.action.entity])],prepared:void 0}},execute:async(t,e)=>{const i=e.find(n=>n.action.entity.kind!=="Monster"&&n.action.isWithChainBlock),a=e[t.index-1];return a!==i?!1:(a.isNegatedActivationBy=t.action,await m.tryDestroy([a.action.entity],t),!0)},settle:async()=>!0}]}}const Zi=Object.freeze(Object.defineProperty({__proto__:null,default:br},Symbol.toStringTag,{value:"Module"}));function*Dr(){yield{name:"召喚僧サモンプリースト",actions:[T,E,P,_,{title:"①表示形式変更",isMandatory:!0,playType:"TriggerEffect",spellSpeed:"Normal",executableCells:["MonsterZone"],executablePeriods:[...D,...N],executableDuelistTypes:["Controller"],meetsConditions:t=>t.action.entity.hasBeenSummonedNow(["NormalSummon","FlipSummon"]),prepare:async()=>({selectedEntities:[],chainBlockTags:["IfNormarlSummonSucceed"],prepared:void 0}),execute:async t=>t.action.entity.battlePosition!=="Attack"||!t.action.entity.isOnFieldAsMonsterStrictly?!1:(await t.action.entity.setBattlePosition("Defense",["Effect"],t.action.entity,t.activator),!0),settle:async()=>!0},{title:"③リクルート",isMandatory:!1,playType:"IgnitionEffect",spellSpeed:"Normal",executableCells:["MonsterZone"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],isOnlyNTimesPerTurnIfFaceup:1,canPayCosts:t=>t.activator.status.canDiscardAsCost?t.activator.getHandCell().cardEntities.some(e=>e.kind==="Spell"):!1,canExecute:t=>{const e=t.activator.getDeckCell().cardEntities.filter(n=>n.kind==="Monster").filter(n=>n.lvl===4),i=t.activator.getMonsterZones();return t.activator.getEnableSummonList(t.activator,"SpecialSummon",["Effect"],t.action,e.map(n=>({monster:n,posList:S,cells:i})),[],!1).length>0},payCosts:async(t,e,i)=>{const a=t.activator.getHandCell().cardEntities.filter(r=>r.kind==="Spell"),n=await t.activator.waitSelectEntity(a,"手札コストを選択",i);if(!n&&!i)throw new F(t);if(n)return await n.discard(["Cost"],t.action.entity,t.activator),{discard:[n]}},prepare:async()=>({selectedEntities:[],chainBlockTags:["SpecialSummonFromDeck"],prepared:void 0}),execute:async t=>{const e=t.activator.getDeckCell().cardEntities.filter(n=>n.lvl===4),i=t.activator.getMonsterZones(),a=await t.activator.summonOne(t.activator,"SpecialSummon",["Effect"],t.action,e.map(n=>({monster:n,posList:S,cells:i})),[],!1,!1);return a?(a.statusOperatorBundle.push(new V("攻撃不可",n=>n.effectOwner.duel.clock.isSameTurn(n.isSpawnedAt),!1,t.action.entity,t.action,()=>!0,(n,r)=>({...r,canAttack:!1}))),!!a):!1},settle:async()=>!0}],continuousEffects:[Lt("②リリース不可","Monster",t=>[t],t=>[new me("②リリース不可",()=>!0,!0,t,{},()=>!0,["AdvanceSummonRelease","ReleaseAsEffect","ReleaseAsCost"],()=>!1)])]}}const $i=Object.freeze(Object.defineProperty({__proto__:null,default:Dr},Symbol.toStringTag,{value:"Module"}));function*Pr(){yield{name:"アンカモフライト",actions:[T,E,_,ee,{title:"特殊召喚",isMandatory:!1,playType:"SpecialSummon",spellSpeed:"Normal",executableCells:["ExtraDeck"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],isOnlyNTimesPerDuel:1,meetsConditions:t=>t.activator.getExtraDeck().cardEntities.every(e=>e.nm==="アンカモフライト"),canExecute:t=>t.action.entity.face==="FaceUp"&&j(t,S,[],["Rule"]),getDests:t=>J(t,S,[],["Rule"]),prepare:t=>te(t,"SpecialSummon",["SpecialSummon","Rule"],S),execute:ie,settle:async()=>!0},{title:"①ドロー",isMandatory:!1,playType:"IgnitionEffect",spellSpeed:"Normal",executableCells:["SpellAndTrapZone"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],priorityForNPC:20,isOnlyNTimesPerTurn:1,meetsConditions:t=>t.activator.getExtraDeck().cardEntities.every(e=>e.nm==="アンカモフライト"),canExecute:t=>t.activator.getDeckCell().cardEntities.length>0&&t.activator.canDraw,prepare:async()=>({selectedEntities:[],chainBlockTags:["DestroySpellTrapOnField","Draw"],prepared:void 0}),execute:async t=>(await m.tryDestroy([t.action.entity],t)).length?(t.action.entity.field.duel.clock.incrementProcSeq(),await t.activator.draw(1,t.action.entity,t.activator),!0):!1,settle:async()=>!0}],summonFilter:(t,e,i,a,n,r,s,l,u,c)=>{const d={posList:u,cells:c},p={posList:[],cells:[]};return s!==e||r.entity===e?d:p},continuousEffects:[it("除外予定","Monster",t=>[t],t=>[new V("除外予定",()=>!0,!0,t,{},(e,i)=>i.isOnFieldAsMonsterStrictly&&i.face==="FaceUp",(e,i)=>({...i,willBeBanished:!0}))])]}}const Gi=Object.freeze(Object.defineProperty({__proto__:null,default:Pr},Symbol.toStringTag,{value:"Module"}));function*Mr(){yield{name:"エキセントリック・ボーイ",actions:[T,E,P,_],summonFilter:(t,e,i,a,n,r,s,l,u,c)=>{const d={posList:u,cells:c},p={posList:[],cells:[]};if(!n.includes("SyncroSummon"))return d;const f=l.find(g=>g.material===t.isSpawnedBy);return f?!f.cell.isMonsterZoneLikeCell||l.length!==2?p:l.filter(g=>g!==f).every(g=>g.cell.cellType==="Hand")?d:p:d},defaultStatus:{allowHandSyncro:!0},onUsedAsMaterial:(t,e)=>{e.info.summonKinds.includes("SyncroSummon")&&(t.action.entity.statusOperatorBundle.push(new V("除外予定",()=>!0,!1,t.action.entity,t.action,(i,a)=>a.isOnFieldAsMonsterStrictly&&a.face==="FaceUp",(i,a)=>({...a,willBeBanished:!0}))),e.info.isEffectiveIn=e.info.isEffectiveIn.filter(i=>i!=="ExtraMonsterZone").filter(i=>i!=="MonsterZone"))}}}const ji=Object.freeze(Object.defineProperty({__proto__:null,default:Mr},Symbol.toStringTag,{value:"Module"})),Ar={title:"ペンデュラム召喚",isMandatory:!1,playType:"SpecialSummon",spellSpeed:"Normal",executableCells:["Hand"],executablePeriods:["main1","main2"],executableDuelistTypes:["Controller"],isOnlyNTimesPerTurn:1,canExecute:t=>{const e=t.activator.getPendulumScales();if(!e||e.upperBound-e.lowerBound<2)return!1;const i=[...t.activator.getHandCell().cardEntities.filter(r=>r.kind==="Monster"),...t.activator.getExtraDeck().cardEntities.filter(r=>r.face==="FaceUp")].filter(r=>r.kind==="Monster").filter(r=>r.lvl&&r.lvl>e.lowerBound).filter(r=>r.lvl&&r.lvl<e.upperBound);if(!i.length)return!1;const a=[...t.activator.getMonsterZones(),...t.activator.getAvailableMonsterZones()];return console.log(...t.activator.getExtraMonsterZones()),console.log(...a),t.activator.getEnableSummonList(t.activator,"PendulumSummon",["Rule"],t.action,i.map(r=>({monster:r,cells:a,posList:S})),[],!1).length>0},prepare:async t=>{const e=t.activator.getPendulumScales();if(!e||e.upperBound-e.lowerBound<2)return;const i=[...t.activator.getHandCell().cardEntities.filter(n=>n.kind==="Monster"),...t.activator.getExtraDeck().cardEntities.filter(n=>n.face==="FaceUp")].filter(n=>n.kind==="Monster").filter(n=>n.lvl&&n.lvl>e.lowerBound).filter(n=>n.lvl&&n.lvl<e.upperBound);if(!i.length)return;const a=[...t.activator.getMonsterZones(),...t.activator.getAvailableExtraMonsterZones()];return await t.activator.summonMany(t.activator,"PendulumSummon",["Rule"],t.action,i.map(n=>({monster:n,posList:S,cells:a})),[],!1,void 0,n=>n.length>0,!1),q()},execute:async t=>(t.activator.getPendingMonstersOnField().forEach(e=>e.determine()),!0),settle:async()=>!0},xr={title:"強制勝利",isMandatory:!0,playType:"IgnitionEffect",spellSpeed:"Normal",executableCells:["Hand"],executablePeriods:["main2"],executableDuelistTypes:["Controller"],isOnlyNTimesPerTurn:1,canExecute:t=>t.activator.duel.clock.turn>1,prepare:async t=>(await m.sendManyToGraveyardForTheSameReason(t.activator.duel.field.getCardsOnFieldStrictly(),["Rule"],t.action.entity,t.activator),{selectedEntities:[],chainBlockTags:[],prepared:void 0,nextChainBlockFilter:()=>!1}),execute:async t=>{const e=[{name:"封印されし者の左足",column:4},{name:"封印されし者の右足",column:2},{name:"封印されし者の左腕",column:5},{name:"封印されし者の右腕",column:1},{name:"封印されしエクゾディア",column:3}];for(const i of e){const a=[t.activator.duel.field.getAllCardEntities().filter(n=>n.owner===t.activator).find(n=>n.origin.name===i.name),t.activator.getOpponentPlayer().getHandCell().cardEntities.find(n=>n.origin.name===i.name)].filter(n=>n!==void 0);if(!a.length)throw new v("想定されない状態",t.activator.getHandCell().cardEntities,i.name);console.log(a),await M.moveMany(a.map(n=>[n,n.controller.getMonsterZones().find(r=>r.column===(n.controller.seat==="Above"?6-i.column:i.column))??n.controller.getFieldZone(),"Monster","FaceUp","Vertical","Top",["Rule"],void 0,void 0,void 0]))}throw new $(t.activator,`${t.activator.getOpponentPlayer().profile.name}がワンターンキルに失敗した。`)},settle:async()=>!0},Fr=t=>{const e=[Ar];return t.profile.npcType==="FtkChallenge"&&e.push(xr),{name:t.profile.name,actions:e,staticInfo:{name:t.profile.name,kind:"Monster",wikiEncodedName:"%A5%D7%A5%EC%A5%A4%A5%E4%A1%BC"}}},Fe=t=>t.type==="Name",Nr=t=>t.type==="Filter",Br=t=>t.type==="Overmuch";function*Or(){const t={...Object.assign({"/src/ygo_entity_proc/card_proc_definitions/CardProcDefinitions_ContinuousSpell.ts":Vt,"/src/ygo_entity_proc/card_proc_definitions/CardProcDefinitions_ContinuousTrap.ts":zt,"/src/ygo_entity_proc/card_proc_definitions/CardProcDefinitions_CounterTrap.ts":Wt,"/src/ygo_entity_proc/card_proc_definitions/CardProcDefinitions_EquipSpell.ts":Qt,"/src/ygo_entity_proc/card_proc_definitions/CardProcDefinitions_EquipSpell_Preset.ts":Xt,"/src/ygo_entity_proc/card_proc_definitions/CardProcDefinitions_FieldSpell.ts":Kt,"/src/ygo_entity_proc/card_proc_definitions/CardProcDefinitions_FieldSpell_Preset.ts":Jt,"/src/ygo_entity_proc/card_proc_definitions/CardProcDefinitions_FusionMonster.ts":ei,"/src/ygo_entity_proc/card_proc_definitions/CardProcDefinitions_LinkMonster.ts":ti,"/src/ygo_entity_proc/card_proc_definitions/CardProcDefinitions_Monster.ts":ii,"/src/ygo_entity_proc/card_proc_definitions/CardProcDefinitions_Monster_Preset_DirectAttacker.ts":ai,"/src/ygo_entity_proc/card_proc_definitions/CardProcDefinitions_Monster_Preset_Recruiter.ts":ni,"/src/ygo_entity_proc/card_proc_definitions/CardProcDefinitions_NormalSpell.ts":ri,"/src/ygo_entity_proc/card_proc_definitions/CardProcDefinitions_NormalSpell_General_Draw.ts":si,"/src/ygo_entity_proc/card_proc_definitions/CardProcDefinitions_NormalSpell_Preset.ts":oi,"/src/ygo_entity_proc/card_proc_definitions/CardProcDefinitions_NormalTrap.ts":li,"/src/ygo_entity_proc/card_proc_definitions/CardProcDefinitions_NormalTrap_UponAttackDeclaration.ts":ci,"/src/ygo_entity_proc/card_proc_definitions/CardProcDefinitions_QuickPlaySpell.ts":ui,"/src/ygo_entity_proc/card_proc_definitions/CardProcDefinitions_RitualSpell.ts":pi,"/src/ygo_entity_proc/card_proc_definitions/CardProcDefinitions_SyncroMonster.ts":fi,"/src/ygo_entity_proc/card_proc_definitions/CardProcDefinitions_TestMonster.ts":hi,"/src/ygo_entity_proc/card_proc_definitions/CardProcDefinitions_XyzMonster.ts":gi}),...Object.assign({"/src/ygo_entity_proc/card_proc_definitions/character_yusei/CardProcDefinitions_Yusei_SyncroTunerMonster.ts":yi,"/src/ygo_entity_proc/card_proc_definitions/support_fusion/CardProcDefinitions_FustionSubstitude_Monster.ts":vi,"/src/ygo_entity_proc/card_proc_definitions/tag_b/CardProcDefinitions_BambooSword_EquipSpell.ts":Si,"/src/ygo_entity_proc/card_proc_definitions/tag_b/CardProcDefinitions_BambooSword_NormalSpell.ts":Ci,"/src/ygo_entity_proc/card_proc_definitions/tag_b/CardProcDefinitions_Blackwing_Monster.ts":Ti,"/src/ygo_entity_proc/card_proc_definitions/tag_c/CardProcDefinitions_Crystron_LinkMonster.ts":Ei,"/src/ygo_entity_proc/card_proc_definitions/tag_e/CardProcDefinitions_Exodia_Monster.ts":_i,"/src/ygo_entity_proc/card_proc_definitions/tag_f/CardProcDefinitions_Firewall_LinkMonster.ts":ki,"/src/ygo_entity_proc/card_proc_definitions/tag_f/CardProcDefinitions_Fusion_NormalSpell.ts":wi,"/src/ygo_entity_proc/card_proc_definitions/tag_i/CardProcDefinitions_Igknight_Monster.ts":bi,"/src/ygo_entity_proc/card_proc_definitions/tag_j/CardProcDefinitions_Junk_Monster.ts":Di,"/src/ygo_entity_proc/card_proc_definitions/tag_m/CardProcDefinitions_Metalfoes_Monster.ts":Pi,"/src/ygo_entity_proc/card_proc_definitions/tag_m/CardProcDefinitions_Metalfoes_NormalSpell.ts":Mi,"/src/ygo_entity_proc/card_proc_definitions/tag_r/CardProcDefinitions_Resonator_Monster.ts":Ai,"/src/ygo_entity_proc/card_proc_definitions/tag_s/CardProcDefinitions_SpellCounter_Monster.ts":xi,"/src/ygo_entity_proc/card_proc_definitions/tag_s/CardProcDefinitions_Stardust_Monster.ts":Fi,"/src/ygo_entity_proc/card_proc_definitions/tag_s/CardProcDefinitions_Synchron_NormalSpell.ts":Ni,"/src/ygo_entity_proc/card_proc_definitions/tag_s/CardProcDefinitions_Synchron_SyncroMonster.ts":Bi,"/src/ygo_entity_proc/card_proc_definitions/tag_t/CardProcDefinitions_Toon_ContinuousSpell.ts":Oi,"/src/ygo_entity_proc/card_proc_definitions/tag_v/CardProcDefinitions_Void_NormalSpell.ts":Li,"/src/ygo_entity_proc/card_proc_definitions/tag_w/CardProcDefinitions_WorldChalice_Monster.ts":qi,"/src/ygo_entity_proc/card_proc_definitions/type_Cyberse/CardProcDefinitions_Earth_Cyberse_lvl1_Monster.ts":Ri,"/src/ygo_entity_proc/card_proc_definitions/type_Fairy/CardProcDefinitions_Light_Fairy_lvl8_SyncroMonster.ts":Hi,"/src/ygo_entity_proc/card_proc_definitions/type_Fiend/CardProcDefinitions_Dark_Fiend_lvl4_Monster.ts":Zi,"/src/ygo_entity_proc/card_proc_definitions/type_Spellcaster/CardProcDefinitions_Dark_Spellcaster_lvl4_Monster.ts":$i,"/src/ygo_entity_proc/card_proc_definitions/type_Spellcaster/CardProcDefinitions_Light_Spellcaster_lvl5_PendulumMonster.ts":Gi,"/src/ygo_entity_proc/card_proc_definitions/type_Spellcaster/CardProcDefinitions_Wind_Spellcaster_lvl3_Monster.ts":ji})};for(const e of Object.keys(t))t[e].default&&(yield*t[e].default())}function*Lr(...t){const e={...Object.assign({"/src/ygo_entity_proc/card_proc_definitions/CardProcDefinitions_ContinuousSpell.ts":Vt,"/src/ygo_entity_proc/card_proc_definitions/CardProcDefinitions_ContinuousTrap.ts":zt,"/src/ygo_entity_proc/card_proc_definitions/CardProcDefinitions_CounterTrap.ts":Wt,"/src/ygo_entity_proc/card_proc_definitions/CardProcDefinitions_EquipSpell.ts":Qt,"/src/ygo_entity_proc/card_proc_definitions/CardProcDefinitions_EquipSpell_Preset.ts":Xt,"/src/ygo_entity_proc/card_proc_definitions/CardProcDefinitions_FieldSpell.ts":Kt,"/src/ygo_entity_proc/card_proc_definitions/CardProcDefinitions_FieldSpell_Preset.ts":Jt,"/src/ygo_entity_proc/card_proc_definitions/CardProcDefinitions_FusionMonster.ts":ei,"/src/ygo_entity_proc/card_proc_definitions/CardProcDefinitions_LinkMonster.ts":ti,"/src/ygo_entity_proc/card_proc_definitions/CardProcDefinitions_Monster.ts":ii,"/src/ygo_entity_proc/card_proc_definitions/CardProcDefinitions_Monster_Preset_DirectAttacker.ts":ai,"/src/ygo_entity_proc/card_proc_definitions/CardProcDefinitions_Monster_Preset_Recruiter.ts":ni,"/src/ygo_entity_proc/card_proc_definitions/CardProcDefinitions_NormalSpell.ts":ri,"/src/ygo_entity_proc/card_proc_definitions/CardProcDefinitions_NormalSpell_General_Draw.ts":si,"/src/ygo_entity_proc/card_proc_definitions/CardProcDefinitions_NormalSpell_Preset.ts":oi,"/src/ygo_entity_proc/card_proc_definitions/CardProcDefinitions_NormalTrap.ts":li,"/src/ygo_entity_proc/card_proc_definitions/CardProcDefinitions_NormalTrap_UponAttackDeclaration.ts":ci,"/src/ygo_entity_proc/card_proc_definitions/CardProcDefinitions_QuickPlaySpell.ts":ui,"/src/ygo_entity_proc/card_proc_definitions/CardProcDefinitions_RitualSpell.ts":pi,"/src/ygo_entity_proc/card_proc_definitions/CardProcDefinitions_SyncroMonster.ts":fi,"/src/ygo_entity_proc/card_proc_definitions/CardProcDefinitions_TestMonster.ts":hi,"/src/ygo_entity_proc/card_proc_definitions/CardProcDefinitions_XyzMonster.ts":gi}),...Object.assign({"/src/ygo_entity_proc/card_proc_definitions/character_yusei/CardProcDefinitions_Yusei_SyncroTunerMonster.ts":yi,"/src/ygo_entity_proc/card_proc_definitions/support_fusion/CardProcDefinitions_FustionSubstitude_Monster.ts":vi,"/src/ygo_entity_proc/card_proc_definitions/tag_b/CardProcDefinitions_BambooSword_EquipSpell.ts":Si,"/src/ygo_entity_proc/card_proc_definitions/tag_b/CardProcDefinitions_BambooSword_NormalSpell.ts":Ci,"/src/ygo_entity_proc/card_proc_definitions/tag_b/CardProcDefinitions_Blackwing_Monster.ts":Ti,"/src/ygo_entity_proc/card_proc_definitions/tag_c/CardProcDefinitions_Crystron_LinkMonster.ts":Ei,"/src/ygo_entity_proc/card_proc_definitions/tag_e/CardProcDefinitions_Exodia_Monster.ts":_i,"/src/ygo_entity_proc/card_proc_definitions/tag_f/CardProcDefinitions_Firewall_LinkMonster.ts":ki,"/src/ygo_entity_proc/card_proc_definitions/tag_f/CardProcDefinitions_Fusion_NormalSpell.ts":wi,"/src/ygo_entity_proc/card_proc_definitions/tag_i/CardProcDefinitions_Igknight_Monster.ts":bi,"/src/ygo_entity_proc/card_proc_definitions/tag_j/CardProcDefinitions_Junk_Monster.ts":Di,"/src/ygo_entity_proc/card_proc_definitions/tag_m/CardProcDefinitions_Metalfoes_Monster.ts":Pi,"/src/ygo_entity_proc/card_proc_definitions/tag_m/CardProcDefinitions_Metalfoes_NormalSpell.ts":Mi,"/src/ygo_entity_proc/card_proc_definitions/tag_r/CardProcDefinitions_Resonator_Monster.ts":Ai,"/src/ygo_entity_proc/card_proc_definitions/tag_s/CardProcDefinitions_SpellCounter_Monster.ts":xi,"/src/ygo_entity_proc/card_proc_definitions/tag_s/CardProcDefinitions_Stardust_Monster.ts":Fi,"/src/ygo_entity_proc/card_proc_definitions/tag_s/CardProcDefinitions_Synchron_NormalSpell.ts":Ni,"/src/ygo_entity_proc/card_proc_definitions/tag_s/CardProcDefinitions_Synchron_SyncroMonster.ts":Bi,"/src/ygo_entity_proc/card_proc_definitions/tag_t/CardProcDefinitions_Toon_ContinuousSpell.ts":Oi,"/src/ygo_entity_proc/card_proc_definitions/tag_v/CardProcDefinitions_Void_NormalSpell.ts":Li,"/src/ygo_entity_proc/card_proc_definitions/tag_w/CardProcDefinitions_WorldChalice_Monster.ts":qi,"/src/ygo_entity_proc/card_proc_definitions/type_Cyberse/CardProcDefinitions_Earth_Cyberse_lvl1_Monster.ts":Ri,"/src/ygo_entity_proc/card_proc_definitions/type_Fairy/CardProcDefinitions_Light_Fairy_lvl8_SyncroMonster.ts":Hi,"/src/ygo_entity_proc/card_proc_definitions/type_Fiend/CardProcDefinitions_Dark_Fiend_lvl4_Monster.ts":Zi,"/src/ygo_entity_proc/card_proc_definitions/type_Spellcaster/CardProcDefinitions_Dark_Spellcaster_lvl4_Monster.ts":$i,"/src/ygo_entity_proc/card_proc_definitions/type_Spellcaster/CardProcDefinitions_Light_Spellcaster_lvl5_PendulumMonster.ts":Gi,"/src/ygo_entity_proc/card_proc_definitions/type_Spellcaster/CardProcDefinitions_Wind_Spellcaster_lvl3_Monster.ts":ji})},i=[];for(const a of Object.values(e))if(a.default){for(const n of a.default())if(t.includes(n.name)){const r={...K[n.name]};let s=n.summonFilter;r.kind==="Monster"&&r.monsterCategories&&!n.summonFilter&&r.monsterCategories.union(Pt).length&&(s=_n),n.fusionMaterialInfos&&n.fusionMaterialInfos.some(l=>l.type==="Name")&&(r.textTags=[...r.textTags??[],...n.fusionMaterialInfos.filter(Fe).map(l=>l.cardName)]),yield{...n,summonFilter:s,staticInfo:r},i.push(n.name)}}yield*t.filter(a=>!i.includes(a)).map(a=>K[a]).filter(a=>a).filter(a=>a.kind==="Monster").filter(a=>{var n;return!((n=a.monsterCategories)!=null&&n.includes("Effect"))}).filter(a=>{var n;return!((n=a.monsterCategories)!=null&&n.includes("Pendulum"))}).map(a=>{var n;return i.push(a.name),{name:a.name,actions:(n=a.monsterCategories)!=null&&n.includes("SpecialSummon")?ot:En,staticInfo:a}}),i.length!==t.length&&console.log(t.filter(a=>!i.includes(a)))}const qr=t=>({...Fr(t),staticInfo:{name:t.profile.name,kind:"Monster",wikiEncodedName:"%A5%D7%A5%EC%A5%A4%A5%E4%A1%BC"}}),Rr=new Set,Ie=Xi;let Ui=0,Vi=0;for(const t of Or()){if(Rr.has(t.name))throw new Error(`カード定義重複${t.name}`);Ie[t.name]&&(Ie[t.name].isImplemented=!0,Ui++)}const K=Object.values(Ie).reduce((t,e)=>{var i;return e.monsterCategories&&!((i=e.monsterCategories)!=null&&i.includes("Effect"))&&!e.monsterCategories.includes("Pendulum")&&(e.isImplemented=!0,Vi++),e.isForTest&&e.isImplemented,t[e.name]=e,t},{}),ps=Ui,fs=Vi,et=[{id:-1,name:"サンプルデッキ１",deckType:"NPC",description:"",cardNames:["アンノウン・シンクロン","六武衆のご隠居","ジャンク・フォアード","ジャンク・フォアード","ジャンク・フォアード","チューン・ウォリアー","チューン・ウォリアー","ガード・オブ・フレムベル","ガード・オブ・フレムベル","守護竜ユスティア","守護竜ユスティア","エンジェル・トランペッター","エンジェル・トランペッター","ジェムナイト・サフィア","ジェムナイト・サフィア","魂虎","魂虎","暗黒界の番兵 レンジ","暗黒界の番兵 レンジ","バトルフットボーラー","バトルフットボーラー","球騎士の三人娘","球騎士の三人娘","エンジェル・トランペッター","エンジェル・トランペッター","Ｇ戦隊 シャインブラック","Ｇ戦隊 シャインブラック","しゃりの軍貫","しゃりの軍貫","ジョングルグールの幻術師","ジョングルグールの幻術師","ゾンビーノ","ゾンビーノ","メガロスマッシャーＸ","メガロスマッシャーＸ","ライドロン","ライドロン","機界騎士アヴラム","機界騎士アヴラム","幻のグリフォン","幻のグリフォン","幻殻竜","幻殻竜","アレキサンドライドラゴン","アレキサンドライドラゴン","ジェネティック・ワーウルフ","ジェネティック・ワーウルフ","サイバー・ドラゴン","フロストザウルス","フロストザウルス","フロストザウルス","青眼の白龍","マジカル・アンドロイド","マジカル・アンドロイド","マジカル・アンドロイド","大地の騎士ガイアナイト","大地の騎士ガイアナイト","大地の騎士ガイアナイト","スクラップ・デスデーモン","スクラップ・デスデーモン","スクラップ・デスデーモン","スターダスト・ドラゴン","スターダスト・ドラゴン","スターダスト・ドラゴン","ナチュル・ガオドレイク","ナチュル・ガオドレイク","ナチュル・ガオドレイク"]},{id:-2,name:"サンプルデッキ２",deckType:"NPC",description:"",cardNames:["アンノウン・シンクロン","六武衆のご隠居","ジャンク・フォアード","グローアップ・バルブ","ガード・オブ・フレムベル","伝説の白石","伝説の白石","伝説の白石","守護竜ユスティア","ギャラクシーサーペント","ジェネクス・コントローラー","Ｅ・ＨＥＲＯ フェザーマン","Ｅ・ＨＥＲＯ バーストレディ","チューン・ウォリアー","Ｅ・ＨＥＲＯ クレイマン","Ｅ・ＨＥＲＯ スパークマン","しゃりの軍貫","ジョングルグールの幻術師","ゾンビーノ","ジェネティック・ワーウルフ","ライトロード・ビースト ウォルフ","サイバー・ドラゴン","サイバー・ドラゴン","サイバー・ドラゴン","ラブラドライドラゴン","Ｄ－ＨＥＲＯ ディアボリックガイ","Ｄ－ＨＥＲＯ ディアボリックガイ","Ｄ－ＨＥＲＯ ディアボリックガイ","フロストザウルス","Ｅ・ＨＥＲＯ ネオス","青眼の白龍","青眼の白龍","青眼の白龍","Ｅ－エマージェンシーコール","おろかな埋葬","トレード・イン","トレード・イン","トレード・イン","闇の量産工場","強欲な壺","強欲な壺","強欲な壺","死者蘇生","死者蘇生","死者蘇生","召喚師のスキル","召喚師のスキル","召喚師のスキル","成金ゴブリン","成金ゴブリン","成金ゴブリン","戦士の生還","増援","調和の宝札","調和の宝札","調和の宝札","天使の施し","天使の施し","天使の施し","貪欲な壺","貪欲な壺","貪欲な壺","マジカル・アンドロイド","マジカル・アンドロイド","マジカル・アンドロイド","大地の騎士ガイアナイト","大地の騎士ガイアナイト","大地の騎士ガイアナイト","スクラップ・デスデーモン","スクラップ・デスデーモン","スクラップ・デスデーモン","スターダスト・ドラゴン","スターダスト・ドラゴン","スターダスト・ドラゴン","ナチュル・ガオドレイク","ナチュル・ガオドレイク","ナチュル・ガオドレイク"]},{id:-3,name:"サンプルデッキ３",deckType:"NPC",description:"",cardNames:["アンノウン・シンクロン","六武衆のご隠居","ジャンク・フォアード","グローアップ・バルブ","ガード・オブ・フレムベル","伝説の白石","伝説の白石","伝説の白石","守護竜ユスティア","ギャラクシーサーペント","ジェネクス・コントローラー","Ｅ・ＨＥＲＯ フェザーマン","Ｅ・ＨＥＲＯ バーストレディ","チューン・ウォリアー","Ｅ・ＨＥＲＯ クレイマン","Ｅ・ＨＥＲＯ スパークマン","しゃりの軍貫","ジョングルグールの幻術師","ゾンビーノ","ジェネティック・ワーウルフ","ライトロード・ビースト ウォルフ","サイバー・ドラゴン","サイバー・ドラゴン","サイバー・ドラゴン","ラブラドライドラゴン","Ｄ－ＨＥＲＯ ディアボリックガイ","Ｄ－ＨＥＲＯ ディアボリックガイ","Ｄ－ＨＥＲＯ ディアボリックガイ","フロストザウルス","Ｅ・ＨＥＲＯ ネオス","青眼の白龍","青眼の白龍","青眼の白龍","Ｅ－エマージェンシーコール","おろかな埋葬","トレード・イン","トレード・イン","トレード・イン","闇の量産工場","強欲な壺","強欲な壺","強欲な壺","死者蘇生","死者蘇生","死者蘇生","召喚師のスキル","召喚師のスキル","召喚師のスキル","成金ゴブリン","成金ゴブリン","成金ゴブリン","戦士の生還","増援","調和の宝札","調和の宝札","調和の宝札","天使の施し","天使の施し","天使の施し","貪欲な壺","貪欲な壺","貪欲な壺","マジカル・アンドロイド","マジカル・アンドロイド","マジカル・アンドロイド","大地の騎士ガイアナイト","大地の騎士ガイアナイト","大地の騎士ガイアナイト","スクラップ・デスデーモン","スクラップ・デスデーモン","スクラップ・デスデーモン","スターダスト・ドラゴン","スターダスト・ドラゴン","スターダスト・ドラゴン","ナチュル・ガオドレイク","ナチュル・ガオドレイク","ナチュル・ガオドレイク"]},{id:-9007199254740991,name:"FtkChallenge",deckType:"NPC",description:"FtkChallenge",cardNames:["封印されし者の右足","封印されし者の右腕","封印されし者の左足","封印されし者の左腕","封印されしエクゾディア","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン","スカゴブリン"]},{id:-1e3,name:"図書館エクゾプリセット",deckType:"Preset",description:"プリセット",cardNames:["封印されし者の右足","封印されし者の右腕","封印されし者の左足","封印されし者の左腕","封印されしエクゾディア","王立魔法図書館","王立魔法図書館","王立魔法図書館","召喚僧サモンプリースト","召喚僧サモンプリースト","召喚僧サモンプリースト","アンカモフライト","ダーク・バースト","チキンレース","チキンレース","チキンレース","テラ・フォーミング","トゥーン・ワールド","トゥーンのもくじ","トゥーンのもくじ","トゥーンのもくじ","一時休戦","黄金色の竹光","黄金色の竹光","黄金色の竹光","手札断殺","手札断殺","手札断殺","真刀竹光","成金ゴブリン","成金ゴブリン","成金ゴブリン","打ち出の小槌","打ち出の小槌","無の煉獄","無の煉獄","無の煉獄","妖刀竹光","妖刀竹光","妖刀竹光"]}],w=class w{constructor(e,i){o(this,"id");o(this,"name");o(this,"deckType");o(this,"description");o(this,"lastUsedAt");o(this,"cardNames");o(this,"getIllegalCardNames",()=>Array.from(new Set(this.cardNames.filter(e=>!Object.keys(K).includes(e)))));o(this,"getDisableCardNames",()=>Array.from(new Set(this.cardNames.filter(e=>!Object.keys(K).includes(e)))));o(this,"createCardInfos",()=>{const e=this.getIllegalCardNames();if(e.length>0)throw new Error(`存在しないカード名からデッキを生成しようとした。${e}`);return this.cardNames.map(i=>K==null?void 0:K[i]).filter(i=>i)});o(this,"copy",async()=>w.createNewDeck(this.name,this.description,this.cardNames));o(this,"updateTimestamp",async()=>{await w.tblHeader.update(this.id,e=>({...e,lastUsedAt:new Date}))});o(this,"saveDeckInfo",async e=>{const i=e??this;await w.tblHeader.update(this.id,r=>({...r,name:i.name,description:i.description,deckType:"User",lastUsedAt:new Date}));const a=(await w.tblDetail.getAll()).filter(r=>r.deckId===this.id);await w.tblDetail.delete(a.map(r=>r.id));const n=await w.tblDetail.insertMany(i.cardNames.map((r,s)=>({deckId:this.id,seq:s,name:r,description:""})));return new w(await w.tblHeader.get(this.id),n)});o(this,"delete",async()=>{await w.tblHeader.delete([this.id]);const e=(await w.tblDetail.getAll()).filter(i=>i.deckId===this.id);await w.tblDetail.delete(e.map(i=>i.id))});this.id=e.id,this.name=e.name,this.deckType=e.deckType,this.description=e.description,this.lastUsedAt=e.lastUsedAt,this.cardNames=i.filter(a=>a.deckId===this.id).map(a=>a.name)}};o(w,"toJson",e=>{const i=e.map(a=>{const{id:n,name:r,description:s,lastUsedAt:l,cardNames:u}=a;return{id:n,name:r,description:s,lastUsedAt:l,cardNames:u}});return i.forEach(a=>{a.cardNames=a.cardNames.map(n=>K[n]).sort(xt).map(n=>n.name)}),JSON.stringify(i,null,2)}),o(w,"convertToObjectURL",e=>{const i=w.toJson(e),a=new Blob([i],{type:"text/plain"});return window.URL.createObjectURL(a)}),o(w,"idb"),o(w,"tblHeader"),o(w,"tblDetail"),o(w,"getAllDeckInfo",async e=>{if(e&&(w.idb=e),!w.idb)throw new Error("illegal argument: idb is undefined.");w.tblHeader||(w.tblHeader=new Hr(w.idb)),w.tblDetail||(w.tblDetail=new Zr(w.idb));const i=await w.tblHeader.getAll(),a=await w.tblDetail.getAll();return i.length?i.map(n=>new w(n,a)):[await w.prepareSampleDeck()]}),o(w,"createNewDeck",async(e,i,a)=>{const n=await w.tblHeader.insert({name:e,description:i,deckType:"User",lastUsedAt:new Date}),r=await w.tblDetail.insertMany(a.map((s,l)=>({deckId:n.id,seq:l,name:s,description:""})));return new w(n,r)}),o(w,"prepareSampleDeck",async()=>{const e=et.find(i=>i.deckType==="Preset")??et.slice(-1)[0];return await w.createNewDeck(e.name,e.description,e.cardNames)});let kt=w;class Hr extends tt{constructor(i){super(i,"TblDeckHeader");o(this,"_prepareInitialRecords",()=>[])}}class Zr extends tt{constructor(i){super(i,"TblDeckDetail");o(this,"_prepareInitialRecords",()=>[])}}const hs=et.map(t=>({...t,lastUsedAt:new Date})).filter(t=>t.id<0);export{fs as A,ps as B,jr as C,kt as D,Ct as E,Tt as F,hs as G,$e as H,cs as I,ls as J,v as S,as as a,Xr as b,Qr as c,sa as d,Xe as e,os as f,ss as g,K as h,Jr as i,ds as j,us as k,be as l,ns as m,xt as n,zr as o,Vr as p,Ur as q,rs as r,es as s,is as t,Ki as u,ts as v,Ir as w,Yr as x,Kr as y,Wr as z};
